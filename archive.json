{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-05-18T00:43:53.404062+00:00",
  "repo": "quicwg/version-negotiation",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "1CEA8E"
    },
    {
      "name": "has-pr",
      "description": "",
      "color": "006b75"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU1NzIyNDQ4NDY=",
      "title": "In-line or routing promises vs compatibility",
      "url": "https://github.com/quicwg/version-negotiation/issues/1",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the common scenario where one has not deployed a new version to 100% of all potential endpoints all the time, the probability of a successful upgrade is p^n, where:\r\np = probability of landing on server with a proposed version being accepted\r\nn = number of \"nonsticky\" round trips\r\n\r\nIf the routing of the packets for an attempted session initiation/connection are routed to the same place, it becomes far more predictable.\r\n\r\nAll of the above is a long way of saying that compatible is not the same as in-line / routed to the same place.\r\n\r\nProviding an in-line upgrade capability allows a reasonably understandable site deployment to do an upgrade without surprising weirdness. Without this, even with \"compatible\" upgrades, there will be some \"fun\" deployment issues in practice.\r\n\r\n(Issue copied from [individual draft repo](https://github.com/ekr/draft-schinazi-quic-version-negotiation/issues/7), by @grmocg on 2019-11-19)",
      "createdAt": "2020-02-27T17:39:58Z",
      "updatedAt": "2021-01-14T01:17:53Z",
      "closedAt": "2021-01-14T01:17:53Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU1NzIyNDY5NzQ=",
      "title": "Do servers need to understand compatibility?",
      "url": "https://github.com/quicwg/version-negotiation/issues/2",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "If there is a definition for a mapping from vM to vN, can a client assume that the server will understand that mapping? Or does the client have to accept an incompatible version negotiation from servers?\r\n\r\nIt would be nice if compatible mappings could be developed separately from QUIC versions, which suggests that the server can decide whether to apply the mapping.\r\n\r\n(Issue copied from [individual draft repo](https://github.com/ekr/draft-schinazi-quic-version-negotiation/issues/6), by @martinthomson on 2019-11-12)",
      "createdAt": "2020-02-27T17:44:03Z",
      "updatedAt": "2021-01-14T01:17:54Z",
      "closedAt": "2021-01-14T01:17:54Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Copy of the conversation from the original issue:\r\n\r\n@ekr \r\n>Can you say more about \"mapping\"? I don't believe that appears in this document, so I'd like to make sure we are on the same page.\r\n\r\n@martinthomson \r\n>Sorry, I was using my own model. If you can use an initial flight from A to negotiate B (i.e., there is a mapping from that flight in A to the equivalent in B), then can the client expect that the server will understand that the two are compatible?\r\n>\r\n>I think that the inclusion of a list of compatible versions in the transport parameter implies that there is a need for a shared understanding of what is compatible. However, I don't think that is necessary.\r\n\r\n@ekr \r\n> So, say hypothetically we have version A and B, which are the same except that B uses a different code point for the CRYPTO frame. And so in principle, the client could send an Initial with version=A, compat_versions=[A, B] and the server could respond with B, but for some reason the server vendor doesn't realize this and instead sends VN = B?\r\n\r\n@martinthomson \r\n> Right. I don't know if this has implications for design, but it came up in our discussion of what ALPN applies to this morning.\r\n\r\n@DavidSchinazi \r\n> Perhaps we should state that for two versions to be compatible, there MUST be a document defining this mapping? But we need to handle the case where client believes A maps to B but the server doesn't know about this happing and sends a VN packet - the client needs to be OK with that?\r\n\r\n@martinthomson \r\n> Right. I think that clients need to be willing to accept version negotiation always. A server might not implement mappings or might only support trivial mappings.\r\n\r\n@ekr \r\n> Hmm.... I'm not sure I buy this. In other protocols (e.g., TLS), we don't have VN at all and just expect servers to properly implement the version negotiation mechanism, and there just isn't confusion about what's compatible. I agree we've had intolerance problems, but given that TLS negotiation is simpler than QUIC negotiation, it's not clear that falling back to VN will reduce those.\r\n\r\n@martinthomson \r\n> I see. You are concerned that clients being willing to accept VN will result in downgrades, even if they are only performance downgrades (you get the same end result, but with worse performance). Can't we address that with post-hoc validation of the version parameters?\r\n>\r\n> You can make part of the definition of B a requirement to understand a mapping from A, but if the mapping is defined separately, then you can't insist on the mapping being understood.\r\n\r\n@ekr \r\n> That's not my primary point. Rather, it just seems like this is creating a\r\nbunch of unnecessary confusion",
          "createdAt": "2020-02-27T17:47:00Z",
          "updatedAt": "2020-02-27T17:47:00Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "I believe clients always have to accept the incompatible-version path.  If the client offers A and knows that a mapping from A to B exists, that doesn't mean the server possesses that mapping.  From the server's point of view, if it only implements B, it's receiving a packet offering an unknown version.  It will send a VN packet, and expect the client to retry with B.\r\n\r\nThe only way around that is if the client also knows that the spec for B *requires* supporting a mapping from A.  I don't think we can assume that's the general case, though it might happen in some cases.",
          "createdAt": "2020-02-27T20:19:05Z",
          "updatedAt": "2020-02-27T20:19:05Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1NzIyNDk1MTU=",
      "title": "Comments from Mike Bishop",
      "url": "https://github.com/quicwg/version-negotiation/issues/3",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Comment from @MikeBishop [on the QUIC list](https://mailarchive.ietf.org/arch/msg/quic/0iAgoaoDaKyY_hsSYyyODe8o6HI) on 2019-11-06 :\r\n\r\n> Some notes:\r\n>\r\n>  *   Section 3:  \u201cVersion negotiation takes place after the retry cycle is over.\u201d  This is only possible for compatible versions; if the server does not support the version the client attempted, it obviously cannot send a Retry packet in that version, because Retry packets are version-specific.\r\n>  *   Section 3:  \u201cServers must retain the ability to process the Initial packet from older versions\u2026.\u201d  No, it means that if the server wants to avoid a VN packet, it needs to be able to process the Initial packet from the version the client tried.\r\n>  *   Section 4:  Rather than putting a count-prefixed list of versions, perhaps consider just embedding the VN packet payload?  It\u2019s equivalent, but easier to explain.\r\n>  *   Section 7:  Clearly it is possible to possible to add new frame types to Initial packets in a future version, I think what you mean to say is that this is a change that would break compatibility between versions.\r\n>\r\n> As a general statement on the document, you assume throughout that all versions have packet types, contain packet types called Initial and Retry, and that Initial packets contain frames.  The odds of those things being true across QUIC versions is likely high, but they\u2019re not invariants, so you can\u2019t assume them here.  You need to state general principles, and then use concepts from QUICv1 as examples of the principle.\r\n>\r\n> For example, rather than discussing version compatibility in terms of Initial packets, you might want to say that versions A and B are \u201ccompatible\u201d if the first flight of packets sent by the client in version A carries enough information for the server to generate the corresponding flight in version B, the server speaks version B, and is able to parse at least the first flight of version A.\r\n>\r\n> Also not discussed is the case where the server speaks version(s) which are compatible with what the client offered, but doesn\u2019t speak the version the client offered, even enough to generate the response.  With the right definition of \u201ccompatible,\u201d this just falls into the \u201cincompatible\u201d path and works for the server, but you need to call out the fact that the client shouldn\u2019t consider it an error if the server uses the incompatible path between versions that the client thinks are compatible.",
      "createdAt": "2020-02-27T17:48:44Z",
      "updatedAt": "2021-01-14T01:17:54Z",
      "closedAt": "2021-01-14T01:17:54Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU1NzIyNTAzNzQ=",
      "title": "Change framing to improve clarity",
      "url": "https://github.com/quicwg/version-negotiation/issues/4",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Comment from @martinthomson [on the QUIC list](https://mailarchive.ietf.org/arch/msg/quic/x-P5DpFQovPTHi_pkaLVsiC8j10) on 2019-11-04:\r\n\r\n> Hi David,\r\n>\r\n> I think that this is broadly the right mechanism.  It would be good to validate it more thoroughly.  \r\n>\r\n> The model and framing could use a little work.\r\n>\r\n> I struggled a little with the framing here because the split between incompatible and compatible versions is very important, but also unclear.  The definition of \"compatible\" is left for Section 7, but it seems like it should be right up front.\r\n>\r\n> The framing I would choose puts the model up front.  The model that you have have two layers that are applied progressively:\r\n>\r\n> 1. incompatible version negotiation, where the server sends a Version Negotiation packet in response to a version it does not understand.\r\n>\r\n> 2. compatible version negotiation, where the server can generate interpret a version X Initial packet and continue with version Y.\r\n>\r\n> Regarding the model, the definition of \"compatible\" needs work.\r\n>\r\n> I observe that you only need a mapping from \"Initial\"-equivalent packets in X to the same in Y - and maybe the ability to generate a Retry in version X (more below) - in order for this to work.  That's where there is a clear functional mapping from a version X packets that initiate the connection to something that fills the same purpose in version Y.  \r\n>\r\n> But the definition you have for \"compatible\" implies that the mapping is bijective, which I don't think is necessary.  As the draft says, version Y might define (and allow) new frame types in its Initial-equivalent packet(s), but as long as those are either optional or can be synthesized from X, that's OK.  It isn't necessary that every Y have a functional representation in X.  We might not want to define a way to negotiate an older version from a newer one (or at least not for every case).\r\n>\r\n> The ability to generate a Retry stretches this definition a little.  Can you explain why you can't generate a version Y Retry?  I have an inkling, but it's not fully formed.  It complicates the model more than I'd like to have it this way around.",
      "createdAt": "2020-02-27T17:50:25Z",
      "updatedAt": "2021-01-14T01:17:54Z",
      "closedAt": "2021-01-14T01:17:54Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU1NzIyNTEyNzY=",
      "title": "The client is unable to detect downgrade attacks",
      "url": "https://github.com/quicwg/version-negotiation/issues/5",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While I recognize that it is an explicit design choice of this extension to move all the downgrade detection to the server, it seems unfortunate to prevent the client from detecting the downgrade and instead relying on the server to do so. (I could imagine that some server implementations are lazy/broken and might not perform this detection)?\r\n\r\nAlternatively, if the server delivered to the client a set of lists of versions that the server (or the server's peers) might have sent in VN packets, then the client could compare the actual VN packet it received with the elements in the set and detect the case where none of them match. Commonly the server would send one such list, but if it were participating in a staggered rollout, it could send both the \"old\" and \"new\" lists?\r\n\r\n(Issue copied from [individual draft repo](https://github.com/ekr/draft-schinazi-quic-version-negotiation/issues/3), by @RyanTheOptimist on 2019-11-04)",
      "createdAt": "2020-02-27T17:52:03Z",
      "updatedAt": "2021-02-05T00:28:59Z",
      "closedAt": "2021-02-05T00:28:59Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `Server Handshake Version Information` contains all versions supported by the server, so the client could easily perform that verification, taking care to:\r\n* remove the current version from `Supported Version`\r\n* remove any greasing version both from `Supported Version` and from the versions in the VN packet\r\n* ignoring the ordering of versions (dependent on the outcome of https://github.com/quicwg/base-drafts/issues/4743)\r\n\r\nOpen question: Should the client also check that the server actually performed a version upgrade, if there's a version supported by both endpoints with a higher preference than the currently selected version?",
          "createdAt": "2021-01-15T03:35:24Z",
          "updatedAt": "2021-01-15T03:35:24Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "@marten-seemann, what is \"Server Handshake Version Information\"? I don't see that string in this draft. Is it in a different doc?",
          "createdAt": "2021-01-15T15:38:45Z",
          "updatedAt": "2021-01-15T15:38:45Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I was looking at #11, as I assumed that\u2019s the direction this draft is moving in.",
          "createdAt": "2021-01-15T17:01:08Z",
          "updatedAt": "2021-01-15T17:01:08Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "Oh, I see. Yes, I agree that #11 fixes this issue.",
          "createdAt": "2021-01-15T18:00:33Z",
          "updatedAt": "2021-01-15T18:00:33Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU1NzIyNTIwMzE=",
      "title": "Should \"Compatible Version\" mention 0-RTT?",
      "url": "https://github.com/quicwg/version-negotiation/issues/6",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Consider the case of two difference QUIC versions which are roughly identical in terms of the crypto/handshake/packet layer. But imagine that these two versions, say, renumber streams or some other change which makes 0-RTT data look different. I would assume that such versions would not be \"compatible\" for the purposes of section 7?\r\n\r\nOr alternatively, they could be considered compatible, but the server MUST not process 0-RTT packets, and the client must \"unwind\" the 0-RTT state (un-open streams, etc)?\r\n\r\n(Issue copied from [individual draft repo](https://github.com/ekr/draft-schinazi-quic-version-negotiation/issues/2), by @RyanTheOptimist on 2019-11-04)",
      "createdAt": "2020-02-27T17:53:30Z",
      "updatedAt": "2021-01-14T01:17:54Z",
      "closedAt": "2021-01-14T01:17:54Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Comment](https://github.com/ekr/draft-schinazi-quic-version-negotiation/issues/2#issuecomment-549562670) from @DavidSchinazi on 2019-11-04:\r\n\r\nI agree, we should add text to discuss this, perhaps in a section of recommendations for writers of new versions. When deciding whether two versions are compatible, the cost of rewriting 0-RTT data from one version to the next should be taken into account.",
          "createdAt": "2020-02-27T17:54:28Z",
          "updatedAt": "2020-02-27T17:54:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Comment](https://github.com/ekr/draft-schinazi-quic-version-negotiation/issues/2#issuecomment-555826187) from @grmocg on 2019-11-19:\r\n\r\nInterested in seeing where this goes.",
          "createdAt": "2020-02-27T17:55:10Z",
          "updatedAt": "2020-02-27T17:55:10Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "It definitely should discuss 0-RTT.  I suspect the same language *could* hold, in that for certain pairs of versions it might be possible to construct up-level 0-RTT packets from down-level 0-RTT packets and pretend that's what you received.  However, I suspect that won't be true for all compatible version pairs; tolerating that would mean that you have versions which are Initial-compatible and versions which are I/0-compatible, and you'd have to define behavior between them.\r\n\r\nIt might be simpler to say that if the server wants to change versions, it MUST reject Early Data.",
          "createdAt": "2020-12-14T18:48:44Z",
          "updatedAt": "2020-12-14T18:48:44Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2NjgwMzU1MTQ=",
      "title": "Client Offer Version-Specific Transport Parameters",
      "url": "https://github.com/quicwg/version-negotiation/issues/8",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Related to https://github.com/quicwg/base-drafts/issues/3965.\r\n\r\nShould the version negotiation transport parameter allow for (optionally) encoding transport parameters specific to each compatible version? This might improve the range of compatible versions in the future.\r\n\r\nFor instance, if version 2 changed the meaning of one of the existing transport parameters such that it wasn't directly compatible with version 1's TPs, this would allow the versions themselves to still be considered compatible, because the client could just offer the v2 TPs along with the v1.",
      "createdAt": "2020-07-29T18:04:12Z",
      "updatedAt": "2021-01-14T01:17:55Z",
      "closedAt": "2021-01-14T01:17:55Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks I'm not sure I understand the problem that this solves. If there is a v2-only TP, the client can send it in v1 and rely on the fact that v1 servers ignore unknown TPs. Could you write up a specific example where this would be useful?",
          "createdAt": "2020-07-29T19:33:01Z",
          "updatedAt": "2020-07-29T19:33:01Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Any kind of breaking change to an existing transport parameter, where the new encoding format in v2 is incompatible with v1.\r\n\r\nFor instance, say `max_udp_payload_size` was changed to require two numbers, a v4 and v6 specific value. I know this is a contrived example, but if something like it happens in the future, the client cannot send a value for 'max_udp_payload_size` that generically works for both v1 and v2. Without this feature, v1 and v2 would have to be considered incompatible.\r\n\r\nAnother example, would be a transport parameter that is explicitly disallowed to be sent by the client in v1, but then is allowed (required?) in v2. If it's not required, the client just wouldn't be able to take advantage of the feature tied to the TP, but if it goes from disallowed to required, then the versions become incompatible. For example `stateless_reset_token`.",
          "createdAt": "2020-07-29T19:49:42Z",
          "updatedAt": "2020-07-29T19:51:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This doesn't sound like the right solution. If we want to change the format of `max_udp_payload_size` in v2, we can give it a new TP ID. That allows the two versions to be compatible. Similarly, if we want to switch a TP from disallowed to required, we can give it a new ID.\r\n\r\nDo you have any use-cases that can't be solved by changing the Transport Parameter IDs when changing a TP's meaning?",
          "createdAt": "2020-07-29T19:59:06Z",
          "updatedAt": "2020-07-29T19:59:06Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "What about if any transport parameter goes from required in v1 to disallowed in v2?",
          "createdAt": "2020-07-29T20:03:34Z",
          "updatedAt": "2020-07-29T20:03:42Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I mentioned in https://github.com/quicwg/version-negotiation/issues/8#issuecomment-665880750 , in that scenario we'd give this TP a new ID in v2.",
          "createdAt": "2020-07-29T20:17:18Z",
          "updatedAt": "2020-07-29T20:17:18Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Yeah, I guess. You just never have a breaking change by constantly appending new transport parameters and ignoring old/deprecated ones. Then the client just sends the superset of all parameters for all versions. It just means you can never actually change the meaning of a transport parameter for with a particular numeric value. If folks are fine with that restriction for transport parameters, then I'm fine closing this issue.\r\n\r\nOne thought though then, when connecting using version negotiation, the client might use the lowest compatible version number for the packet, but it should supply the highest compatible (superset) version of the transport parameters. Does the spec call this out already?",
          "createdAt": "2020-07-29T20:30:25Z",
          "updatedAt": "2020-07-29T20:30:25Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "However, as noted in https://github.com/quicwg/base-drafts/issues/4369, we have created such a breaking change between draft versions and version 1.  The TLS codepoint used for the transport parameters changed between versions.  This needs to be addressed in the definition of being able to craft an appropriate Initial in the new version, because there are multiple paths one could choose:\r\n\r\n- Require the client to include both TP extensions, so the server can respond only to the one used by the QUIC version it selects.\r\n    - This pair of versions might be either compatible or incompatible, depending on whether the client includes both TPs in its ClientHello.\r\n    - This solution isn't desirable long-term, because we don't want QUIC clients squatting on private-use space indefinitely.\r\n- Require the server to modify the client's TLS message in well-defined ways as part of constructing an up-level Initial.\r\n    - If the client doesn't have a way to make those changes to an in-progress handshake and/or restart a handshake by inputting a ClientHello, it will fail.\r\n    - PSK binders could complicate this further; this would likely mean it's not possible to do some compatible version changes while doing 0-RTT.\r\n\r\nSo while the contents of the TP shouldn't be breaking between versions, we have an existence proof of breaking changes in the means of carrying the transport parameters.",
          "createdAt": "2020-12-14T18:45:04Z",
          "updatedAt": "2020-12-14T18:45:04Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU3NjY4MjEyOTM=",
      "title": "Editor's Copy link is broken",
      "url": "https://github.com/quicwg/version-negotiation/issues/9",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Looks like `gh-pages` contains a draft, but GitHub isn't rendering it.  Is GitHub Pages enabled?",
      "createdAt": "2020-12-14T18:54:11Z",
      "updatedAt": "2020-12-14T20:05:00Z",
      "closedAt": "2020-12-14T20:05:00Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thanks @MikeBishop. Yes it seems link GitHub pages was not enabled. I've fixed that now and the page is hosted on https://quicwg.org/version-negotiation/draft-ietf-quic-version-negotiation.html\r\n\r\nThe link in README.md seems to be bogus. I've made PR #10 to fix it up.",
          "createdAt": "2020-12-14T19:08:09Z",
          "updatedAt": "2020-12-14T19:08:09Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3ODYzMDc5MjE=",
      "title": "Define v1 and draft-29 Compatibility",
      "url": "https://github.com/quicwg/version-negotiation/issues/12",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The primary versions available to us to test this new version negotiation process are draft-29 and upcoming v1 versions. It probably makes sense to define the compatibility rules for these so that we can test everything out.",
      "createdAt": "2021-01-14T20:29:47Z",
      "updatedAt": "2021-07-26T00:54:13Z",
      "closedAt": "2021-07-26T00:54:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My main concern is that these two versions are very hard to implement compatibility for, because of the TLS codepoint change. Because of that, I don't think Google would implement this. But if we have multiple implementors interested, then we should do it.",
          "createdAt": "2021-01-14T20:34:01Z",
          "updatedAt": "2021-01-14T20:34:01Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I agree it would be tricky. I'd have to double check our logic in MsQuic, but I think it would be easy enough on the server side, but definitely trickier on the client side.",
          "createdAt": "2021-01-14T20:38:20Z",
          "updatedAt": "2021-01-14T20:38:20Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since RFC 9000 has been published, I think interest in draft-29 is declining. @nibanks how do you feel about closing this issue?",
          "createdAt": "2021-07-25T23:52:02Z",
          "updatedAt": "2021-07-25T23:52:02Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Sure, good ahead.",
          "createdAt": "2021-07-26T00:54:03Z",
          "updatedAt": "2021-07-26T00:54:03Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3ODY1MDg1MTQ=",
      "title": "Is the server required to upgrade versions?",
      "url": "https://github.com/quicwg/version-negotiation/issues/13",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Let's assume both client and server support compatible versions `X` and `Y`, and the server prefers `Y` over `X`.\r\nThe client now initiates a connection using version `X`, for some reason though the conversion from `X` to `Y` fails.\r\n\r\nAs the draft is written now, the only way for the server to proceed here is to perform Incomptabile Version Negotiation, i.e. send a VN packet. While this rule makes the process deterministic (and might allow the client to verify the result of the version negotiation, see the open question in https://github.com/quicwg/version-negotiation/issues/5#issuecomment-760623428), it also costs a round trip. When the differences between `X` and `Y` are small, a server might prefer to not bother with upgrading the version, and just establish a connection using `X`. Should we allow that?",
      "createdAt": "2021-01-15T03:43:38Z",
      "updatedAt": "2021-02-05T00:28:59Z",
      "closedAt": "2021-02-05T00:28:59Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand the scenario you have in mind here. How would the conversion from X to Y fail? This seems like it shouldnt' happen and should just cause connection failure.",
          "createdAt": "2021-01-15T04:11:41Z",
          "updatedAt": "2021-01-15T04:11:41Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr Looking at #11, it says:\r\n> Note that version compatibility does not mean that every single possible instance of a first flight will succeed in conversion to the other version. For example, if version B is equal to A in all aspects except it introduced a new frame in its first flight that version A cannot parse or even ignore, then A could still be compatible with B as conversions would succeed for connections where that frame is not used.",
          "createdAt": "2021-01-15T04:21:15Z",
          "updatedAt": "2021-01-15T04:21:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, well I haven't reviewed #11 but that sounds wrong to me.",
          "createdAt": "2021-01-15T04:31:56Z",
          "updatedAt": "2021-01-15T04:31:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You're right @marten-seemann that was an oversight. In #11, I've replaced:\r\n> If any of these operations fail, the server uses incompatible version negotiation instead, see {{incompat-vn}}.\r\n\r\nwith:\r\n> If any of these operations fail, the server will use the original version if it supports it, and if it doesn't then the server will perform incompatible version negotiation instead, see {{incompat-vn}}.",
          "createdAt": "2021-01-15T23:00:06Z",
          "updatedAt": "2021-01-15T23:00:06Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU3ODY1MTA4MDM=",
      "title": "Client's version preference is ignored",
      "url": "https://github.com/quicwg/version-negotiation/issues/14",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Assume that both endpoints support compatible versions `A` and `B`, but the client prefers version `A` over version `B`, while the server prefers version `B` over version `A`.\r\n\r\nWhen the server receives a connection attempt using version `A`, it will detect that the client also supports `B`, and convert it to version `B`. The connection therefore ends up with version `B`.\r\n\r\nIs that what we want?  One could argue that the version in use should be controlled by the client, not by the server. This could be easily achieved by only allowing the server to switch to version `B` if the client expressed a preference for `B` over `A`.",
      "createdAt": "2021-01-15T03:50:27Z",
      "updatedAt": "2021-02-05T00:28:59Z",
      "closedAt": "2021-02-05T00:28:59Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related: @kazuho's comment on https://github.com/quicwg/base-drafts/issues/4743#issuecomment-760574432.",
          "createdAt": "2021-01-15T03:54:47Z",
          "updatedAt": "2021-01-15T03:54:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I believe that having the server choose is the right answer. We already have experience with it in TLS where it works reasonably well. It's also hard to enforce the client chooses rule when the client speaks first and offers all its supported versions. The server can just pretend it only supports B and just speaks the A Initial format.",
          "createdAt": "2021-01-15T04:09:11Z",
          "updatedAt": "2021-01-15T04:09:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @ekr, letting the server choose whether to follow the client's preference or not seems simplest.",
          "createdAt": "2021-01-15T22:55:08Z",
          "updatedAt": "2021-01-15T22:55:08Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3OTA2NzEzOTE=",
      "title": "Server behavior when the transport parameter is malformed or conflicting?",
      "url": "https://github.com/quicwg/version-negotiation/issues/15",
      "state": "CLOSED",
      "author": "anrossi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Looking at #11, how should the server respond if the Client Handshake Version Negotiation Information is malformed? For example, the QUIC version in the long header is different from the Current Attempted Version field in the transport parameter?\r\nShould the server continue with the Original Version in the long header (assuming it is supported), or attempt incompatible version negotiation?\r\n(related to #13)",
      "createdAt": "2021-01-21T04:04:40Z",
      "updatedAt": "2021-01-23T03:47:37Z",
      "closedAt": "2021-01-23T03:47:37Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the Client Handshake Version Negotiation Information is malformed (too short to be parsed or something like that) or if it fails to validate (e.g. Current Attempted Version field differs from the long header's version) then the server MUST close the connection with VERSION_NEGOTIATION_ERROR. I've added text to #11's \"Version Downgrade Prevention\" section to make that explicit.",
          "createdAt": "2021-01-21T23:02:22Z",
          "updatedAt": "2021-01-21T23:02:22Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "According to the principles we used in QUIC v1, I would've expected a TRANSPORT_PARAMETER_ERROR if parsing fails and a VERSION_NEGOTIATION_ERROR if validation fails.",
          "createdAt": "2021-01-22T01:28:04Z",
          "updatedAt": "2021-01-22T01:28:04Z"
        },
        {
          "author": "anrossi",
          "authorAssociation": "NONE",
          "body": "My confusion comes from the line in Compatible Version Negotiation:\r\n\r\n> If any of these operations fail, the server will use the original version if it supports it\r\n\r\nIt seems ambiguous whether this is referring only to the attempt to convert the received flight to a newer version, or whether it  also includes the potential failures in parsing.\r\n@marten-seemann brings up a good point too.",
          "createdAt": "2021-01-22T22:29:48Z",
          "updatedAt": "2021-01-22T22:29:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see. I've clarified that sentence to explicitly rule out parsing and validation failures. I also changed the error code.",
          "createdAt": "2021-01-22T22:34:11Z",
          "updatedAt": "2021-01-22T22:34:11Z"
        },
        {
          "author": "anrossi",
          "authorAssociation": "NONE",
          "body": "Looks good to me! Thanks",
          "createdAt": "2021-01-23T03:47:37Z",
          "updatedAt": "2021-01-23T03:47:37Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU4MDQxNjk0NzI=",
      "title": "What happens when conversion fails?",
      "url": "https://github.com/quicwg/version-negotiation/issues/17",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "In [Section 3.3](https://www.ietf.org/archive/id/draft-ietf-quic-version-negotiation-03.html#section-3.3-2) it talks about the server picking a compatible version and then converting the first flight.  As noted in the definition of compatible, it is not sufficient that the transform exist, it also has to succeed.  In the example given, there might be reasons that a conversion could fail (such as the inclusion of information that is optional and cannot be transformed).\r\n\r\nIn other words, the version might be compatible but the handshake is not.  There are three possible outcomes I see here:\r\n\r\n1. This eliminates that version from the set of compatible options.  The server is free to try another compatible version or just give up and use the offered version.  I don't like this much as it implies a denial of service attack on a server that is willing to try multiple compatible versions.\r\n2. The server can regard all attempts at compatible versions to have failed and it could send a Version Negotiation packet in response.  I am happier with this, but only marginally.  It could hide a genuine error on the part of the client.  That error manifests as a performance bug.  As clients should not ever offer a handshake that includes a compatible version that can't be used, this suggests option 3...\r\n3. The server regards this as a fatal error.  The server uses a signal appropriate to the original version to indicate handshake failure.  Ideally, any version that has other versions compatible with it defines an error code for this purpose.",
      "createdAt": "2021-02-09T03:23:29Z",
      "updatedAt": "2021-12-02T21:27:28Z",
      "closedAt": "2021-12-02T21:27:28Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It could hide a genuine error on the part of the client.\r\n\r\nCan you elaborate on that? In my mental model, one of the reasons why conversion could fail is that the client is offering an extension which only works with the original, but not the upgraded version. In that case conversion would fail, even though the two versions are compatible in general.\r\n\r\nI think this would rule out 3. the client didn\u2019t do anything wrong, and therefore shouldn\u2019t receive an error.",
          "createdAt": "2021-02-10T04:34:42Z",
          "updatedAt": "2021-02-10T04:34:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Tue, Feb 9, 2021 at 8:34 PM Marten Seemann <notifications@github.com>\nwrote:\n\n> It could hide a genuine error on the part of the client.\n>\n> Can you elaborate on that? In my mental model, one of the reasons why\n> conversion could fail is that the client is offering an extension which\n> only works with the original, but not the upgraded version. In that case\n> conversion would fail, even though the two versions are compatible in\n> general.\n>\n\nMy view is that either the conversion process should describe how to\ndiscard that data or the client should not include it.\n",
          "createdAt": "2021-02-10T04:37:25Z",
          "updatedAt": "2021-02-10T04:37:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I agree with @ekr here.  If the conversion hits something that it doesn't know how to convert, which seems possible if you consider the range of options that might exist, then that's an error.  Either client shouldn't have included it, or the server is ignorant of how the conversion should operate.\r\n\r\nIn most cases I can think of, stuff that is only valid for the original version can just be thrown away when converting.\r\n\r\nConcrete example of a case that might fail.  Say that we change the rules for Initial packets in QUICv2 to make the minimum size of the DCID 10 bytes (up from 8 in v1).  A client that offers a QUICv1 Initial with an 8-byte DCID would be valid in v1, but it is invalid in v2.  Thus, the rule might be that the client always provide at least 10 bytes in its DCID.  If the client didn't do that, but offered v2 as compatible, it has a bug and the connection shouldn't proceed.",
          "createdAt": "2021-02-10T08:27:56Z",
          "updatedAt": "2021-02-10T08:27:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with you, though I'm not sure what you're asking in terms of changes to the draft - what's missing? Should we define the concept of conversion better to explain that a conversion cannot fail - or is this about how the server should react when the client sent something that it knew would fail?",
          "createdAt": "2021-02-11T02:35:40Z",
          "updatedAt": "2021-02-11T02:35:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "[This text](https://tools.ietf.org/id/draft-ietf-quic-version-negotiation-03.html#section-3.3-2) in Section 3.3 seems to just assume that this conversion process works:\r\n\r\n> If the server supports one of the client's compatible versions, and the server also believes that the original version is compatible with this version, then the server converts the client's first flight to that version and replies to the client as if it had received the converted first flight. ",
          "createdAt": "2021-02-11T02:55:18Z",
          "updatedAt": "2021-02-11T02:55:18Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU4MDQxNzg0NDk=",
      "title": "Stable address tuple",
      "url": "https://github.com/quicwg/version-negotiation/issues/18",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "[Section 3.3](https://www.ietf.org/archive/id/draft-ietf-quic-version-negotiation-03.html#section-3.3-4) indicates that the address tuple used for the first flight remain stable.  This is probably OK, but I think that this is unnecessary.\r\n\r\nWhat seems particularly risky here is anticipating the rules about connection IDs that might apply to both versions:\r\n\r\n> During that time, clients MUST also use the same Destination Connection ID, except if the server explicitly instructs the client to use a different Destination Connection ID (\\[v1 example...]).\r\n\r\nMy preference here is to drop this text entirely and leave it to the negotiated version to specify these rules.  Once you have performed whatever mapping/transformation that is defined, then the first flight complies with the requirements of the negotiated version and you are subject to the rules of that version.\r\n\r\nTrying to manage the intersection of both sets of rules is complicated.  Better not to chase down that rabbit hole (I've been there).\r\n\r\nFWIW, I fully expect v2 to also specify address tuple stability during the handshake.  However, if it does not and a client can send a v2 first flight on multiple tuples (leaving aside the implausibility of expecting those datagrams to arrive at the same place), then that won't be naturally compatible with v1 and you won't be able to start with v2 in that way and expect to be able to negotiate v1 out of that.  This is no different than your new, optional frame example.",
      "createdAt": "2021-02-09T03:46:35Z",
      "updatedAt": "2021-12-02T21:26:49Z",
      "closedAt": "2021-12-02T21:26:49Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we need to state something about 5-tuple stability here, because if version A requires 5-tuple stability and version B requires 5-tuple stability, neither of those documents specifies that the two halves of the handshake (the first half using A, and the second half using B) need 5-tuple stability between them.",
          "createdAt": "2021-02-11T02:38:14Z",
          "updatedAt": "2021-02-11T02:38:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I don't think that you need to say anything about that specifically.  You might use it as an example in a sentence like:\r\n\r\n> After the first flight is converted to the negotiated version, the handshake completes in the negotiated version.  The entire handshake (including the converted first flight) needs to conform to the rules of the negotiated version.  For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the handshake, including the first flight.",
          "createdAt": "2021-02-11T02:57:38Z",
          "updatedAt": "2021-02-11T02:57:38Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough, that works for me.",
          "createdAt": "2021-02-11T03:00:46Z",
          "updatedAt": "2021-02-11T03:00:46Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU4MDQxODI5MjU=",
      "title": "Listing all versions is unnecessary",
      "url": "https://github.com/quicwg/version-negotiation/issues/19",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The current approach is somewhat maximal when it comes to listing versions.  This is the most cautious approach, but I am certain that this is unnecessary.  In some cases, that might be bad.\r\n\r\nA server does not need to list compatible versions.  A client doesn't benefit from knowing what compatible options the server supports.  It's just wasted bytes.  If the client offered the compatible version and the server supports it, it is not relevant because otherwise the server would have picked it.  If the client did not offer the compatible version, then there is no hope of that being selected either (an alternative outcome to #17 might invalidate this outcome, but I'm assuming that my preferred outcome is what happens there).  Thus, the only requirement is that the server offer information about the versions that are incompatible.\r\n\r\nA client does not need to list the versions it received in a Version Negotiation packet.  The information it receives about incompatible versions from the server is sufficient for it to authenticate the information it receives there.\r\n\r\nTo up-level slightly, I think that the logic we use to determine what is in this field is simple.  The endpoint that decides needs to be presented with an authenticated copy of the information it might use to make its decision.  Thus, the server needs to know about all compatible versions and the client needs to know about all incompatible versions.\r\n\r\nTo that end, you don't necessarily need to have the client indicate which version it attempted first.  It can just look at the list of incompatible versions the server supports and abort if it sees that version there.\r\n\r\nAll that said, I think that it is not bad that the client include the current version here.  That's critical information that we aren't necessarily avoiding here.  Note though that this does mean that when you transform a vN Initial to a vM Initial, you can't transform that field, so you have to tolerate this being the *original* version. (I'll open another issue for that.)\r\n\r\n",
      "createdAt": "2021-02-09T03:59:39Z",
      "updatedAt": "2021-05-27T01:42:00Z",
      "closedAt": "2021-05-27T01:42:00Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A server does not need to list compatible versions. A client doesn't benefit from knowing what compatible options the server supports. It's just wasted bytes. If the client offered the compatible version and the server supports it, it is not relevant because otherwise the server would have picked it. If the client did not offer the compatible version, then there is no hope of that being selected either (an alternative outcome to #17 might invalidate this outcome, but I'm assuming that my preferred outcome is what happens there). Thus, the only requirement is that the server offer information about the versions that are incompatible.\r\n\r\nAs you pointed out, the client and server can disagree on which versions are compatible - so the server can't know the full list of which versions the client thinks are compatible. Or are you just suggesting to remove the versions that the client listed as compatible from this list? That sounds like added complexity to save a very small number of bytes.\r\n\r\n> A client does not need to list the versions it received in a Version Negotiation packet. The information it receives about incompatible versions from the server is sufficient for it to authenticate the information it receives there.\r\n\r\nHow does the server ensure that the version negotiation packet was not tampered with then?",
          "createdAt": "2021-02-11T02:42:34Z",
          "updatedAt": "2021-02-11T02:42:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "> the client and server can disagree on which versions are compatible \r\n\r\nI only suggested that the client might make a mistake in constructing its first flight.\r\n\r\nI don't think that I ever said that the client and server can disagree.  Or more to the point, I didn't suggest that we deliberately allow one to believe that versions are compatible when the other does not.  That said, I guess it would be possible under what I describe, for either to believe that a version is compatible and the other to disagree.  That might not be good though, because it limits validation options.\r\n\r\nHowever, if you think it through it isn't at all good:\r\n* A client lists version X listed as compatible.  The server supports that version, but doesn't believe it is compatible.  The server can then not choose that version.  The server instead lists that as an incompatible version.  The client would have preferred version X, but chose to offer a more compatible version.  Client is forced to take another round trip to get what it wants.\r\n* A client chooses not to list version X as compatible.  The server believes it is compatible, so omits it.  The client would have preferred it had it known about it, but it isn't able to learn that the server supports it.  (This is the case your design addresses.)\r\n\r\nI would rather not to deal with any ambiguity.  I think that support for a version needs to include compatibility, so that if you support X, you automatically understand its compatibility.  If you want definition of compatibility to be separate from definition of a version, then yes, the server might need to list those versions it regards as compatible along with the incompatible ones.\r\n\r\nYou could make this a per-version thing - if a version *might* be incompatible, then it is listed as incompatible.  That is, if there is an optional compatibility for that version, then you might have to assume that the client doesn't know about that compatibility.  That would be my preference.\r\n\r\n> How does the server ensure that the version negotiation packet was not tampered with then?\r\n\r\nThe only thing that matters to the client is that it is able to authenticate that the versions it might choose in place of the currently offered version are known to it.  You are suggesting that we need to authenticate the bits that were sent in the packet.  We don't need that.  We don't need to list versions that the doesn't support (though of course the server doesn't know that for anything other than greasing versions).  We don't need to authenticate the ordering either.",
          "createdAt": "2021-02-11T03:09:32Z",
          "updatedAt": "2021-02-11T03:09:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From Section 2:\r\n> Note that both endpoints might disagree on whether two versions are compatible or not. For example, two versions could have been defined concurrently and then specified as compatible in a third document much later - in that scenario one endpoint might be aware of the compatibility document while the other may not.\r\n\r\nI think that this scenario is realistic, and that's why the current design supports it.\r\n\r\nOn the topic of validating every single bit of the VN packet, I will say that statements to the tune of \"we don't need to authenticate XYZ, just authenticating X is enough\" were the source of many of the security vulnerabilities in TLS. I don't feel confident enough to find the exact bounds of what needs to be authenticated, so authenticating everything is safe and principled.",
          "createdAt": "2021-02-11T03:17:18Z",
          "updatedAt": "2021-02-11T03:17:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am currently writing the client side code to parse the version_negotiation TP received from the server. It looks like that:\r\n\r\n1) Parse the Negotiated Version and verify that it matches the version in the packet header.\r\n2) Parse the Supported Version Count.\r\n3) Verify that there are just 4*count octets of parameter content after the Supported Version Count.\r\n\r\nThat is, I don't do anything at all with the list of supported versions. I could be wrong, and somebody somewhere might find this list of supported versions useful. But I doubt it.",
          "createdAt": "2021-04-24T04:58:19Z",
          "updatedAt": "2021-04-24T04:58:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "The client needs to verify this list or there is a potential downgrade attack.  If you are relying on the server for verifying the copy of the Version Negotiation packet that the client includes, that *might* avoid the attack, but as the client is ultimately responsible for choosing between incompatible versions, it ultimately needs to take responsibility for that choice and that means verifying.",
          "createdAt": "2021-04-27T05:39:02Z",
          "updatedAt": "2021-04-27T05:39:02Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "The full list might also be useful for client discovery of more-preferred-but-incompatible versions.  If the server accepts the client's proposed version (or upgrades to a compatible version) but also indicates support for some other versions, the client might choose to act on that, either by opening a new connection now or by caching it as a hint for future attempts.",
          "createdAt": "2021-04-27T14:42:14Z",
          "updatedAt": "2021-04-27T14:42:14Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the client might want to do the verification. But then, if the client does the verification, does it need to copy the content of the VN packet in the attribute? We have currently two lists, VN received by client and versions supported by server. At least one of them is redundant.\r\n\r\nI actually like the idea of letting the client verify. There is a tradeoff between detecting a spurious VN and junking a connection. In some cases, the negotiation will find the same version that it would have found without the interfering VN. The client is better position than the server to decide the tradeoff.",
          "createdAt": "2021-04-27T16:18:33Z",
          "updatedAt": "2021-04-27T16:18:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Letting the client verify is tricky because we want to support the scenario where\r\n1. client sends initial, reaches server S1\r\n2. server S1 sends version negotiation packet to client\r\n3. client sends initial with a different version, reaches server S2\r\n\r\nand S1 and S2 have different supported versions.\r\n\r\nThe draft currently only relies on server verification because of this requirement: only servers can know about this divergence of versions among a fleet.",
          "createdAt": "2021-04-27T17:53:56Z",
          "updatedAt": "2021-04-27T17:53:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "What I proposed for that case is that we allow for S1 and S2 to support different versions, but S2 is required to know that a particular version is unevenly deployed.  S2 would be prohibited from advertising any partially deployed version.\r\n\r\nOtherwise, a client can't do the validation, as you say.  As it is the server that has the special needs (that is, it is the one doing a progressive rollout or similar), then it is up to the server to manage that complexity.",
          "createdAt": "2021-04-28T07:53:48Z",
          "updatedAt": "2021-04-28T07:53:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is obsolete now that #42 has landed, closing.",
          "createdAt": "2021-05-27T01:42:00Z",
          "updatedAt": "2021-05-27T01:42:00Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU4MDQxODQwNDU=",
      "title": "Current Version or Original Version",
      "url": "https://github.com/quicwg/version-negotiation/issues/20",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The new transport parameter includes a Current Version.  However, as the client instance of this appears in a message that is \"transformed\" when selecting a compatible version.  Thus, unless this value is transformed as part of that process (*), I think that this is probably better named as Original Version instead.\r\n\r\nNote that I don't believe it to be possible to modify the TLS handshake in any way here.  Though logically the things that carry might be transformed such that the framing is different and so forth, things like the PSK binder in TLS make changes to anything in a ClientHello extraordinarily difficult.  I think that we should accept that some transformations are impossible.",
      "createdAt": "2021-02-09T04:02:44Z",
      "updatedAt": "2021-05-27T01:42:12Z",
      "closedAt": "2021-05-27T01:42:12Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are you referring to `Currently Attempted Version`? I personally find that clearer then `Original Version` in that specific context because `Original Version` can be confused with `Previously Attempted Version`.",
          "createdAt": "2021-02-11T02:44:36Z",
          "updatedAt": "2021-02-11T02:44:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "\"Current\" doesn't apply when the transport parameter is validated.  And your text uses \"original version\" throughout.  I was only requesting that you pick one and be consistent.",
          "createdAt": "2021-02-11T03:11:43Z",
          "updatedAt": "2021-02-11T03:11:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But they're different concepts. Here's an example:\r\n\r\nWhen performing incompatible version negotiation from version A to version B,\r\n1. client sends a first flight with version A where:\r\n  - Original Version = A\r\n  - Currently Attempted Version = A\r\n  - Previously Attempted Version = 0\r\n2. server sends a VN packet which lists B\r\n3. client sends a first flight with version B where:\r\n  - Original Version = A\r\n  - Currently Attempted Version = B\r\n  - Previously Attempted Version = A",
          "createdAt": "2021-02-11T03:21:26Z",
          "updatedAt": "2021-02-11T03:21:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oh, then I think that you want Attempted Version and Original Version as your field names.",
          "createdAt": "2021-02-11T03:25:33Z",
          "updatedAt": "2021-02-11T03:25:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That doesn't work for compatible VN from A to B, where the client sends a first flight with version A where:\r\n- Original Version = A\r\n- Currently Attempted Version = A\r\n- Previously Attempted Version = 0",
          "createdAt": "2021-02-11T03:31:25Z",
          "updatedAt": "2021-02-11T03:31:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is obsolete now that #42 has landed, closing.",
          "createdAt": "2021-05-27T01:42:12Z",
          "updatedAt": "2021-05-27T01:42:12Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU4MDQxODQ5OTc=",
      "title": "Section 4 is missing a definition of some fields",
      "url": "https://github.com/quicwg/version-negotiation/issues/21",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Received Negotiation Version, Compatible Version, and Supported Version each have a description for their counts, but not the fields.  (Some of the definition of these is included in the description of the count; this is just an editorial quirk.)",
      "createdAt": "2021-02-09T04:05:04Z",
      "updatedAt": "2021-05-27T01:42:19Z",
      "closedAt": "2021-05-27T01:42:18Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would you like to send a PR for this?",
          "createdAt": "2021-02-11T02:45:22Z",
          "updatedAt": "2021-02-11T02:45:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is obsolete now that #42 has landed, closing.",
          "createdAt": "2021-05-27T01:42:18Z",
          "updatedAt": "2021-05-27T01:42:18Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU4MDQxODY1NzA=",
      "title": "Don't undermine version greasing",
      "url": "https://github.com/quicwg/version-negotiation/issues/22",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> Clients MAY include versions following the pattern 0x?a?a?a?a in their Compatible Version list, and the server in their Supported Version list. Those versions are reserved to exercise version negotiation (see the Versions section of [QUIC]), and MUST be ignored when parsing these fields. On the other hand, the Received Negotiation Version list MUST be identical to the received Version Negotiation packet, so clients MUST NOT add or remove reserved version from that list.\r\n\r\nThis construction directly undermines greasing by privileging the handling of greased versions.  Please don't do this.\r\n\r\nAs I alluded to in #19, this doesn't need to match the Version Negotiation packet/datagram contents.  What is important here is that the list doesn't include a version that the client would have preferred to attempt over the current one.  If you validate the server values that way, then you never have to worry about greased versions being different in the two different places.\r\n\r\nIndeed, you can have the server offer Version Negotiation packets that include more versions than they claim in their handshake (this being beneficial during the rollout of a fancy new version of the protocol).",
      "createdAt": "2021-02-09T04:09:14Z",
      "updatedAt": "2021-03-05T00:42:17Z",
      "closedAt": "2021-03-05T00:42:17Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you elaborate on how this undermines greasing? All we say is that you can add grease to version lists, but the Received Negotiation Version list needs to be transmitted as an opaque blob. We don't treat greased versions differently on receipt anywhere.",
          "createdAt": "2021-02-11T02:47:36Z",
          "updatedAt": "2021-02-11T02:47:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Well, the second MUST NOT pertains to something that I think should be removed.  But you say \"[reserved versions] MUST be ignored when parsing these fields\".  That tells implementations to train themselves to recognize greased versions.  At that point, they are no longer treating these as versions that they just don't understand, but something special.  The whole point of using an odd pattern was to ensure that this never happened.",
          "createdAt": "2021-02-11T03:14:00Z",
          "updatedAt": "2021-02-11T03:14:00Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough, if we replaced\r\n> Those versions are reserved to exercise version negotiation (see the Versions section of [QUIC]), and MUST be ignored when parsing these fields.\r\n\r\nwith:\r\n> Those versions are reserved to exercise version negotiation (see the Versions section of [QUIC]), and will be ignored when parsing these fields.\r\n\r\nWould that be OK?",
          "createdAt": "2021-02-11T03:22:50Z",
          "updatedAt": "2021-02-11T03:22:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "That's all I'm asking for.  (Along with striking the echo of the VN packet, but we'll pursue that separately.  The requirement there is reasonable if you assume that echoing the bits is necessary.)",
          "createdAt": "2021-02-11T03:24:34Z",
          "updatedAt": "2021-02-11T03:24:34Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU4MDQxODc2MDA=",
      "title": "Version Negotiation terminates a connection attempt",
      "url": "https://github.com/quicwg/version-negotiation/issues/23",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "> Once a client has reacted to a Version Negotiation packet, it MUST drop all subsequent Version Negotiation packets on that connection.\r\n\r\nThe draft says explicitly that receiving Version Negotiation terminates a connection attempt.  This isn't consistent with that.  This probably needs to say something like this instead:\r\n\r\n> A client that makes a connection attempt based on information received from a Version Negotiation packet MUST ignore any Version Negotiation packets it receives in response to that connection attempt.",
      "createdAt": "2021-02-09T04:12:09Z",
      "updatedAt": "2021-11-19T23:44:17Z",
      "closedAt": "2021-11-19T23:44:17Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds good to me, can you make this a PR?",
          "createdAt": "2021-02-11T02:48:15Z",
          "updatedAt": "2021-02-11T02:48:15Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU4MDQxOTAzODI=",
      "title": "Error signaling is a requirement on all QUIC versions",
      "url": "https://github.com/quicwg/version-negotiation/issues/24",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Defining an error code for QUICv1 is good, but I think that you need to frame this differently.  It probably needs to be framed in terms of a requirement on all QUIC versions.  So rather than:\r\n\r\n> If the connection was using QUIC version 1, it MUST be closed with a transport error of type VERSION_NEGOTIATION_ERROR.\r\n\r\nYou might say something like:\r\n\r\n> Every QUIC version that supports version negotiation MUST define a method for signaling errors related to version negotiation.  This signal is used when validation of the version negotiation transport parameter fails or when a flight cannot be converted by the server to the compatible version \\[note: see #17].  For QUIC version 1, this document registers a transport error of type VERSION_NEGOTIATION_ERROR; see {{iana-error}}.  \r\n",
      "createdAt": "2021-02-09T04:18:40Z",
      "updatedAt": "2021-11-19T23:50:26Z",
      "closedAt": "2021-11-19T23:50:26Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this. Can you make it a PR?",
          "createdAt": "2021-02-11T02:48:50Z",
          "updatedAt": "2021-02-11T02:48:50Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU4MDQxOTUxODQ=",
      "title": "Define something concrete for Retry",
      "url": "https://github.com/quicwg/version-negotiation/issues/25",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Allowing Retry to retain the same version makes it a lot harder to define a transform into a compatible version because it means that the entire Retry exchange needs to be accounted for.  As noted, allowing the compatible version selection to be deferred is probably the right answer, because it means that the server generating the Retry doesn't need to unwrap the Initial.  However, I don't think that a naive design like that naturally retains the properties we designed for Retry.\r\n\r\nThe current text seems to be disavowing any responsibility for dealing with Retry.  I don't think that is acceptable.\r\n\r\nA v2 without Retry that is compatible with v1 could just ignore the Retry, but that would lose the protections we specifically built in v1.  What I think needs to happen is that v2 would not be compatible with v1 unless it was able to carry the information the v2 server needs to authenticate the v1 Retry.  That is, there is a function that transforms a v1 Initial that includes a token into a v2 equivalent and there is a mechanism in v2 that provides the same retry_connection_id and so forth...even if v2 doesn't include a similar Retry mechanism natively.\r\n\r\n",
      "createdAt": "2021-02-09T04:30:09Z",
      "updatedAt": "2022-03-07T23:28:33Z",
      "closedAt": "2022-03-07T23:28:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We explicitly didn't define anything concrete for protocol features that aren't invariant, such as retry. But we could add some guidelines for this. Can you suggest text?",
          "createdAt": "2021-02-11T02:50:53Z",
          "updatedAt": "2021-02-11T02:50:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "How about we agree on a design first.  Do you think that this is a reasonable approach?",
          "createdAt": "2021-02-11T03:14:49Z",
          "updatedAt": "2021-02-11T03:14:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Absolutely, if two versions have a similar concept of retry and similar safety mechanisms to protect it, then retry can be made to work with compatible VN if the compatibility doc describes how to convert the retry safety mechanisms.",
          "createdAt": "2021-02-11T03:24:45Z",
          "updatedAt": "2021-02-11T03:24:45Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "So:\r\n\r\n1. Endpoints send Retry (or any stateless exchange that is equivalent) in the version that matches the thing they respond to.\r\n2. Endpoints that choose a compatible version can only do so if the compatible version describes how to translate what happened into something the new version can use.\r\n\r\nThat seems right.\r\n\r\nWhat I find interesting about this is that v2 might define the same retry authentication as v1, in which case it says \"if retry happened, then do the same, whether it was v1 or v2 originally\".  That's easy.  We might also have a protocol that doesn't bother to authenticate Retry, in which case translation is as simple as \"forget that you sent a Retry\".  Anything is possible.",
          "createdAt": "2021-11-29T09:59:31Z",
          "updatedAt": "2021-11-29T09:59:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this framing. I'll write it up as a PR unless you'd rather do it.",
          "createdAt": "2021-11-29T18:59:16Z",
          "updatedAt": "2021-11-29T18:59:16Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "You're the editor :)",
          "createdAt": "2021-11-29T20:39:27Z",
          "updatedAt": "2021-11-29T20:39:27Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU4MDQxOTg2NjA=",
      "title": "Frame self-description is not a problem",
      "url": "https://github.com/quicwg/version-negotiation/issues/26",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "has-pr"
      ],
      "body": "In [Section 10](https://www.ietf.org/archive/id/draft-ietf-quic-version-negotiation-03.html#section-10-1):\r\n\r\n> Additionally, frames in QUIC version 1 do not use a self-describing encoding, so unrecognized frame types cannot be parsed or ignored (see the Extension Frames section of [QUIC]); this means that new versions that wish to be very similar to QUIC version 1 and compatible with it should avoid introducing new frames in initial packets.\r\n\r\nThis is not an issue.  If v2 defines a new frame type that can appear in Initial-equivalent packets, then to be compatible with v1 (in both directions) that frame type could simply be optional in v2.  The lack of a self-describing encoding is not an issue as the parsing of the v2 packet is done with knowledge of all the core frame types in v2.  Sure, you can't introduce an extension frame here, but that's true of v1 on its own.\r\n\r\nThe only way in which a version might become incompatible is if it includes new *information* that can't be inferred from the other version or doesn't have a valid default.\r\n\r\nI think that the intent of this was to say that if there is any need for the Initial flight to carry new information that is only consumed by a compatible version, then there is no way for QUIC version 1 to carry that new information by using new frames.  Instead, it has to use a field in v1 that would be ignored by a v1 endpoint.  As v1 defines no real extension points of this sort, the options in this case are limited.\r\n\r\nI think that this text can be removed.  Maybe you could talk about the problem of carrying version-specific information in other versions.",
      "createdAt": "2021-02-09T04:39:16Z",
      "updatedAt": "2021-11-20T01:11:43Z",
      "closedAt": "2021-11-20T01:11:43Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This makes sense. This text was somewhat vestigial from earlier designs of this mechanism.",
          "createdAt": "2021-02-11T02:52:03Z",
          "updatedAt": "2021-02-11T02:52:03Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU4MDQyMDEyMjM=",
      "title": "Is handshake version information invariant?",
      "url": "https://github.com/quicwg/version-negotiation/issues/27",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "I think that the answer is \"no\" (see also Betteridge's Law) in that the format is version-specific, but [Section 4](https://www.ietf.org/archive/id/draft-ietf-quic-version-negotiation-03.html#section-4-1) is pretty obtuse about this:\r\n\r\n> During the handshake, endpoints will exchange handshake version information, which is a blob of data that is defined below. In QUIC version 1, the handshake version information is transmitted using a new transport parameter, [...]\r\n\r\nThe first sentence reads as an absolute; the second is clearly narrowly scoped.  But then nothing is said about other versions.\r\n\r\nAs I mentioned with error codes in #24, I think that the way this needs to be phrased is as a requirement on QUIC versions that support version negotiation.  The requirement is that those protocols need to define a way to carry certain information.  You can then define that information in the abstract when articulating that requirement; again see #24.\r\n\r\nThe concrete form you choose for v1 then only needs to apply to v1.",
      "createdAt": "2021-02-09T04:46:16Z",
      "updatedAt": "2021-12-02T21:27:12Z",
      "closedAt": "2021-12-02T21:27:12Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The intention was for the handshake version information to be invariant, and for how it is conveyed to be version-specific. But I agree that we should state that versions need an authenticated way to exchange handshake version information.",
          "createdAt": "2021-02-11T02:53:37Z",
          "updatedAt": "2021-02-11T02:53:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "It needs to go further than that.  I think that you need to list, concretely, what information is being authenticated.  And you need to explain the consequences, namely:\r\n\r\n> The purpose of this document is to describe (in the abstract) a version negotiation scheme that different QUIC versions can opt into using.  Though this scheme is not invariant, the versions that use this scheme benefit from downgrade protection if they support either incompatible or compatible negotiation.  Versions that define compatibility with other versions additionally benefit from seamless upgrade.\r\n>\r\n> This does not preclude a QUIC versions from not using this scheme, but that version does not realize these benefits.\r\n\r\nAnd then in Section 4, say precisely what information needs to be authenticated in order to achieve this goal, with a concrete definition for how the information is carried in QUIC version 1 transport parameters.",
          "createdAt": "2021-02-11T03:19:44Z",
          "updatedAt": "2021-02-11T03:19:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That works for me.",
          "createdAt": "2021-02-11T03:25:43Z",
          "updatedAt": "2021-02-11T03:25:43Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU4MDQyMjgzMjc=",
      "title": "You have two links to the repo",
      "url": "https://github.com/quicwg/version-negotiation/issues/28",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "One was automatically added by tools, the other is in the abstract.\r\n\r\nConsider removing one or other.",
      "createdAt": "2021-02-09T05:43:07Z",
      "updatedAt": "2021-03-05T00:44:46Z",
      "closedAt": "2021-03-05T00:44:45Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be nice if there was a way to get the tools to mention the mailing list as well, then we could remove this paragraph.",
          "createdAt": "2021-02-11T02:54:36Z",
          "updatedAt": "2021-02-11T02:54:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "The tools do mention the mailing list.  I have no idea what happened to yours.",
          "createdAt": "2021-02-11T03:20:09Z",
          "updatedAt": "2021-02-11T03:20:09Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do I need to mention the WG or mailing list in the markdown metadata somewhere?",
          "createdAt": "2021-02-11T03:26:16Z",
          "updatedAt": "2021-02-11T03:26:16Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "It might be possible to run `make -f lib/setup.mk .note.xml`.  Try that and see what damage it does.  You might need to delete .note.xml first.",
          "createdAt": "2021-02-11T03:27:05Z",
          "updatedAt": "2021-02-11T03:27:37Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\n~/src/draft-ietf-quic-version-negotiation $ make -f lib/setup.mk .note.xml\r\nmake: '.note.xml' is up to date.\r\n~/src/draft-ietf-quic-version-negotiation $ make\r\nmake: Nothing to be done for 'latest'.\r\n```",
          "createdAt": "2021-02-11T03:33:30Z",
          "updatedAt": "2021-02-11T03:33:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Yeah, I thought so.  You might need to remove the file first.",
          "createdAt": "2021-02-11T03:35:10Z",
          "updatedAt": "2021-02-11T03:35:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That didn't work so I fixed it by hand via https://github.com/quicwg/version-negotiation/commit/0ef639f6790e1cc576a346aaf31a22712f1c2f2d",
          "createdAt": "2021-02-11T04:02:50Z",
          "updatedAt": "2021-02-11T04:02:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah I found the issue, fix is here: https://github.com/martinthomson/i-d-template/pull/266",
          "createdAt": "2021-02-11T04:29:48Z",
          "updatedAt": "2021-02-11T04:29:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that that's merged, this is fixed.",
          "createdAt": "2021-03-05T00:44:45Z",
          "updatedAt": "2021-03-05T00:44:45Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU4MDQyMjk0NTA=",
      "title": "Make introduction match the text",
      "url": "https://github.com/quicwg/version-negotiation/issues/29",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The introduction reads like the draft only defines compatible version negotiation.  It probably needs to be written to be more general.",
      "createdAt": "2021-02-09T05:45:15Z",
      "updatedAt": "2021-07-26T00:07:08Z",
      "closedAt": "2021-07-26T00:07:08Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough.",
          "createdAt": "2021-02-11T02:55:05Z",
          "updatedAt": "2021-02-11T02:55:05Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU4MDQyMzM5MDU=",
      "title": "Could this use ALPN identifiers instead?",
      "url": "https://github.com/quicwg/version-negotiation/issues/30",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is likely a big ticket question, and I predict that Ekr will disagree with me here, but it needs to be asked.  In [draft-thomson-tls-snip](https://datatracker.ietf.org/doc/draft-thomson-tls-snip/) I proposed a design that would allow incompatible versions to be authenticated using ALPN identifiers alone.  A similar thing would work here if we were able to guarantee that an application protocol could be used with exactly one QUIC version.\r\n\r\nThat is not an unreasonable constraint if you consider the interaction between QUIC and other points in the space (Alt-Svc and SVCB in particular both use only ALPN).\r\n\r\nFWIW, I want an actual decision about this to be recorded.  We keep agreeing to disagree in other places about this issue and I'm tired of it.  It means that we have one set of assumptions for some protocols and a different set of assumptions for others and the edges don't line up very well at all.  For instance, we might not even need compatible version negotiation if we could agree one way or other.",
      "createdAt": "2021-02-09T05:53:41Z",
      "updatedAt": "2021-05-27T01:44:40Z",
      "closedAt": "2021-05-27T01:44:40Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I definitely think that we should agree as a community on what ALPN means. I my opinion, Alt-Svc shouldn't have used ALPN, because of all the confusions you describe, but here we are. I don't think this is in-scope for draft-ietf-quic-version-negotiation though, because ALPN is not a QUIC invariant. There are deployed versions of QUIC that do not have a concept of ALPN. Because of this, I think that draft-ietf-quic-version-negotiation should stick to 32bit QUIC versions and leave the ALPN problem alone.",
          "createdAt": "2021-02-11T02:59:15Z",
          "updatedAt": "2021-02-11T02:59:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There was consensus at the last interim meeting to stick with 32bit versions, so I'm closing this. Please comment if you disagree.",
          "createdAt": "2021-05-27T01:44:40Z",
          "updatedAt": "2021-05-27T01:44:40Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU4Mjc3MjE1MzI=",
      "title": "Terminological precision",
      "url": "https://github.com/quicwg/version-negotiation/issues/32",
      "state": "CLOSED",
      "author": "wbl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Bijective should be symmetric. We're describing a relation not a function.\r\nThis is a very minor comment, will send a PR hopefully soon.",
      "createdAt": "2021-03-10T13:14:44Z",
      "updatedAt": "2021-05-27T01:45:02Z",
      "closedAt": "2021-05-27T01:45:02Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed, my math is pretty rusty :) Totally agree with you, and thanks for offering to write the PR!",
          "createdAt": "2021-03-10T13:35:51Z",
          "updatedAt": "2021-03-10T13:35:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "@wbl any luck with the PR?",
          "createdAt": "2021-04-12T19:31:07Z",
          "updatedAt": "2021-04-12T19:31:07Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I completely forgot about this!",
          "createdAt": "2021-04-13T05:50:55Z",
          "updatedAt": "2021-04-13T05:50:55Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/quicwg/version-negotiation/pull/33 opened",
          "createdAt": "2021-04-15T05:38:56Z",
          "updatedAt": "2021-04-15T05:38:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing now that #33 has been merged.",
          "createdAt": "2021-05-27T01:45:02Z",
          "updatedAt": "2021-05-27T01:45:02Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU4NjQwMDA4MjQ=",
      "title": "Need a rationale for changing the outer Version Number",
      "url": "https://github.com/quicwg/version-negotiation/issues/34",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current text says:\r\n\r\n- Negotiated Version: The version that the server chose to use for the connection. This field MUST be equal to the value of the Version field in the long header that carries this data.\r\n\r\nThat means for example a response to a long header packet carrying version 1 would be a long header packet carrying version 2. This discloses to third parties the otherwise hidden version negotiation, which may well be a bad thing. It also introduces a new error mode, since the result of the negotiation is only known after receiving the server's first flight, but the new version is present in the headers at the beginning of that flight. What if the two disagree?",
      "createdAt": "2021-04-21T15:16:13Z",
      "updatedAt": "2021-07-26T00:10:16Z",
      "closedAt": "2021-07-26T00:10:16Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it would be preferable to hide the fact that compatible version negotiation is happening to passive observers. \r\n\r\nBut how would that work in practice? How does the client know to parse the server's first flight as a v2 flight without getting that information in the long header's Version field?",
          "createdAt": "2021-04-21T15:40:43Z",
          "updatedAt": "2021-04-21T15:40:43Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe switch to the new version *after* the first flight?",
          "createdAt": "2021-04-21T18:18:37Z",
          "updatedAt": "2021-04-21T18:18:37Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You could imagine using the v1 format for all long headers and v2 for short headers. This then becomes a tradeoff between hiding the VN vs having the flexibility of using the v2 format in handshake packets.",
          "createdAt": "2021-04-21T18:34:10Z",
          "updatedAt": "2021-04-21T18:34:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This text was removed in #42, closing.",
          "createdAt": "2021-07-26T00:10:16Z",
          "updatedAt": "2021-07-26T00:10:16Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU4NjQ1MDQ4NTQ=",
      "title": "Do we really need to list the full VN content?",
      "url": "https://github.com/quicwg/version-negotiation/issues/35",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec directs the client to list all the versions proposed in the VN that it receives, and the server to verify that \"it could have sent this VN\". The text then goes on to explain how to relax the checks in partially upgraded server farms. I find this a bit problematic for two reasons:\r\n\r\n1)  Assessing whether a server \"could have sent\" a list of Version Numbers is full of interesting corner cases. Should the verification test the order in which alternate versions are presented? What if different servers in the farm have different software stacks? What if the VN was sent by an updated server but verified by a not-updated server?\r\n\r\n2) The spec requires the client to remember the content of the VN packet, which is quite possibly malicious, maybe very large. This is a bit unwieldy to implement. It also has the potential to trigger bugs, by invoking rarely used segments of code.\r\n\r\nThe server will receive the initial version proposed and the negotiated value. Isn't that sufficient? If we need more, why not providing the full list of versions supported by the client?",
      "createdAt": "2021-04-22T03:32:21Z",
      "updatedAt": "2021-05-27T01:45:19Z",
      "closedAt": "2021-05-27T01:45:19Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not too worried about asking the client to remember one packet worth of data, but I agree with you that we might be able to simplify this. I went with a very conservative approach of validating everything, but I agree that simply including the original version and negotiated version should be enough to prevent downgrades.",
          "createdAt": "2021-04-22T17:25:54Z",
          "updatedAt": "2021-04-22T17:25:54Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am looking at implementing this, and I wonder whether we should be able to simplify. As you said, the VN content is not really required. The server can check whether it would have rejected the proposed version, and that's pretty much sufficient to protect against VN downgrade, except for the \"compatibility\" issue.\r\n\r\nThe easiest client side implementation is to provide a list of \"currently attempted, previously rejected, all supported versions\", without bothering for the \"compatibility\" test. If we do that, we leave the test of compatibility strictly on the server side, with incompatibility resulting in VN. If the server can parse the message, then the server will pick the \"best\" version from a list, and document that in the proposed version. There is no real need to list the server supported versions. ",
          "createdAt": "2021-04-22T20:59:03Z",
          "updatedAt": "2021-04-22T20:59:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is obsolete now that #42 has landed, closing.",
          "createdAt": "2021-05-27T01:45:19Z",
          "updatedAt": "2021-05-27T01:45:19Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU4NjQ1MzA5NDk=",
      "title": "Domain separation requirements",
      "url": "https://github.com/quicwg/version-negotiation/issues/36",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@wbl pointed out on the list that there is a risk where different protocols that share credentials are not mutually secure unless there is clean domain separation when using those credentials.  TLS 1.3 tries to do this by adjusting the signature inputs so that there is no risk of overlap with TLS 1.2, which might also make it more likely that other protocols cannot have collisions.  But that's not a guarantee.\r\n\r\nThis is largely theoretical (you would need to find a transcript in one protocol that would be accepted in the other protocol), but those sorts of attacks are incredibly hard to fix if the mistake is made.  It is easier - and far better - to prevent than fix.  So a note about this is worth including when talking about incompatible negotiation.  Given that we already have uses of incompatible negotiation that reuse credentials, it seems quite likely that there will be more.\r\n\r\nNote: the usual advice here is \"don't reuse credentials\", but no matter how loudly you say that, people will do what they need to do.  We could say \"MUST analyze all credential reuse and prove that there are no potential input collisions\", but I don't know if that would be effective in practice.",
      "createdAt": "2021-04-22T04:37:07Z",
      "updatedAt": "2021-07-26T00:12:53Z",
      "closedAt": "2021-07-26T00:12:53Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding guidance for designers of new QUIC versions seems reasonable, but I'm not sure what we can do in this spec protocol-wise apart from making sure the version is in the transcript.",
          "createdAt": "2021-04-22T17:29:30Z",
          "updatedAt": "2021-04-22T17:29:30Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "Perhaps this should be a TLS-level document for how to ensure domain separation with TLS in general, be it other QUIC handshakes or completely unrelated features. The 64 spaces goofiness especially may not be obvious to a protocol designer.\r\n\r\n(I'd similarly advised signed exchanges to use a compatible domain separation, spaces and all, in case anyone reused keys despite all the pointers not to, but there wasn't anything handy to cite.)",
          "createdAt": "2021-04-22T18:24:21Z",
          "updatedAt": "2021-04-22T18:24:54Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I don't think that we need to directly mention the goofiness in TLS, but it would simply be a note that sharing credentials across different QUIC versions needs to consider (and ideally mitigate) the risk of cross-version confusion.",
          "createdAt": "2021-04-23T01:05:06Z",
          "updatedAt": "2021-04-23T01:05:06Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At the meeting I think @DavidSchinazi mentioned that Chrome is using entirely different crypto with the same certificates in their gquic. Once we do that \"the transcript\" is underspecified across the underlying crypto protocols. And nobody is going to get new certs or a new PKI for their new QUIC version.",
          "createdAt": "2021-04-23T04:22:17Z",
          "updatedAt": "2021-04-23T04:22:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "Yeah, what's now called gQUIC predates all this stuff, including even TLS 1.3. The signature's got a different label prefix, however.",
          "createdAt": "2021-04-23T05:19:10Z",
          "updatedAt": "2021-04-23T05:19:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on this conversation, we don't need to change anything in draft-ietf-quic-version-negotiation for this issue. While making sure signatures have different prefixes is important, I don't think it's in scope for this document because it applies to TLS and Google QUIC which is way beyond the scope of this draft. Closing.",
          "createdAt": "2021-07-26T00:12:53Z",
          "updatedAt": "2021-07-26T00:12:53Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU4NjU3Mjc1MTk=",
      "title": "Test case, authenticated handshake",
      "url": "https://github.com/quicwg/version-negotiation/issues/37",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I am looking at practical use of \"compatible version negotiation\", and would like to start with the [authenticated handshake extension)[https://www.ietf.org/archive/id/draft-kazuho-quic-authenticated-handshake-01.txt]. That extension redefines the format of the Initial packets to insert a secret in the authenticated data, and thus in the AEAD checksum. This \"change of format\" is pretty much what we want to support with the VN mechanism: map the new proposed format to a new version, negotiate that new version, use the new syntax for packets carrying the new version.\r\n\r\nWhen doing that, I find interesting issues. For example, what does it mean to \"re-process the client's first flight\". Which makes me believe that this is probably on the right track...",
      "createdAt": "2021-04-23T04:21:14Z",
      "updatedAt": "2021-11-20T01:20:58Z",
      "closedAt": "2021-11-20T01:20:58Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @huitema is this issue requesting specific changes to the draft?",
          "createdAt": "2021-07-26T00:13:36Z",
          "updatedAt": "2021-07-26T00:13:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing since I'm not seeing any changes required in the draft. Please reopen if you have changes in mind.",
          "createdAt": "2021-11-20T01:20:58Z",
          "updatedAt": "2021-11-20T01:20:58Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU4NjYyNTA0NDI=",
      "title": "What does reprocess the first flight mean?",
      "url": "https://github.com/quicwg/version-negotiation/issues/38",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "has-pr"
      ],
      "body": "Section 3.3 states:\r\n\r\n* If the server supports one of the client's compatible versions, and the server also believes that the original version is compatible with this version, then the server converts the client's first flight to that version and replies to the client as if it had received the converted first flight. The version used by the server in its reply is refered to as the \"negotiated version\". The server MUST NOT reply with a version that is not present in the client's compatible versions, unless it is the original version.\r\n\r\nI am looking at implementing that, and I am really puzzled. Take for example Martin Duke's V2 draft, which merely changes the Initial salt. Reprocess the first flight would mean try to parse it with the new salt, and that would fail.  Or the \"authenticated handshake\" draft, which require adding a secret into the Initial AAD, but that secret is only present if the first flight was designed for authenticated handshake. I think that the draft needs to be much more precise about this \"compatible version\" process. It seems that there are three levels:\r\n\r\n* packets, which should be parsed and formatted according to the version number in the long header, or for 1RTT packets the version number negotiated during the handshake.\r\n\r\n* frames, which generally should be treated independently of the packet format -- unless the target version includes new parameters\r\n\r\n* transport parameters and maybe TLS extensions\r\n\r\nIn Martin Duke's V2 draft, we have a simple case of merely changing the packet format without changing the semantic of frames or parameters, so that's easy. In the authenticated exchange draft, the peers could update from V1 to V-authenticated, but only if they manage to retrieve the required secret from the TLS extensions or the transport parameter. Is that what reprocess means?\r\n\r\nThe more I think of it, the more I believe that the \"upgrade from V1 to Vx\" process should be defined as part of the Vx specification. For example, Vx spec might say something like \"when upgrading from V1 to Vx, find the Transport Parameter X, Y and Z and use them to initialize Vx parameters A, B and C.\" Maybe that's part of what a \"compatible upgrade\" is.\r\n\r\n",
      "createdAt": "2021-04-23T16:11:05Z",
      "updatedAt": "2021-12-02T21:27:28Z",
      "closedAt": "2021-12-02T21:27:28Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @huitema, where does the word \"reprocess\" come from? I don't see it anywhere in the draft. The draft uses the word \"convert\". For example in Martin Duke's v2 draft, you would convert a v1 initial to v2 by decrypting it with v1 initial keys, setting the version to v2, and re-encrypting it with v2 initial keys. Then you'd be able to process that new synthetic v2 initial. Of course as an optimization your code can skip the re-encryption and just use the parsed result but the concept is to define a conversion between versions.\r\n\r\nIn the current design, it's totally possible for the \"upgrade from V1 to Vx\" process to be described in the Vx draft, but it's not required - that allows us to make two versions compatible even if they were developed concurrently in isolation.",
          "createdAt": "2021-04-26T15:32:11Z",
          "updatedAt": "2021-04-26T15:32:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema gentle ping on this - did the latest update to the draft clarify this for you?",
          "createdAt": "2021-07-25T23:19:22Z",
          "updatedAt": "2021-07-25T23:19:22Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The spec says:\r\n\r\n* If the server supports one of the client's compatible versions, and the server also believes that the original version is compatible with this version, then the server converts the client's first flight to that version and replies to the client as if it had received the converted first flight. The version used by the server in its reply is refered to as the \"negotiated version\".\r\n\r\n(Typo: Should be _referred_, I think)\r\n\r\nThe text works, but it relies on _the server also believes_. My point is that in order to believe, the server has to be able to convert the initial Vi input into the selected Vx. You may or may not want to outline that. I would prefer if you did.",
          "createdAt": "2021-07-27T19:42:04Z",
          "updatedAt": "2021-07-27T19:42:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good, I'll write up an editorial PR to address this.",
          "createdAt": "2021-07-27T19:50:41Z",
          "updatedAt": "2021-07-27T19:50:41Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU4NjYzNzY2ODg=",
      "title": "Packet loss during version negotiation",
      "url": "https://github.com/quicwg/version-negotiation/issues/39",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Implementing the negotiation in picoquic, I find an interesting corner case.\r\n\r\nWhen receiving an initial packet, picoquic checks whether there is an ongoing connection for the specified IP addresses, ports and connection IDs. If there is one, it verifies that the newly received packet is consistent with what is already in that context -- in particular, the same version ID. But of course, if the server is doing version negotiation, that version has already changed. Which means that the server can only process the repeated Initial packet if it remembers what the original version ID was. Maybe obvious, but maybe something we should see in the spec.\r\n",
      "createdAt": "2021-04-23T19:31:13Z",
      "updatedAt": "2022-03-07T22:12:49Z",
      "closedAt": "2022-03-07T22:12:49Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "There's a related wrinkle: if the client first flight is multiple packets, then the server might need to send multiple packets.  It might be forced to acknowledge in the original version a few times until it has all of the packets and can see that a different version is available.  Clients might get packets out of order and so see something like v2, v1, v2, v2...  They can probably drop the odd version packet, but that might not be the best strategy.",
          "createdAt": "2021-04-27T01:57:16Z",
          "updatedAt": "2021-04-27T01:57:16Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is addressed in the [v2 draft](https://quicwg.org/quic-v2/draft-ietf-quic-v2.html#name-compatible-negotiation-requ):\r\n\r\nDo we still need something in VN?",
          "createdAt": "2022-03-07T22:02:13Z",
          "updatedAt": "2022-03-07T22:02:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since this detail will be pretty specific to the interaction between the two versions at play, the spec for the second version (or whichever spec makes them compatible) is the right place for that guidance. Conveniently, we already have this in the v2 draft. So I'm going to close this with no action. Please reopen/comment if you disagree.",
          "createdAt": "2022-03-07T22:12:49Z",
          "updatedAt": "2022-03-07T22:12:49Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU4NjY0NzkxNzY=",
      "title": "Incompatible VN and unaware server",
      "url": "https://github.com/quicwg/version-negotiation/issues/40",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 5 describes Version Downgrade Prevention. If a client receives a VN packet and selects a new attempted version, it will format the \"compatible VN\" extension and document in it the previously attempted version and the VN parameters. The server who understands the extension will then verify that the VN was not a downgrade attack. This supposes that the server supports the extension. If it does not, the server will ignore the `version_negotiation` parameter, and will not verify anything. It also will not include that parameter in its parameter set.\r\n\r\nWhat should the client do in that scenario? Should it just close the connection with version_negotiation error? ",
      "createdAt": "2021-04-23T22:59:02Z",
      "updatedAt": "2021-05-27T01:54:32Z",
      "closedAt": "2021-05-27T01:54:32Z",
      "comments": []
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4NzAwODc4ODM=",
      "title": "Do applications define compatible versions?",
      "url": "https://github.com/quicwg/version-negotiation/issues/41",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "Two versions might be compatible in the sense that one can convert the Initial Packet from one into the other. But one version might not have the features necessary for an application. There are two ways to mediate this that I can see:\r\n\r\n1) The client excludes compatible versions that are inadequate for the app from its TP. This means the QUIC API will need a way for applications to control the advertised versions.\r\n2) Servers understand what capabilities are needed and will not select an advertised compatible version that does not support them.\r\n\r\nFor incompatible VN, if the server can identify the application based on IP and port, it might scrub irrelevant versions from its VN packet, though I don't know if that's a good idea or not.",
      "createdAt": "2021-04-28T15:39:41Z",
      "updatedAt": "2021-12-02T21:27:19Z",
      "closedAt": "2021-12-02T21:27:19Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "When MsQuic implemented this extension, we exposed a configuration option to the app for it to specify its \"desired version list\". My expectation is that a client would include all acceptable QUIC versions here, and then adapt (if necessary) their protocol layer accordingly. Though, this might get harry, for instance, if they need to then choose a different ALPN based on the negotiated QUIC version (we don't _currently_ support that).",
          "createdAt": "2021-04-28T16:05:09Z",
          "updatedAt": "2021-04-28T16:05:09Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke you're describing an implicit assumption of the draft: the list of supported versions are specific to an application, not just to an implementation. Perhaps we can add a sentence to make that more obvious, such as `The client shouldn't be enabling or advertising support for versions that it can't use.` Servers don't need to do anything here, it's the client's responsibility to know what it wants to do with a given connection, not the server's.",
          "createdAt": "2021-04-28T19:37:04Z",
          "updatedAt": "2021-04-28T19:37:40Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes @DavidSchinazi that works for me. The real issue is that this not totally internal to the QUIC implementation and there needs to be an API for the application to manage this.",
          "createdAt": "2021-04-28T21:20:59Z",
          "updatedAt": "2021-04-28T21:20:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that such an API is reasonable (Google QUICHE provides one for example) but I think that's out of scope for this document though.",
          "createdAt": "2021-04-28T22:03:15Z",
          "updatedAt": "2021-04-28T22:03:15Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree you shouldn't define the API, but it would be good to say, \"hey, dummy, don't just advertise every compatible version the QUIC implementation supports\"",
          "createdAt": "2021-04-29T17:56:19Z",
          "updatedAt": "2021-04-29T17:56:19Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Note that the relationship between version selection and ALPN is similar to the aftereffects of HTTP/2, which made the cipher selection and ALPN selection within TLS interdependent. That was a pain. It doesn't affect this draft per se, but I do hope we don't paint ourselves into that particular corner again.",
          "createdAt": "2021-05-14T19:46:17Z",
          "updatedAt": "2021-05-14T19:46:17Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4NzkzOTUwMDU=",
      "title": "Should the client communicate version preference ordering?",
      "url": "https://github.com/quicwg/version-negotiation/issues/43",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In #42, @martinthomson mentioned that having the client communicate preference ordering between compatible versions isn't absolutely necessary. This issue tracks whether we want to keep this ordering or not.",
      "createdAt": "2021-05-07T17:22:59Z",
      "updatedAt": "2021-08-10T12:35:19Z",
      "closedAt": "2021-08-10T12:35:18Z",
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "During the IETF QUIC WG meeting there was (weak-ish) consensus that this useful to keep.",
          "createdAt": "2021-07-27T19:51:41Z",
          "updatedAt": "2021-07-27T19:51:41Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "The strongest argument against this was that it doesn't give the server a full ordering, because it doesn't tell the server where the offered version falls in the preference list.  There's a possible answer to that, which is that the client should only offer compatible versions which are more preferred than the currently offered version.\r\n\r\nHowever, we should explicitly state that the server makes the actual decision and MAY factor client preferences into that.  I suspect most won't.",
          "createdAt": "2021-08-04T19:02:21Z",
          "updatedAt": "2021-08-04T19:02:21Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MikeBishop that's incorrect. The offered version is present in the list.",
          "createdAt": "2021-08-04T19:40:49Z",
          "updatedAt": "2021-08-04T19:40:49Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Ah, thanks for correcting me.  Then we're spending bytes to repeat the version number, which we don't expect servers will typically use.  Not the end of the world either way.",
          "createdAt": "2021-08-04T19:49:56Z",
          "updatedAt": "2021-08-04T19:49:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Consensus established. Closing this issue with no action.",
          "createdAt": "2021-08-10T12:35:18Z",
          "updatedAt": "2021-08-10T12:35:18Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU4ODgxMzcwMzc=",
      "title": "Remove backticks for fields",
      "url": "https://github.com/quicwg/version-negotiation/issues/44",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In #42, @martinthomson points out that the backticks don't render nicely in the TXT version, so let's remove them",
      "createdAt": "2021-05-11T18:28:03Z",
      "updatedAt": "2021-11-19T23:33:31Z",
      "closedAt": "2021-11-19T23:33:31Z",
      "comments": []
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4OTIxODg5MzY=",
      "title": "Anthropomorphism",
      "url": "https://github.com/quicwg/version-negotiation/issues/45",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This draft talks about clients and servers \"thinking\" and \"believing\" things.  Those verbs don't necessarily apply to protocol implementations, no matter what new frontiers we're exploring in the machine learning space.  Might be worth a pass to rephrase these in terms of client or server capabilities and information.\r\n\r\n\"Know\" is a little fuzzier, since an endpoint does in fact possess information at certain points in the process.",
      "createdAt": "2021-05-14T19:40:53Z",
      "updatedAt": "2021-11-19T23:40:18Z",
      "closedAt": "2021-11-19T23:40:18Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "body": "So... when my computer says \"thinking ...\", are you saying it's lying to me? ",
          "createdAt": "2021-05-14T22:56:31Z",
          "updatedAt": "2021-05-14T22:56:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "https://thedailywtf.com/articles/The-Speedup-Loop",
          "createdAt": "2021-05-15T19:31:22Z",
          "updatedAt": "2021-05-15T19:31:22Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU5MDMyOTg5MTk=",
      "title": "Consider reordering sections",
      "url": "https://github.com/quicwg/version-negotiation/issues/47",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Reading this with fresh-ish eyes, I found Section 4 to be what I wanted to read after the introduction.  I found the server upgrade/rollback text in Section 2 a bit heavy going.  I wanted to do was get to the bit that said how the protocol works.\r\n\r\nI think that you could move Section 4 right to the top.  I realize that this makes it tricky: you are relying a bit on the definitions of the different sets of versions at the server later, but I think that it is probably workable.  A forward reference to a definition for compatible versions is probably the most obvious missing piece.\r\n\r\nRight now, Section 4-6 are the \"how this protocol works\".  I think that these are pretty tight.  That's good work.\r\n\r\nSection 7 probably need to get folded into those sections.  It seems a little awkward.\r\n\r\nSection 2 is partly definitions and partly deployment considerations.  I think that the deployment stuff needs to go after the protocol description.\r\n\r\nSection 3 is a key definition, but that can probably get merged with Section 4.3 and moved there.  There's a fair bit of overlap between that text.  I would also fold in Section 8 as that relates to how things might be compatible (it might be a bit of a surprise to learn that it's not just the first flight that is sent in the original version).  The same applies to Section 9 for the same reason.\r\n\r\nSection 10 is something I would put alongside the server deployment stuff.  It's important enough for a top-level heading (as is the deployment stuff), but really, this stuff falls under the broad heading \"consequences of the design\".  Having that at the bottom with the security considerations is a good choice.  This stuff is really just applying logic to determining the consequences of the design and explaining that to people so they don't have to apply the same logic themselves.  When you get to this part, you should not be surprising anyone with new information, you are just helping to fill in the gaps.",
      "createdAt": "2021-05-27T06:59:09Z",
      "updatedAt": "2022-03-07T23:38:10Z",
      "closedAt": "2022-03-07T23:38:10Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDODoD7vc49TVqF",
      "title": "Small transport parameter codepoint",
      "url": "https://github.com/quicwg/version-negotiation/issues/53",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I just saw a provisional registration for the 0xff73db value (from the current draft).  This contains a note suggesting that the value might become permanent.\r\n\r\nGiven how crucial version negotiation could be, I think we should seriously consider taking a codepoint from the 0-63 range.",
      "createdAt": "2021-10-18T00:14:10Z",
      "updatedAt": "2021-10-18T15:57:29Z",
      "closedAt": "2021-10-18T15:57:29Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, that was the intent but it wasn't clear from the draft. I wrote in #54 to make it clearer.",
          "createdAt": "2021-10-18T15:57:16Z",
          "updatedAt": "2021-10-18T15:57:23Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDODoD7vc4_Eif8",
      "title": "Backward compatibility with the version negotiation of RFC 9000",
      "url": "https://github.com/quicwg/version-negotiation/issues/55",
      "state": "CLOSED",
      "author": "kazu-yamamoto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Suppose that a client supports QUIC v1, v2 and the new negotiation while a server supports RFC 9000 only. \r\n\r\nThe following normal scenario succeeds because the client does not receive a VN packet so the client does not have to check `version_information`:\r\n\r\n```\r\n- C: Initial: ver=1, version_information = 1, {2, 1}\r\n- S: Initial: ver=1, Handshake\r\n- C: Handshake: ver=1\r\n```\r\n\r\nHowever, the following scenario, I think, fails:\r\n\r\n```\r\n- C: Initial: ver=greasing, version_information = greasing, {2, 1, greasing}\r\n- S: VN: ver=0, {1}\r\n- C: Initial: ver=1, version_information = 1, {1}\r\n- S: Initial: ver=1, Handshake\r\n- C: Handshake: CC\r\n```\r\n\r\nThe client sent CC because `version_information` is missing.\r\n\r\nThe latter is the common method to test the version negotiation of RFC 9000. Are we giving up this method?",
      "createdAt": "2021-11-19T05:31:28Z",
      "updatedAt": "2022-03-22T00:01:13Z",
      "closedAt": "2022-03-22T00:01:12Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "It looks like the key flaw here is in dealing with servers that don't understand this extension.  I think that we fix that by treating absence of version_information as being equivalent to \"version_information = 1, {1}\" or \"version_information = 1, {}\" (which is functionally equivalent).\r\n\r\nThat is, of course, in tension with this text in [Section 6](https://quicwg.org/version-negotiation/draft-ietf-quic-version-negotiation.html#section-6-3):\r\n\r\n> If the Version Information was missing, the endpoints MAY complete the handshake if they have reason to believe the peer might not support this extension. \r\n\r\n... so far so good.\r\n\r\n> However, if a client has reacted to a Version Negotiation packet and the Version Information was missing, the client MUST close the connection; if the connection was using QUIC version 1, that connection closure MUST use a transport error of type VERSION_NEGOTIATION_ERROR.\r\n\r\nThat part probably needs to be revised.",
          "createdAt": "2021-11-19T05:37:13Z",
          "updatedAt": "2021-11-19T05:37:13Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "With the current spec, \"version_information = 1, {}\" from a *client* is not allowed. So for simplicity, \"version_information = 1, {}\" from a *server* should not be allowed, either. Only the form of \"version_information = 1, {1}\" should be allowed.",
          "createdAt": "2021-11-19T06:09:37Z",
          "updatedAt": "2021-11-19T06:09:37Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with the premise, the scenario where the client starts with a grease version, waits for VN then tries with a version from the VN packet doesn't work with this extension. But that scenario was never specifically allowed in RFC 9000, it's just something a few implementations picked up along the way. I'd suggest either doing nothing, or having an appendix that mentions this version greasing technique. I'd rather not treat a missing parameter as something present, because that opens up a class of downgrade attacks against servers that don't support this extension.",
          "createdAt": "2021-11-19T17:28:41Z",
          "updatedAt": "2021-11-19T17:28:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conceptually, this comes down to one question: if the server doesn't support this extension, should the client fail open or fail closed. I'd argue fail closed because it has better security and this scenario won't happen in practice.",
          "createdAt": "2021-11-19T17:29:37Z",
          "updatedAt": "2021-11-19T17:29:37Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "I don't have a strong opinion. I just want to have a clear spec. \r\n\r\nLet's consider another scenario. Suppose that a server supports RFC 9000 only and does not allow draft-29. If I understand correctly, the following would happen without the greasing version:\r\n\r\n```\r\n- C: Initial: ver=draft-29, version_information = draft-29, {2, 1, draft-29}\r\n- S: VN: ver=0, {1}\r\n- C: Initial: ver=1, version_information = 1, {1}\r\n- S: Initial: ver=1, Handshake\r\n- C: Handshake: CC\r\n```\r\n\r\n@DavidSchinazi Does this scenario change your opinion?",
          "createdAt": "2021-11-19T23:10:50Z",
          "updatedAt": "2021-11-19T23:10:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The specification for draft-29 states that if you receive VN you MUST close the connection. If you support draft-29 and the VN draft, then you try again but require the presence of version_information and fail the handshake if it's missing. This scenario isn't ambiguous. We need to fail the handshake in this scenario because otherwise we're exposing the client to version downgrade attacks.",
          "createdAt": "2021-11-19T23:17:29Z",
          "updatedAt": "2021-11-19T23:17:29Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "OK. I would like to add an appendix which describe the four scenarios in https://github.com/kazu-yamamoto/quic/issues/19.",
          "createdAt": "2021-11-19T23:30:04Z",
          "updatedAt": "2021-11-19T23:30:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's reasonable. Can you send a PR with the appendix you have in mind please?",
          "createdAt": "2021-11-20T00:50:37Z",
          "updatedAt": "2021-11-20T00:50:37Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "I will.",
          "createdAt": "2021-11-20T01:33:58Z",
          "updatedAt": "2021-11-20T01:33:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "> The specification for draft-29 states that if you receive VN you MUST close the connection.\r\n\r\nWhat about if you support version 2 and version 1?  Version 2 will say that you need to support this draft.  But if the server doesn't support version 2, then do you also need to fail on the basis that you are now executing version 1 logic?  That seems like it is the wrong answer.\r\n\r\nSure, most sensible clients will attempt version 1 and offer a compatible upgrade to version 2, but that doesn't mean we shouldn't consider the converse.",
          "createdAt": "2021-11-22T23:26:35Z",
          "updatedAt": "2021-11-22T23:26:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see two solutions here:\r\n1. Tell the client to not do that - we already have text in the \"Client Choice of Original Version\" section but we could expand on it\r\n2. Fail open (in other words, don't fail the handshake if version_negotiation is missing)\r\n\r\nDo you have opinions on which is best? (or if you see other solutions)",
          "createdAt": "2021-11-23T01:00:18Z",
          "updatedAt": "2021-11-23T01:00:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "In this case, we have special information: if the server only supports version 1 (let's not drag pre-RFC9000 draft versions into this), then the absence of the extension might be used to confirm that.  That only works for version 1, but it seems OK to me to accept that as a positive signal (as opposed to the absence of one).",
          "createdAt": "2021-11-23T01:11:04Z",
          "updatedAt": "2021-11-23T01:11:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about a server that supports QUICv1 and Google QUIC versions Q050 and Q043? Or some other future non-IETF versions? In other words, what change to the draft do you have in mind? We could special-case QUICv1 but I'm not sure what it'd get us.",
          "createdAt": "2021-11-23T18:37:06Z",
          "updatedAt": "2021-11-23T18:37:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "My suggestion is that we say that a client that negotiates QUIC version 1 can assume that the server ONLY supports QUIC version 1 for the purposes of validation.  That is, in the absence of the extension and if QUIC version 1 is in use, the client may assume that the extension is present with a value of `1, {1}` (to use Kazu's notation).\r\n\r\nThat privileges QUIC version 1 as the version of QUIC that we defined prior to this, but I don't think we can extend this sort of compatibility to other protocols without risking the exact sort of downgrades we're trying to avoid.\r\n\r\nSadly, that means that Q050 and Q043 are not protected in the same way.  Implementations of other QUIC versions could add support for this extension though.",
          "createdAt": "2021-11-23T23:38:33Z",
          "updatedAt": "2021-11-23T23:38:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds reasonable to me. If we rely on the following two assumptions:\r\n1. QUICv1 is preferred over earlier versions (such as 0xff00001d or Q050)\r\n2. versions that are created after QUICv1 will use this draft\r\n\r\nthen we're guaranteed that a downgrade attack against a QUICv1+Q050 server isn't possible, while still allowing VN to servers that only support QUICv1.",
          "createdAt": "2021-11-23T23:56:31Z",
          "updatedAt": "2021-11-23T23:56:31Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDODoD7vc4_ltFJ",
      "title": "Specify impact on encryption keys",
      "url": "https://github.com/quicwg/version-negotiation/issues/67",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I am reading the draft, and I have doubts on how this is supposed to affect encryption keys.\r\n\r\nSuppose a classic exchange: the client sends a couple of initial packets, the server parses them and acknowledges them, the server then sends initial and handshake packets. I think we have the following constraints:\r\n\r\n1) The server will only complete the compatible version negotiation after receiving \"enough\" of the client's initial packets, i.e., enough to parse the QUIC transport parameters.\r\n2) The server transport parameters are sent as encrypted extensions. The client will only receive them after receiving \"enough\" handshake packets.\r\n3) The client could learn that the server has chosen a new version at any point during the handshake, by receiving a new version field in a long header packet --  Initial or handshake.\r\n\r\nSo we get possible variations:\r\n\r\n1) Server receives client first flight with V1, may reply with V1 ACK until the flight has been received, but uses V2 for the reminder of the handshake, i.e., sends server hello in a V2 Initial packet, sends the encrypted parameters and the reminder of the server first flight in V2 handshake packets. Upon reception and successful decryption of initial V2 packet, the client switches to V2.\r\n\r\n2) Same but server sends all Initial packets using V1, all handshake packets using V2. Client switches to V2 upon reception and successful decryption of V2 handshake packet.\r\n\r\n3) Server keeps using V1 for initial and handshake packets, switches to V2 for 1RTT packets. Client keeps using V1 until the handshake completes, switches to V2 for 1RTT packets.\r\n\r\nVariation 3 is the easiest to implement, but I suspect that \"the server converts the client's first flight to that version and replies to the client as if it had received the converted first flight\" actually implies variation 1. That variation requires that the client makes a pretty expensive decision, recomputing the encryption keys using the new version's parameters upon receiving a packet with a \"negotiated\" version in the version header. Since the encryption key of initial packets is well known, this is yet another avenue for third parties to send poisoned packets and cause the client to fail the connection, but I suppose that will not stop us because there are many such attacks already.\r\n\r\nIn any case, the current text is not very explicit. I think that we will save a lot of interop issues by being more explicit, maybe presenting the expected flow of packets.\r\n\r\n",
      "createdAt": "2021-11-30T06:31:42Z",
      "updatedAt": "2022-03-07T23:08:04Z",
      "closedAt": "2022-03-07T23:08:04Z",
      "comments": [
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "I agree that timing of key installation is severe. From the anti-ossification point of view, V2 should be used as much as possible. So, variant 1 is ideal but it is hard to implement it.",
          "createdAt": "2021-11-30T12:16:36Z",
          "updatedAt": "2021-11-30T12:16:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am doing a thought experiment, hypothesizing a V3 version of QUIC in which the handshake changes radically. Instead of using just Initial and Handshake packets, the Handshake would also use Zero RTT packets, because we magically found a way to always have a Resume Token available, or maybe a shared password. In the new V3 version we would have:\r\n\r\n* From client: Initial packet carry Client Hello and some unencrypted parameters. \r\n* From client: Zero RTT packets carry encrypted handshake parameters\r\n* From server: Zero RTT packets carry Server Hello and unencrypted extensions. \r\n* From server: Handshake packets carry reminder of server flight\r\n* From client: Handshake packet carry Client's Fin.\r\n\r\nMaybe V3 is designed to prevent third parties from spoofing the server. In the transition phase, we would want something like:\r\n\r\n* From client: Initial V1 packet carry Client Hello and all parameters. \r\n* From server: Zero RTT V3 packets carry Server Hello and unencrypted extensions. \r\n* etc...\r\n\r\nThat would preserve the key \"defense from spoofing\" when the negotiation succeeds. But it does require something like variation #1.\r\n\r\n\r\n",
          "createdAt": "2021-11-30T13:06:11Z",
          "updatedAt": "2021-11-30T13:06:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current text in the draft was written with Google's implementation in mind, where the server will never send a packet until it has received the full client hello. Therefore the intent was:\r\n* client sends first flight in v1\r\n* if some of those packets get lost, the client retransmits all of them\r\n* once server receives the full client hello, it can decide to perform compatible VN with v2\r\n* all server packets are then sent with v2\r\n\r\nThis issue makes me realize that some implementations may wish to acknowledge initial packets before receiving the full client hello, which I hadn't thought of. If the client hello ever becomes more than a handful of packets, this might be useful.\r\n\r\nI would prefer variation 1 (server sends initial acks of client's first flight in v1 but everything else in v2, including the server hello) as that would match our implementation model, and has the property of switching to the newer version ASAP.\r\n\r\nI agree that we should be clearer, though I'm not sure if that belongs in this draft since this draft intends to be mostly version agnostic. Perhaps that's something that needs to be added to the QUICv2 draft in the section when it declares itself compatible with QUICv1?",
          "createdAt": "2021-11-30T21:59:52Z",
          "updatedAt": "2021-11-30T21:59:52Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "Yes, it would be nicer if we add VN scenarios to the V2 draft instead of the VN draft.",
          "createdAt": "2021-11-30T23:20:05Z",
          "updatedAt": "2021-11-30T23:20:05Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think you cannot pass the burden to every new version draft. You have to be very explicit about what is expected.\r\n\r\nOn the implementation part: picoquic uses picotls. When initial or handshake packets are received, picoquic passes the content of the \"crypto\" frames to picotls. Picotls does its own thing according to the TLS 1.3 logic. At some point it will callback into picoquic for events like \"handshake secret is now available\" or \"transport parameter option has been received\". In my tests, the order of events on the client was:\r\n\r\n1. set zero RTT encode secret (when sending the client hello)\r\n2. receive the server initial packet with new version set (which causes client to declare negotiation successful)\r\n3. set handshake encode secret (when receiving the server hello extensions)\r\n4. set handshake decode secret (when receiving the server hello extensions)\r\n5. process the transport options (when receiving the server first flight)\r\n6. set the 1rtt encode secret (after receiving the server first flight)\r\n7. set the 1rtt decode secret (father receiving the server first flight)\r\n\r\nOn the server, the order is:\r\n\r\n1. set the zero RTT decode secret (when receiving the client hello)\r\n2. process the transport options (when receiving the client hello) and do the negotiation\r\n3. set handshake encode secret (after composing the server hello)\r\n4. set handshake decode secret (after composing the server hello)\r\n4. send the server initial packet with new version set (which causes client to declare negotiation successful)\r\n6. set the 1rtt encode secret (after sending the server first flight)\r\n7. set the 1rtt decode secret (father receiving the client finished)\r\n\r\nIn the specific case of the V1 to V2 \"reprocessing\" means replacing the initial key computed with the V1 initial secret by one that uses the V2 secret. However, on the client side, we have to do this reprocessing in a speculative manner, upon receiving a first long header packet with version = V2. \r\n",
          "createdAt": "2021-12-01T00:02:04Z",
          "updatedAt": "2021-12-01T00:02:04Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is something weird happening with 0-RTT. See issue #68 ",
          "createdAt": "2021-12-01T00:12:11Z",
          "updatedAt": "2021-12-01T00:12:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think you cannot pass the burden to every new version draft. You have to be very explicit about what is expected.\r\n\r\nI don't understand, how can this draft be explicit about future versions that don't exist yet?\r\n\r\n> In the specific case of the V1 to V2 \"reprocessing\" means replacing the initial key computed with the V1 initial secret by one that uses the V2 secret. However, on the client side, we have to do this reprocessing in a speculative manner, upon receiving a first long header packet with version = V2.\r\n\r\nIs that a problem?\r\n\r\n",
          "createdAt": "2021-12-01T00:47:59Z",
          "updatedAt": "2021-12-01T00:47:59Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDODoD7vc4_pUpn",
      "title": "Specify impact on 0-RTT, session resume tickets, etc.",
      "url": "https://github.com/quicwg/version-negotiation/issues/68",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "0-RTT is a weird case. 0-RTT packets are sent by the client using the \"old\" version, but they will be received by the server after the server has completed the negotiation to the new version. There are many plausible solutions, such as:\r\n\r\n1) Do not do both 0-RTT and version negotiation. If a session resumed ticket was received after negotiating from version=A to version=B, then the resumed connection shall use version=B.\r\n2) Accept that 0-RTT packets are decrypted with version=A.\r\n3) Maybe let clients recompute the 0-RTT key after the negotiation completes.\r\n\r\nAll of these have pros and cons, but they should be specified.",
      "createdAt": "2021-12-01T00:09:13Z",
      "updatedAt": "2022-03-07T23:28:33Z",
      "closedAt": "2022-03-07T23:28:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interaction with 0-RTT is discussed in [Section 9](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation#section-9). What's missing?",
          "createdAt": "2021-12-01T00:49:21Z",
          "updatedAt": "2021-12-01T00:49:21Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is probably possible to express the issue in a version independent way.\r\n\r\nSomething like:\r\n\r\n  * Client sends a first flight composed on Version A packets\r\n  * Midway through that flight, server receives enough data to decide to upgrade to version B\r\n  * Server keeps receiving Version A packets for some times after the upgrade\r\n \r\n Upgrade specification shall say what to do with these \"after upgrade\" packets.\r\n\r\nAlso, you probably want to say how negotiation interacts with session resume. Shall the client remember that this particular session resume ticket was received after negotiating version B? Is it OK to just attempt to resume using version B? What does that do to server farms and partial upgrades? If the server farm is not completely updated, should servers list the version B in their supported version list?\r\n\r\n\r\n",
          "createdAt": "2021-12-01T02:10:32Z",
          "updatedAt": "2021-12-01T02:10:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It is probably possible to express the issue in a version independent way.\r\n> \r\n> Something like:\r\n> \r\n> * Client sends a first flight composed on Version A packets\r\n> * Midway through that flight, server receives enough data to decide to upgrade to version B\r\n> * Server keeps receiving Version A packets for some times after the upgrade\r\n> \r\n> Upgrade specification shall say what to do with these \"after upgrade\" packets.\r\n\r\nMy impression is that Section 9 pretty much says this already, but perhaps I'm misunderstanding what you're looking for. Could you send a PR with what you have in mind?\r\n\r\n> Also, you probably want to say how negotiation interacts with session resume. Shall the client remember that this particular session resume ticket was received after negotiating version B? Is it OK to just attempt to resume using version B?\r\n\r\nAs far as I can tell, TLS 1.3 session tickets aren't tied to a transport or application protocol, so they can be used across QUIC versions, right?\r\n\r\n> What does that do to server farms and partial upgrades? If the server farm is not completely updated, should servers list the version B in their supported version list?\r\n\r\nThis is discussed in [Section 2](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation#section-2).\r\n",
          "createdAt": "2021-12-01T02:17:27Z",
          "updatedAt": "2021-12-01T02:17:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I think that the draft should say that a client that receives a session ticket MUST remember the version that was negotiated in that session and attempt a connection with that version only when using the ticket.  The server MAY reject resumption if the ticket version doesn't match.\r\n\r\nYes, you could just resume with TLS and do a concurrent version upgrade.  TLS won't care, but your application state might if it cares about version-specific capabilities.  Especially with 0-RTT.  I don't see much point in engaging with that.  Just require that the version stay the same.",
          "createdAt": "2022-01-05T06:12:33Z",
          "updatedAt": "2022-01-05T06:12:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe that we may want different behavior based on whether or not the negotiated version is supported. Suppose two connections in which the client initiated a connection with version A. In the first, the server parameters contain:\r\n* negotiated: version B\r\n* supported: [ version A, version B]\r\nIn that case, I think we agree that the client should resume using version B, and may use 0RTT.\r\n\r\nIn the second case, the server parameters contain:\r\n* negotiated: version B\r\n* supported: [ version A]\r\n\r\nFor me the second variant indicates that the server would like further connections to be initiated with version A. Could be for many reasons, but a common one would be partial deployment of version B in a server farm. In that specific case, the client may well want to resume with version A and use 0RTT of version A.",
          "createdAt": "2022-01-06T00:59:21Z",
          "updatedAt": "2022-01-06T00:59:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This is good input.  I think that we might recommend something like that, though I don't think we need to go any further.",
          "createdAt": "2022-01-07T03:07:45Z",
          "updatedAt": "2022-01-07T03:07:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unless I'm misunderstanding something, I think @huitema's and @martinthomson's proposals are mutually exclusive. In the second case from [Christian's latest comment](https://github.com/quicwg/version-negotiation/issues/68#issuecomment-1006199546), the first connection will be using version B (because the server decided to perform compatible VN from A to B) and therefore the client will receive a version B resumption ticket (since tickets are sent in 1-RTT packets). So if the client then tries to resume with version A, it runs afoul of MT's [MUST resume with same version](https://github.com/quicwg/version-negotiation/issues/68#issuecomment-1005410540). Am I missing something?",
          "createdAt": "2022-01-10T16:43:33Z",
          "updatedAt": "2022-01-10T16:43:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I was originally convinced of the merits of Christian's approach here (I even opened an issue on our implementation to consider it), but I've since revised that.  Though - in theory - this is right, the chances that resumption is needed during the time that a cluster is partially upgraded is small enough that I don't think that it's worth the extra complication.\r\n\r\nIf you have a server cluster that is rolling out v2, then it might be that you choose v2.  When the client later resumes, presumably the cluster is further along with their rollout, making the odds of hitting a v1-only node low.  Even with an extended rollout and a rapid resumption, which should be rare, the cost of that is a Version Negotiation packet and a full handshake: one round trip extra, maybe two.  Given the transient nature of rollouts, this seems workable.\r\n\r\nRollback is the other case where you might encounter this sort of skew.  That is something that generally only happens when things have gone pear-shaped, so I'm not going to worry too much about some extra latency there.",
          "createdAt": "2022-01-11T00:43:27Z",
          "updatedAt": "2022-01-11T00:43:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson you are assuming that a significant time elapses between initial connection and resumption. That assumption may not be true for all applications. In DoQ for example, resumption is used as an alternative to keep-alive. The interval between connection may well be on the same order of magnitude as the idle timeout -- 10 or 20 seconds. ",
          "createdAt": "2022-01-11T01:56:19Z",
          "updatedAt": "2022-01-11T01:56:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "That seems enough that circumstances could have changed, or at least that failed resumptions won't adversely affect performance.",
          "createdAt": "2022-01-11T02:52:06Z",
          "updatedAt": "2022-01-11T02:52:06Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am trying to think how these issues play out at the TLS level. Are we going to require that implementations encode the version number in the resumption token? If we don't, then there is hardly any enforcement possible, and the arguments behind use-it-or-lose-it come to mind. But then, can implementations actually tie a TLS resumption token to a QUIC version? I think I could implement that in Picoquic, but given the \"black-box\" API between TLS and QUIC, I would not assume that all implementations can.\r\n\r\nThen there is of course the whole issue of tying -- or not -- versions of QUIC to versions of TLS. Or, for that matter, using something else than TLS in a future version of QUIC.\r\n\r\nAnd there is a specific case of V1->V2. There is no actual functional benefit to V2. If there is a performance cost, then the upgrade is going to only be used rarely...",
          "createdAt": "2022-01-11T03:21:25Z",
          "updatedAt": "2022-01-11T03:21:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "It's trivial in my implementation, black box and all.  That is, if you do 0-RTT, you have to remember a bunch of stuff with tickets, so this is just one more piece of data (4 bytes at most).  So implementation-wise, I can't see any issue.\r\n\r\nKeep in mind that this performance cost occurs rarely, only during times when a cluster has uneven support AND when that uneven support covers a connect-resume cycle.  Seems like it isn't worth solving generically.",
          "createdAt": "2022-01-11T03:57:44Z",
          "updatedAt": "2022-01-11T03:57:44Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is trivial to do that in a client implementation. Not so much in a server implementation, especially those that put all the state in the encrypted token. That gets a bizarre tradeoff in which clients can decide to abide by the matching token version requirement although it might in some case impede performance, but servers have a hard time enforcing that requirement.",
          "createdAt": "2022-01-11T19:43:15Z",
          "updatedAt": "2022-01-11T19:43:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why is this not trivial on the server? Since servers already need to encode TPs and h3 settings as a binary blob in the ticket, adding the version to that blob should be trivial right?",
          "createdAt": "2022-01-11T20:02:48Z",
          "updatedAt": "2022-01-11T20:02:48Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Servers do not need to use the initial settings -- this is only for clients sending 0-RTT. The servers only sends data after the negotiation has been done. Servers may need to verify that the client is not sending something excessive in 0-RTT, but they have a very good idea of what initial parameters they use by default, and thus do not need to replicate them in the blob. Might be interesting to ask server developers what they actually do.",
          "createdAt": "2022-01-11T21:48:52Z",
          "updatedAt": "2022-01-11T21:48:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The h3 draft states:\r\n> A server can remember the settings that it advertised, or store an integrity-protected copy of the values in the ticket and recover the information when accepting 0-RTT data. A server uses the HTTP/3 settings values in determining whether to accept 0-RTT data. If the server cannot determine that the settings remembered by a client are compatible with its current settings, it MUST NOT accept 0-RTT data. Remembered settings are compatible if a client complying with those settings would not violate the server's current settings.\r\n\r\nSo the server needs to store _something_ about settings. It could be the full settings, a hash, or just a number, but it needs _something_ if it wants to be able to ever change its settings without rotating session ticket keys at the same time.\r\n\r\nSpeaking as a server developer, our stack serializes the entire settings frame into the ticket.\r\n\r\nI could imagine a server just rotating their keys when they change settings or transport parameters and not having to store data in the ticket, but it's pretty much required if you want to support multiple keys at once which is required for good performance with proper key rotation practices.",
          "createdAt": "2022-01-12T15:35:21Z",
          "updatedAt": "2022-01-12T15:35:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "> Speaking as a server developer, our stack serializes the entire settings frame into the ticket.\r\n\r\nSo THAT's why they are so huge!  (Seriously though, that's exactly what we do as well, even though our server is not deployed in quite the same way, it's the easiest thing to do.)",
          "createdAt": "2022-01-12T23:53:39Z",
          "updatedAt": "2022-01-12T23:53:39Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, Google and Mozilla. I am almost convinced. Care to ask the wider group?\r\n",
          "createdAt": "2022-01-13T00:44:52Z",
          "updatedAt": "2022-01-13T00:44:52Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The nice thing there is that it trains middleboxes to support very large resumption tickets. I can think of quite a few hacks based on that property...\r\n",
          "createdAt": "2022-01-13T00:46:06Z",
          "updatedAt": "2022-01-13T00:46:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The normative requirement on servers is unenforceable, so I'd suggest adding it anyway - since most servers will enforce this, clients will do the work of not reusing across versions, so even servers that do not enforce will ultimately be safe. I'll write up a PR to the VN draft that mentions this in vague terms, and filed https://github.com/quicwg/quic-v2/issues/31 to add normative text to the QUICv2 draft.",
          "createdAt": "2022-01-13T18:21:55Z",
          "updatedAt": "2022-01-13T18:21:55Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDODoD7vc4_pV34",
      "title": "How can the server chosen version field be empty?",
      "url": "https://github.com/quicwg/version-negotiation/issues/69",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft says:\r\n\r\n_Server-Sent Other Versions:\r\n\r\n    When sent by a server, the Other Versions field lists all the Fully-Deployed Versions of this server deployment, see Section 2. Note that the version in the Chosen Version field is not necessarily included in this list, because the server operator could be in the process of removing support for this version. For the same reason, this field MAY be empty._\r\n\r\nBut the syntax is:\r\n```\r\nVersion Information {\r\n  Chosen Version (32),\r\n  Other Versions (32) ...,\r\n}\r\n```\r\nWhat does the draft exactly mean by \"_this field MAY be empty_\"?",
      "createdAt": "2021-12-01T00:16:23Z",
      "updatedAt": "2021-12-02T21:26:15Z",
      "closedAt": "2021-12-02T21:26:15Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The \"Other Versions\" field contains a list of versions, whose length can be zero. That text exists to remind people that the list of Fully-Deployed Versions can be empty, and that shouldn't cause handshake failures.",
          "createdAt": "2021-12-01T00:50:54Z",
          "updatedAt": "2021-12-01T00:50:54Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text is far from clear, because the sentence mixes references to \"Other Versions\" and \"Chosen version\". Stating \"For the same reason, the Other Versions field MAY be empty\" would remove the ambiguity.",
          "createdAt": "2021-12-01T02:13:21Z",
          "updatedAt": "2021-12-01T02:13:21Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for clarifying, I've written that up as #71.",
          "createdAt": "2021-12-01T02:35:47Z",
          "updatedAt": "2021-12-01T02:35:47Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDODoD7vc4_pXxA",
      "title": "Security issue when upgrading based on received version in header",
      "url": "https://github.com/quicwg/version-negotiation/issues/70",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The exchange with a successful negotiation may look like:\r\n```\r\n    Initial packet, long header, version=A ---->\r\n                   [server receives transport parameters]\r\n            <---- server response, long header, version=B\r\n            <------- more packets, long header, version=B\r\n    [client receives transport parameters]\r\n```\r\nThe discussion of issue #67 shows the value of having the server switch to the new version as soon as the negotiation completes. But then, the client can only decrypt the server response if it verifies that \"version = B\" is an expected response, and then starts using the version B encryption keys, etc.\r\n\r\nThere is very little protection there. Are we worried that third parties might spoof a successful negotiation?",
      "createdAt": "2021-12-01T00:28:22Z",
      "updatedAt": "2022-03-07T22:52:43Z",
      "closedAt": "2022-03-07T22:52:43Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand the problem here. The version will be retroactively blessed when the handshake completes, just like the rest of the handshake negotiation.",
          "createdAt": "2021-12-01T00:29:32Z",
          "updatedAt": "2021-12-01T00:29:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to what @ekr said.\r\n\r\n@huitema this is addressed in [Security Considerations](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation#section-11):\r\n\r\n> Negotiation between compatible versions will have the security of the weakest common version.",
          "createdAt": "2021-12-01T00:52:44Z",
          "updatedAt": "2021-12-01T00:52:44Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I get that the whole posture is \"best effort until the handshake is complete, detection of issues during the completion\", and that the final verification will detect spoofing and terminate the connection. So this is basically one more avenue for injecting spoofed packets during the handshake, causing the connection to crash. We may or may not want to mention that.",
          "createdAt": "2021-12-01T01:58:13Z",
          "updatedAt": "2021-12-01T01:58:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's already trivial to cause a handshake failure by injecting spoofed packets, this doesn't make it any worse. So I don't think we absolutely need to mention this but I wouldn't oppose an addition to Security Considerations if you want to write a PR.",
          "createdAt": "2021-12-01T02:24:17Z",
          "updatedAt": "2021-12-01T02:24:17Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am implementing that right now, and I am trying to understand when to accept this \"automatic\" negotiation. This may be a V1 only issue, but I suspect we will find it with other versions as well.\r\n\r\nThe basic protection is that packets received with the wrong version are considered bogus, and are just ignored. I need to create an exception to that rule when negotiation is in progress, accept packet if the version would be accepted after successful negotiation, and do as if the negotiation had already succeeded. The obvious restriction is to only do that on the client, before the handshake is complete. But that still opens a large time window for attacks.\r\n\r\nRestricting to \"TP negotiation not complete yet\" is a bit better than \"handshake not complete yet\", but still leaves a large window. Restricting to \"this is the first packet from the server\" does not work, because the server could be sending initial acknowledgements. Reasoning such as \"no crypto frame received yet\" might work, but the existence of \"crypto frames\" is version dependent. ",
          "createdAt": "2021-12-01T19:05:28Z",
          "updatedAt": "2021-12-01T19:05:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema what problem are you trying to solve? As long as initial receive keys are present, it's trivial for an attacker to make the handshake fail. The version field doesn't change that in any way, and doesn't offer any protection. Or am I misunderstanding something here?",
          "createdAt": "2021-12-01T19:32:10Z",
          "updatedAt": "2021-12-01T19:32:10Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is indeed a denial-of-service window lasting as long as initial packets are accepted. It stops when the handshake keys are computed, at which point picoquic stops processing initial packets. I am trying to ensure that supporting version negotiation  does not extend that window.\r\n\r\nBut yes, I fully get the general point. If we want to protect against packet injection during the handshake, we have to use some crypto. Maybe derive a token from ECH, or something like that.",
          "createdAt": "2021-12-01T19:53:44Z",
          "updatedAt": "2021-12-01T19:53:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, I totally agree with your goal. So far I don't see any vector by which this draft extends the DoS window, but adding text to Security Considerations (or perhaps to Considerations for Future Versions) could help ensure we avoid this pitfall in the future.",
          "createdAt": "2021-12-01T20:02:16Z",
          "updatedAt": "2021-12-01T20:02:16Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we've merged this into the quicv2 draft, is there anything else to say in VN?",
          "createdAt": "2022-03-07T22:46:02Z",
          "updatedAt": "2022-03-07T22:46:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Between what we have in the QUICv2 draft and PR #87 here, this should be covered. So I'm going to close this with no action. Please reopen/comment if you disagree.",
          "createdAt": "2022-03-07T22:52:43Z",
          "updatedAt": "2022-03-07T22:52:43Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDODoD7vc4_qDFw",
      "title": "validating Version Information on compatible negotiation",
      "url": "https://github.com/quicwg/version-negotiation/issues/72",
      "state": "CLOSED",
      "author": "kazu-yamamoto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm reading editor's draft.\r\n\r\nIt says that both peers MUST parse Version Information. This is good.\r\n\r\nHowever, a client MUST validate Version Information only on incompatible version negotiation (\"acted on a Version Negotiation packet\"). I think the same validation should be done on compatible version negotiation.",
      "createdAt": "2021-12-01T05:44:21Z",
      "updatedAt": "2022-03-07T23:08:04Z",
      "closedAt": "2022-03-07T23:08:04Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you elaborate? What validation should the client do if it hasn't reacted to a VN packet?",
          "createdAt": "2021-12-01T06:18:46Z",
          "updatedAt": "2021-12-01T06:18:46Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "I think that Chosen Version MUST be the same as the version in the Initial packet from the server.",
          "createdAt": "2021-12-01T06:47:48Z",
          "updatedAt": "2021-12-01T06:47:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That doesn't quite work - sometimes you might use some packets of the original version (see #25 and #67). The security property we want is to ensure that after the handshake, the server's \"Chosen Version\" is the one used by the connection. That property is guaranteed by this text from the end of Section 6:\r\n\r\n> After the process of version negotiation in this document completes, the version in use for the connection is the version that the server sent in the Chosen Version field of its Version Information. That remains true even if other versions were used in the Version field of long headers at any point in the lifetime of the connection; endpoints MUST NOT change the version that they consider to be in use based on the Version field of long headers as that field could be forged by attackers.",
          "createdAt": "2021-12-01T18:47:21Z",
          "updatedAt": "2021-12-01T18:47:21Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi So, why does a server have to send back Version Information (which is not validated at all) for compatible negotiation?",
          "createdAt": "2021-12-01T23:33:42Z",
          "updatedAt": "2021-12-01T23:33:42Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This exists to prevent an attacker from modifying the version: since the authenticity of version information is protected during the handshake, it guarantees that, once the handshake is complete, the client is using the version that the server chose.",
          "createdAt": "2021-12-02T21:13:18Z",
          "updatedAt": "2021-12-02T21:13:18Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "Do you mean that a client should check if Chosen Version is the same as using version when handshake is complete?",
          "createdAt": "2021-12-03T00:04:18Z",
          "updatedAt": "2021-12-03T00:04:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that's one way of implementing this",
          "createdAt": "2021-12-03T00:08:23Z",
          "updatedAt": "2021-12-03T00:08:23Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDODoD7vc4_uJAM",
      "title": "Validation on incompatible negotiation",
      "url": "https://github.com/quicwg/version-negotiation/issues/73",
      "state": "CLOSED",
      "author": "kazu-yamamoto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> That is, the client would have selected the same version if it received a Version Negotiation packet that listed the versions in the server's Other Versions field, plus the negotiated version. \r\n\r\n- Q1) Other Versions can be empty. In that case, should validation fail?\r\n- Q2) What does this \"negotiated version\" refer to? (I guess \"it selects a mutually supported version and sends a new first flight with that version\")\r\n- Q3) Why don't we check Chosen Version at all?",
      "createdAt": "2021-12-02T02:26:36Z",
      "updatedAt": "2021-12-06T23:57:36Z",
      "closedAt": "2021-12-06T23:57:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Q1: correct. I've written #75 to make that explicit in the spec.\r\nQ2: the term \"negotiated version\" is defined in Sections 4.2 and 4.3\r\nQ3: see #72 ",
          "createdAt": "2021-12-02T22:15:37Z",
          "updatedAt": "2021-12-02T22:15:37Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "Relating to Q3. #72 is about compatible nego. I'm asking the case of incompatible nego here.",
          "createdAt": "2021-12-03T00:00:45Z",
          "updatedAt": "2021-12-03T00:00:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Chosen Version is used to pick the version in both compatible and incompatible VNs, and also when the server uses the version that the client started with.",
          "createdAt": "2021-12-03T00:08:35Z",
          "updatedAt": "2021-12-03T00:08:35Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "OK. So, I feel that the following sentence should include something like \"Chosen Version MUST be checked .... If a mismatch is found, the connection MUST be closed with VERSION_NEGOTIATION_ERROR\".\r\n\r\n> After the process of version negotiation in this document completes, the version in use for the connection is the version that the server sent in the Chosen Version field of its Version Information. That remains true even if other versions were used in the Version field of long headers at any point in the lifetime of the connection; endpoints MUST NOT change the version that they consider to be in use based on the Version field of long headers as that field could be forged by attackers.",
          "createdAt": "2021-12-03T00:17:35Z",
          "updatedAt": "2021-12-03T00:17:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson since you were the motivation to replace verification with negotiation, do you have thoughts here? @huitema points out that when implementing this the client needs to pick the new version based on long headers before it sees the transport parameters",
          "createdAt": "2021-12-03T04:35:11Z",
          "updatedAt": "2021-12-03T04:35:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I think that \"negotiated\" is correct in this context (incompatible) even though it is really just the client selecting from a list, that's still negotiating a version (for which the outcome is a negotiated version).\r\n\r\nChristian is right about the process, but that doesn't mean we can't call it negotiation.  The process is negotiation.  The transport parameter captures the outcome of that negotiation...and the information necessary to validate that outcome.\r\n\r\nIf we hadn't named the Version Negotiation packet something else, we might have more flexibility in how things are named [^1], but that's a done deal.\r\n\r\n[^1]: Well, I guess we'd have the same amount of flexibility, except with different words.",
          "createdAt": "2021-12-03T04:55:39Z",
          "updatedAt": "2021-12-03T04:55:39Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am a bit puzzled here. Suppose that the client started with version 1, is receiving the transport parameters with chosen version X in handshake packet of version Y. There are four possible combination. My understanding is that only two are correct.\r\n\r\nhandshake \\ selected | version 1 | version 2\r\n-----------------------:| ---------- | -----------\r\nversion 1 | correct | error\r\nversion 2 | error | correct\r\n\r\nAm I wrong?",
          "createdAt": "2021-12-03T16:17:15Z",
          "updatedAt": "2021-12-03T16:17:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema that will depend on how the QUICv2 draft defines compatible VN from v1 to v2. I think we should define it in such a way that makes your table correct, but that's a design topic for that draft.",
          "createdAt": "2021-12-03T20:22:30Z",
          "updatedAt": "2021-12-03T20:22:30Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand that it is pretty hard to reason about this in the abstract, but I do believe that we could have some kind of invariant specification here. The basic idea is that we will have:\r\n\r\n* a client flight in which the client uses version A and proposes version B (and maybe C and D)\r\n* a negotiation happening when the server parses the transport parameters (or equivalent) received in the first flight and selects version B or remains with A\r\n* a server flight in which packets are carried as specified in version A or B.\r\n\r\nThe invariant matrix would be:\r\n\r\npacket header \\ selected | version A | version B\r\n--:| -- | --\r\nversion A | correct | error\r\nversion B | error | correct\r\n\r\nI would expect that the \"erroneous\" combinations result in a Version negotiation error.\r\n",
          "createdAt": "2021-12-03T20:38:48Z",
          "updatedAt": "2021-12-03T20:38:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we have invariants for this. For example, you had proposed that the server might have a first flight of ACKs in version A until it can parse the entire ClientHello. I don't think there's value in being prescriptive here, any invariant we come up with will rely on assumptions that might be broken by future versions of QUIC.",
          "createdAt": "2021-12-03T20:58:55Z",
          "updatedAt": "2021-12-03T20:58:55Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe what we want is some kind of guidelines on what reprocessing means, and the implication on packet parsing, etc. In any case, the server will transition from sending version A to sending version B. If version B is somehow preferred, we want that to happen before the handshake is complete. Both Kazu & I had to work this out for V1->V2, which makes me think some kind of guide will be useful. Maybe under the heading of \"implementation experience\".",
          "createdAt": "2021-12-04T20:40:03Z",
          "updatedAt": "2021-12-04T20:40:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That makes sense. I'm closing this issue in favor of https://github.com/quicwg/quic-v2/issues/15 since that's where the transition is defined.",
          "createdAt": "2021-12-06T23:57:35Z",
          "updatedAt": "2021-12-06T23:57:35Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDODoD7vc4_uUto",
      "title": "Current version in version info breaks transport parameters design patterns",
      "url": "https://github.com/quicwg/version-negotiation/issues/74",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "All the transport parameters standardized so far follow a specific pattern: the server can format its transport parameters at the beginning of the connection without waiting for the value of client parameters. Including the \"current version\" in the \"version_information\" transport parameter breaks that pattern.\r\n\r\nProposal: remove the \"current version\" field from the transport parameter.\r\n\r\nThe current version is already documented in the transport header, so removing that should have minimal effect. But it would remove the opportunity to easily tampering by middle-boxes.",
      "createdAt": "2021-12-02T04:09:46Z",
      "updatedAt": "2022-03-07T22:09:19Z",
      "closedAt": "2022-03-07T22:09:19Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "So I don't think that the pattern extends across versions.  That is, you might be able to unilaterally construct transport parameters for a connection once you decide what to do, but deciding on a version happens before that.\r\n\r\nHaving the version in the TLS handshake transcript is useful.  Then we are assured that both endpoints agree on that value.  Remove it and we lose that.",
          "createdAt": "2021-12-02T04:59:35Z",
          "updatedAt": "2021-12-02T04:59:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to what MT said, the Chosen Version field is required to avoid downgrade attacks. Breaking the pattern isn't a problem to me.",
          "createdAt": "2021-12-02T21:19:18Z",
          "updatedAt": "2021-12-02T21:19:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the functionality is worth breaking this established pattern, and that we should not remove the \"current version\" field. Maybe acknowledge that we are breaking the pattern, and give explicit reasons like detect tampering by intermediaries and have the negotiated version in the TLS handshake transcript.",
          "createdAt": "2021-12-02T21:25:36Z",
          "updatedAt": "2021-12-02T21:25:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema is this pattern documented somewhere? If it's just happenstance I'm not sure it needs to be mentioned?",
          "createdAt": "2021-12-02T21:28:49Z",
          "updatedAt": "2021-12-02T21:28:49Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is mostly tradition. I don't believe it is documented, except maybe in email threads.",
          "createdAt": "2021-12-02T23:50:37Z",
          "updatedAt": "2021-12-02T23:50:37Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Then do we need to say something in the draft? This issue is as discoverable as those email threads :-)",
          "createdAt": "2021-12-02T23:55:57Z",
          "updatedAt": "2021-12-02T23:55:57Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "This change effects my implementation where a TLS thread is launched with static TP values in the server side when the first Initial is received.\r\n\r\nBut according to #72 and #73, Chosen Version is important. I'm getting accept this change.",
          "createdAt": "2021-12-03T00:22:58Z",
          "updatedAt": "2021-12-03T00:22:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on this conversation, it doesn't look like there are any changes needed to this draft. The fact that we're breaking a tradition does not need to be covered here since the tradition itself is not covered in RFC 9000. So I'm going to close this with no action. Please reopen/comment if you disagree.",
          "createdAt": "2022-03-07T22:09:19Z",
          "updatedAt": "2022-03-07T22:09:19Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDODoD7vc4_4FIT",
      "title": "A value of 0 in the transport parameter",
      "url": "https://github.com/quicwg/version-negotiation/issues/76",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Should an endpoint be required to reject a transport parameter that contains 0?",
      "createdAt": "2021-12-06T02:45:29Z",
      "updatedAt": "2022-03-07T23:14:50Z",
      "closedAt": "2022-03-07T23:14:50Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure.",
          "createdAt": "2021-12-06T23:58:29Z",
          "updatedAt": "2021-12-06T23:58:29Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "CC with `TRANSPORT_PARAMETER_ERROR`?",
          "createdAt": "2021-12-07T00:47:33Z",
          "updatedAt": "2021-12-07T00:47:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "That's what I currently have in my implementation :)",
          "createdAt": "2021-12-07T00:48:57Z",
          "updatedAt": "2021-12-07T00:48:57Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "Off topic but what if version 0 is included in Supported Version of a VN packet?",
          "createdAt": "2021-12-08T23:41:46Z",
          "updatedAt": "2021-12-08T23:41:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would make the VN packet malformed. I'd suggest either dropping such packets or ignoring the zero.",
          "createdAt": "2021-12-08T23:46:48Z",
          "updatedAt": "2021-12-08T23:46:48Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "OK. I modified my client to drop such packets as same as the case of the original version included.",
          "createdAt": "2021-12-09T01:48:49Z",
          "updatedAt": "2021-12-09T01:48:49Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I considered treating it as an error, but as it is an unauthenticated packet, it's better to drop it.  I've done the same for ours.",
          "createdAt": "2021-12-09T04:57:48Z",
          "updatedAt": "2021-12-09T04:57:48Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDODoD7vc4__yqT",
      "title": "Fix definition of \"compatible\"",
      "url": "https://github.com/quicwg/version-negotiation/issues/77",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 9 is pretty clear that 'compatible versions' might not have commonly usable 0-RTT packets. But Section 3 defines 'compatible' as a translatable first flight. 0-RTT is part of the first flight, so one of these definitions has to change.",
      "createdAt": "2021-12-07T19:24:59Z",
      "updatedAt": "2022-03-07T18:33:52Z",
      "closedAt": "2022-03-07T18:33:52Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That doesn't necessarily follow. You can translate a first flight in a way that 0-RTT is rejected and the 0-RTT packets are just dropped and the handshake will still succeed. I'm not sure I see an inconsistency here.",
          "createdAt": "2021-12-07T20:12:48Z",
          "updatedAt": "2021-12-07T20:12:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having read sec 3 a few times now, I see the subtlety in your point. 0-RTT could fall under the third paragraph as something that can't be included to be compatible.\r\n\r\nI still don't really like the definition. I'll think on it some more, but I'd prefer something like\r\n\"A is said to be 'compatible' with B if the first flight of A contains all the information minimally necessary to complete a first flight of B.\"\r\n\r\nSo to be compatible with v1 , v_x needs to contain a TLS 1.3 client hello including TPs for version negotiation and all the other required v1 TPs. For v1 to be compatible with v_x, v_x must not have any additional information to complete its first fligth besides the client hello at the v1 TPs.\r\n\r\nWhether or not there's 0-RTT in the flight doesn't matter.\r\n\r\nWe are drifting into the editorial, but if you like that definition I'm happy to write a PR.",
          "createdAt": "2021-12-08T00:01:41Z",
          "updatedAt": "2021-12-08T00:01:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure \"minimally necessary\" is well-defined. How about something like:\r\n\r\n> If A and B are two distinct versions of QUIC, A is said to be \"compatible\" with B if it is possible to take a first flight of packets from version A and convert it into a first flight of packets from version B. As an example, if versions A and B are absolutely equal in their wire image and behavior during the handshake but differ after the handshake, then A is compatible with B and B is compatible with A. Note that the conversion of the first flight can be lossy: some data such as QUICv1 0-RTT packets could be ignored during conversion and retransmitted later.",
          "createdAt": "2021-12-08T00:21:09Z",
          "updatedAt": "2021-12-08T00:21:09Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDODoD7vc5AAY8g",
      "title": "Refactor Retry and 0-RTT sections into a new \"Considerations for compatibility with QUICv1\" section",
      "url": "https://github.com/quicwg/version-negotiation/issues/78",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While discussing with @martinduke I realized that the draft tries to be pretty clear about what are invariant properties of QUIC and VN, and what is specific to QUICv1. The Sections on Retry and 0-RTT somewhat stick out there, because those are concepts that are specific to QUICv1 and don't exist in the QUIC invariants. To make this clearer, we should have one section that contains all of our Considerations for compatibility with QUICv1 - guidance for writing specifications that define compatibility with QUICv1, such as draft-ietf-quic-v2.",
      "createdAt": "2021-12-07T23:37:48Z",
      "updatedAt": "2022-03-07T23:28:33Z",
      "closedAt": "2022-03-07T23:28:33Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "I_kwDODoD7vc5BdHgR",
      "title": "What is the negotiated version during the handshake?",
      "url": "https://github.com/quicwg/version-negotiation/issues/79",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [editor's copy of the v2 draft](https://quicwg.org/quic-v2/draft-ietf-quic-v2.html#name-version-negotiation-conside) currently states:\r\n> Both endpoints MUST send Handshake or 1-RTT packets using the negotiated version. An endpoint MUST drop packets using any other version.\r\n\r\nLet's assume the following scenario:\r\n* the server supports both v1 and v2, and is configured to perform compatible negotiation from 1 to 2 when possible\r\n* client sends a QUIC v1 initial with \"Other Versions\" = (1, 2)\r\n* the server decides to switch to v2, and sends its initial ServerHello as v2, followed by a v2 handshake packet with the first half of the certificate - the transport parameters will follow in a later packet\r\n* when the client receives the v2 handshake packet, it technically doesn't yet know the \"negotiated version\" because it hasn't yet parsed the transport parameters\r\n\r\nConceptually, this sounds like a terminology issue with the VN draft: at that point in time the client does know that the server wants to use v2, because it's parsed a v2 ServerHello - but I think we need a name for that in the VN draft so that the v2 draft can refer to it for the MUST above.\r\n\r\ncc @martinduke @martinthomson -- the more I think about it the more I think that [MT's suggestion](https://github.com/quicwg/version-negotiation/pull/42#discussion_r630689250) to \"use instead of validate\" is making the spec and implementation writing a lot harder - the idea makes sense in theory, but in practice it complicates the handshake. Maybe we go back to something like \"the negotiated version is the one seen in long headers, and the Chosen Version in the TP exists to validate that it matches after the fact\"",
      "createdAt": "2022-01-10T17:05:44Z",
      "updatedAt": "2022-03-07T23:08:05Z",
      "closedAt": "2022-03-07T23:08:05Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": " I agree. Let's get the terminology right.",
          "createdAt": "2022-01-10T23:30:21Z",
          "updatedAt": "2022-01-10T23:30:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This WFM.\r\n\r\nFWIW, my implementation at the client uses long header packets to \"negotiate\" the version at the client; the transport parameters are used at the server.  Validation at the server is not necessary, but the validation based on a chosen version is right for the client.",
          "createdAt": "2022-01-11T00:37:56Z",
          "updatedAt": "2022-01-11T00:37:56Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My reading of the current editors' draft is that this is a no-op: AFAICT, the term \"negotiated version\" refers to whatever is the version field of the first server flight. If the editors agree, please close this issue.\r\n",
          "createdAt": "2022-03-07T22:11:51Z",
          "updatedAt": "2022-03-07T22:11:51Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDODoD7vc5BiP57",
      "title": "Differing levels of support for the standard",
      "url": "https://github.com/quicwg/version-negotiation/issues/80",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in https://github.com/quicwg/quic-v2/issues/25, there are various levels of partial support for this standard, different for client and server, and there ought to be normative language around these capabilities. There are certain modes that MUST be supported along with multiple versions, and others that are just performance improvements.\r\n\r\nAFAICT, for any server that supports >1 versions, there are two possible levels of support:\r\n1. Send the TP and support incompatible negotiation\r\n2. Support compatible negotiation\r\n\r\nFor a client, it's more complicated: @DavidSchinazi proposes:\r\n1. No support: do not the send nor parse the TP. If you get a VN packet, fail the QUIC connection\r\n2. Downgrade prevention only: send the TP with only one other version, also parse and validate the TP. If you get a VN packet, fail the QUIC connection. This protects against intermediaries that are rewriting the version field on Initial packets. In v1/v2, these attacks will be detected by the authenticated version field in subsequent handshake packets, but that is not generalizable to all versions of QUIC.\r\n3. Compatible only: downgrade prevention and be prepared to accept an upgrade\r\n4. Incompatible only: advertise only one version, so there's downgrade prevention when trying again with new version after a VN packet.\r\n5. Full: downgrade prevention, compatible VN and incompatible VN\r\n",
      "createdAt": "2022-01-11T18:33:28Z",
      "updatedAt": "2022-03-07T19:55:02Z",
      "closedAt": "2022-03-07T19:55:02Z",
      "comments": []
    },
    {
      "number": 81,
      "id": "I_kwDODoD7vc5DzX9w",
      "title": "Don't assume a single protocol",
      "url": "https://github.com/quicwg/version-negotiation/issues/81",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The document currently says:\r\n\r\n> When a client creates a QUIC connection, its goal is to use an application layer protocol. Therefore, when considering which versions are compatible, clients will only consider versions that support the intended application layer protocol.\r\n\r\nHowever, as we see with HTTP over TCP, clients routinely offer \"h2\", \"http/1.1\" and are content with either selection.  Particularly if ALPN tokens map 1:1 to QUIC versions as specified in H3, the client's goal might be to use any of a collection of application-layer protocols.\r\n\r\nPerhaps tweak this to \"...support one of the intended application layer protocols.\"?  The first statement might or might not need to be expanded as well.",
      "createdAt": "2022-02-14T16:24:24Z",
      "updatedAt": "2022-03-07T22:06:05Z",
      "closedAt": "2022-03-07T22:06:05Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps we add a sentence after the ones you quoted along the lines of \"For example, if the client's first flight advertises multiple ALPN tokens and multiple compatible versions, the server needs to ensure that the ALPN token that it selects can run over the QUIC version that it selects.\"",
          "createdAt": "2022-02-14T16:40:44Z",
          "updatedAt": "2022-02-14T16:40:44Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "I_kwDODoD7vc5FQ8B7",
      "title": "What does \"compatible\" VN mean",
      "url": "https://github.com/quicwg/version-negotiation/issues/90",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ekr"
      ],
      "labels": [],
      "body": "Consider the case where the client and server both support v1 and v2 and prefer v2.\r\n\r\nIn the current draft, if the client puts v1 in the long header and the server responds with v2, that's called \"compatible version negotiation\". OTOH, if the client puts v2 in the long header and the server responds with v2, that's called, well, I'm not quite sure what. I guess not negotiation?\r\n\r\nI think a better way to think about this is that the client is sending an Initial that is compatible with both versions and so both of these cases are compatible version negotiation.\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2022-03-08T00:10:01Z",
      "updatedAt": "2022-04-05T18:39:34Z",
      "closedAt": "2022-04-05T18:39:34Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the scenario where the client starts with v2 and the server responds with v2, I think of that as just \"creating a v2 connection\" without compatible version negotiation involved. Let's discuss this with the WG at IETF 113.",
          "createdAt": "2022-03-08T00:31:00Z",
          "updatedAt": "2022-03-08T00:31:00Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "I_kwDODoD7vc5GIEan",
      "title": "Note that when you do incompatible VN you need to reset ALPN, etc.",
      "url": "https://github.com/quicwg/version-negotiation/issues/91",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The point is that your ALPN offer when you offer QUICvX shouldn't be dependent on if you did VN or not.",
      "createdAt": "2022-03-22T09:41:27Z",
      "updatedAt": "2022-03-22T09:47:39Z",
      "closedAt": "2022-03-22T09:47:39Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging into #92 ",
          "createdAt": "2022-03-22T09:47:39Z",
          "updatedAt": "2022-03-22T09:47:39Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDODoD7vc5GIEk5",
      "title": "Recommendations for ALPN",
      "url": "https://github.com/quicwg/version-negotiation/issues/92",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Can an ALPN label be used for multiple QUIC versions?\r\n\r\nI think that the text should say something like:\r\n\r\n> If the QUIC version uses ALPN, then an application protocol can use the same ALPN label for multiple QUIC versions iff:\r\n> * the version of QUIC for which the ALPN was originally defined supports compatible version negotiation to any other QUIC version (this avoids performance issues)\r\n> * the version of QUIC that is negotiated supports at least the features that the application depends on from the original QUIC version (e.g., if it uses streams, the new version has streams too)\r\n> \r\n> It might be possible to share an ALPN across multiple versions with some added cleverness, but these are what we believe to be safe.\r\n\r\n@ekr adds (and I wholly agree):\r\n\r\n> Any application negotiation needs to be started over entirely when you do an incompatible version negotiation.",
      "createdAt": "2022-03-22T09:42:02Z",
      "updatedAt": "2022-04-05T17:58:25Z",
      "closedAt": "2022-04-05T17:58:25Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm merging #91 into this one where @ekr said \"The point is that your ALPN offer when you offer QUICvX shouldn't be dependent on if you did VN or not.\"",
          "createdAt": "2022-03-22T09:47:29Z",
          "updatedAt": "2022-03-22T09:47:29Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDODoD7vc5GUOds",
      "title": "Compatible Versions Section editorial",
      "url": "https://github.com/quicwg/version-negotiation/issues/93",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [
        "DavidSchinazi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "This is a very important section, but I found it to be a little muddy.\r\n\r\nIn particular, the directionality of the phrase A is compatible with B was unclear.  An example would help here, I think.",
      "createdAt": "2022-03-24T15:51:14Z",
      "updatedAt": "2022-04-05T18:19:58Z",
      "closedAt": "2022-04-05T18:19:58Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "I_kwDODoD7vc5GUO4K",
      "title": "Original version in compatible negotiation",
      "url": "https://github.com/quicwg/version-negotiation/issues/94",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [
        "ekr"
      ],
      "labels": [],
      "body": "> The server MUST NOT reply with a version that is not present in the client's compatible versions, unless it is the original version.\r\n\r\nOriginal version was defined as the version a client attempts prior to a VN packet.  If there is a VN packet, I think that it is still possible to do a compatible upgrade from the version in the client's second attempt.  In that case, \"original version\" isn't the right term to use when talking about compatible upgrades.",
      "createdAt": "2022-03-24T15:52:36Z",
      "updatedAt": "2022-04-05T18:39:34Z",
      "closedAt": "2022-04-05T18:39:34Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can sidestep this particular issue by removing the \"unless...\" clause. That clause isn't helping because the client's chosen version MUST already be present in the compatible versions list.\r\n\r\nHowever, this issue raises a good point: it's possible for incompatible VN to happen and then be followed by compatible VN. We should clarify that this is allowed, and clearly define what the \"original version\" is in that scenario.",
          "createdAt": "2022-04-05T17:23:41Z",
          "updatedAt": "2022-04-05T17:23:41Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDODoD7vc5GUPuD",
      "title": "Is incompatible VN one or two connections?",
      "url": "https://github.com/quicwg/version-negotiation/issues/95",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [
        "DavidSchinazi"
      ],
      "labels": [],
      "body": "I am not sure that I agree with this as some state carries across from the first connection attempt to the second (and hopefully successfully completed) connection.\r\n\r\n(Also, I've implemented this within the same connection object.  I know that other implementations differ here, so what I'm looking for is a little finesse in how this is framed.)",
      "createdAt": "2022-03-24T15:55:23Z",
      "updatedAt": "2022-04-05T18:36:40Z",
      "closedAt": "2022-04-05T18:36:40Z",
      "comments": []
    },
    {
      "number": 96,
      "id": "I_kwDODoD7vc5GUQYg",
      "title": "Choosing the original version",
      "url": "https://github.com/quicwg/version-negotiation/issues/96",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [
        "DavidSchinazi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Section 2.5 says unconditionally that the client chooses the most compatible version.\r\n\r\nThis isn't right, because the most compatible version isn't what it is looking to end up on.  What the client should choose is probably the most compatible version of those that are compatible (directionality ?) with its most preferred version.",
      "createdAt": "2022-03-24T15:57:28Z",
      "updatedAt": "2022-04-05T18:34:54Z",
      "closedAt": "2022-04-05T18:34:54Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rereading this, I think the directionality is correct in the existing text. But perhaps we could figure out better wording.",
          "createdAt": "2022-04-05T17:29:41Z",
          "updatedAt": "2022-04-05T17:29:41Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "I_kwDODoD7vc5GURkY",
      "title": "Don't restate requirements",
      "url": "https://github.com/quicwg/version-negotiation/issues/97",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In Section 4:\r\n\r\n> Clients MUST ignore any received Version Negotiation packets that contain the version that they initially attempted. \r\n\r\nLater\r\n\r\n> Clients MUST ignore any received Version Negotiation packets that contain the version that they initially attempted.\r\n",
      "createdAt": "2022-03-24T16:01:25Z",
      "updatedAt": "2022-04-05T17:15:29Z",
      "closedAt": "2022-04-05T17:15:29Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Already fixed by 63fdeba6e6a7306381779f930d2dc801989e4fcf",
          "createdAt": "2022-04-05T17:15:29Z",
          "updatedAt": "2022-04-05T17:15:29Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "I_kwDODoD7vc5GUSFL",
      "title": "Not a PR because it's late",
      "url": "https://github.com/quicwg/version-negotiation/issues/98",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> For example, that could be accomplished by having the server send a Retry packet in the original version first and therefore validating the client's IP address before attempting compatible version negotiation. \r\n\r\ns/and therefore/, thereby/",
      "createdAt": "2022-03-24T16:03:12Z",
      "updatedAt": "2022-04-05T17:12:15Z",
      "closedAt": "2022-04-05T17:12:15Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "> New versions that also use TLS 1.3 SHOULD mandate that their session tickets are rightly scoped to one version of QUIC; i.e., require that clients not use them across version and that servers validate this client requirement.\r\n\r\ns/rightly/tightly\r\n\r\ns/across version/across multiple versions",
          "createdAt": "2022-03-24T16:04:11Z",
          "updatedAt": "2022-03-24T16:04:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "> Alternatively, that document could specify that compatible version negotiation causes 0-RTT data to be rejected by the server.\r\n\r\ns/Alternatively, t/T/",
          "createdAt": "2022-03-24T16:04:53Z",
          "updatedAt": "2022-03-24T16:04:53Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDODoD7vc5M2K0U",
      "title": "[INV] -> [QUIC-INVARIANTS]",
      "url": "https://github.com/quicwg/version-negotiation/issues/111",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "editorial nit: for consitency with RFC 9000, consider changing you reference name from [INV] -> [QUIC-INVARIANTS]",
      "createdAt": "2022-06-29T20:28:37Z",
      "updatedAt": "2022-07-11T16:24:28Z",
      "closedAt": "2022-07-11T16:24:28Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDODoD7vc5NuoaR",
      "title": "The scenario of Figure 1",
      "url": "https://github.com/quicwg/version-negotiation/issues/114",
      "state": "CLOSED",
      "author": "kazu-yamamoto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm confused with the scenario of Figure 1:\r\n\r\n```\r\nClient                                          Server\r\n\r\n   Chosen = A, Other Versions = (A, B) ----------------->\r\n   <------------------------ Version Negotiation = (D, C)\r\n\r\n   Chosen = C, Other Versions = (C, D) ----------------->\r\n   <----------------- Chosen = D, Other Versions = (D, C)\r\n```\r\n\r\nThe client chose C from VN.\r\n\r\nWhen Other Versions is validated, the rule is:\r\n\r\n> The Other\r\n> Versions field is validated by confirming that the client would have\r\n> attempted the same version with knowledge of the versions the server\r\n> supports.  That is, the client would have selected the same version\r\n> if it received a Version Negotiation packet that listed the versions\r\n> in the server's Other Versions field, plus the negotiated version.\r\n\r\nSo, this validation fails since the client would choose C.",
      "createdAt": "2022-07-14T00:18:07Z",
      "updatedAt": "2022-07-14T23:10:44Z",
      "closedAt": "2022-07-14T23:10:44Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In both cases, the client chose C. Attempted means \"chose\", not \"negotiated\".",
          "createdAt": "2022-07-14T00:28:19Z",
          "updatedAt": "2022-07-14T00:28:19Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "OK. So, the client checks the followings to prevent downgrade attack, right?\r\n\r\n- Check Other Versions so that the virtual second choice is the same as the first choice. (C in this case).\r\n- Check if Chosen is the same as the negotiated version after handshake. (D in this case).",
          "createdAt": "2022-07-14T00:56:04Z",
          "updatedAt": "2022-07-14T00:56:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's correct",
          "createdAt": "2022-07-14T16:50:24Z",
          "updatedAt": "2022-07-14T16:50:24Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "Thanks. Now it's clear to me.",
          "createdAt": "2022-07-14T23:10:44Z",
          "updatedAt": "2022-07-14T23:10:44Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDODoD7vc5QaSGb",
      "title": "AD Review : Should this specification add a update tag? ",
      "url": "https://github.com/quicwg/version-negotiation/issues/115",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to have a discussion to determine whether this specification should update RFC9000 or not.\r\n\r\nThis version negotiation draft adds new functionality on top of RFC9000 using the version negotiation packet from RFC8999. The update tag might be seen as useful to let other aware of the added mechanism for version negotiation, also because it actually changes how section 6 of RFC9000 deals with QUIC versions, which mentions potential future work regarding the negotiation. On the other hand, this new mechanism is not really a must to implement to make things works for RFC9000and both mechanism can co-exists, hence falls into QUIC extension categories. It seems all about how we want the future QUIC versions to get deployed.\r\n\r\nI have checked with WG chairs and authors that we didn't really discussed this in the working group. I think having a discussion now would be useful to know where the WG stands on this and have an response ready for potential questions (from reviews) along the path of publication. ",
      "createdAt": "2022-08-24T08:29:35Z",
      "updatedAt": "2022-09-27T18:09:43Z",
      "closedAt": "2022-09-27T18:09:43Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Speaking in capacity as individual and chair:\r\n\r\nI still find the commentary on use of the Updates tags in https://datatracker.ietf.org/doc/html/draft-kuehlewind-update-tag-04 compelling. If I dare to summarise, the Updates tag is used inconsistently across the IETF. Any use of it is ambiguous and open to interpretation. I'd encourage people to familiarise themselves with some of the background and wider discussion, in order to avoid playing all of it out here.\r\n\r\nTrying to document or describe how the QUIC WG treats use of Updates is probably a futile activity, since its unlikely to be found by the target audience. Adding an Updates tag risks confusing people just as much as it might help some people. \r\n\r\nAbsent a strong reason to provide an Updates tag, I don't think we should. And I don't class subjective opinions as a strong reason on their own.",
          "createdAt": "2022-08-24T11:33:44Z",
          "updatedAt": "2022-08-24T11:33:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I largely agree with Lucas, but I think that the change in behaviour with respect to Version Negotiation is significant enough to warrant an Updates tag in this case.  \r\n\r\nI generally subscribe to the view that Amends is the only useful application of Updates, but this clearly fits into that interpretation.  (It is also an instance of Extends, but I don't care about that.)  I can see how you might argue that this new document only applies to people implementing versions of QUIC *other than* version 1, but that seems too much like sophistry.  On balance though, given the importance of this feature, I think that a strong pointer is useful in this case.\r\n",
          "createdAt": "2022-08-24T21:57:27Z",
          "updatedAt": "2022-08-24T21:57:27Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do not care whether this has an Update tag or not, because it has no impact whatsoever on implementations. I'll follow the WG consensus on this.",
          "createdAt": "2022-09-09T03:40:57Z",
          "updatedAt": "2022-09-09T03:40:57Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "yes, getting the WG consensus is the target here. May be the chairs (@LPardue, @mjoras ) should explicitly ping the WG about it now. ",
          "createdAt": "2022-09-09T08:55:28Z",
          "updatedAt": "2022-09-09T08:55:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Lucas and Martin. \"RFC X updates RFC Y\" has been used with a lot of different meanings, such as:\r\n\r\n* RFC X defines version N+1 of the EXAMPLE protocol, whose version N is defined in RFC Y\r\n* RFC X reflects IETF consensus to change some parts of the specification of the EXAMPLE protocol defined in RFC Y\r\n* RFC X specifies extensions to the EXAMPLE protocol using the extension mechanisms defined in RFC Y\r\n\r\nIn my mid, the first case should be noted as \"obsoletes\", as in RFC 8446 (TPS 1.3) obsoletes RFC 5246 (TLS 1.2). The second case is properly noted as \"updates\". The third case does neither update not obsolete. This is certainly the interpretation that the WG has used so far: neither RFC 9287, greasing the Q bit, nor RFC9221, datagram frames, are marked as updating RFC 9000. The compatible version negotiation should also not be stated as updating RFC 9000.\r\n\r\nIn any case, if the compatible version negotiation updates something, it is not RFC 9000 but RFC 8999, the QUIC invariants, which defines the basic version negotiation.",
          "createdAt": "2022-09-12T03:59:19Z",
          "updatedAt": "2022-09-12T03:59:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Agreed with @huitema that this doesn't sound like an update to RFC 9000. The only reference to QUICv1 ([Special Handling for QUIC Version 1](https://quicwg.org/version-negotiation/draft-ietf-quic-version-negotiation.html#name-special-handling-for-quic-v)) doesn't require any updates to implementations of RFC 9000, just handling for newer versions.\r\n\r\nI could see an argument for marking it as an Update to RFC 8999, but I'm ambivalent about that.",
          "createdAt": "2022-09-22T02:40:51Z",
          "updatedAt": "2022-09-22T02:40:51Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I vote yes for the update: we want implementors of RFC 9000 to be aware of this later doc, even if they don't strictly need to be, and it seems to be within the scope of existing uses.",
          "createdAt": "2022-09-23T23:03:18Z",
          "updatedAt": "2022-09-23T23:03:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "chair hat off: I am coming around to the idea that this doc **should not** update RFC 9000 and **might** update RFC 8999 (specifically because of https://www.rfc-editor.org/rfc/rfc8999.html#name-version-negotiation). \r\n\r\nWhether we **do** add an updates tag is borderline. Adding a tag doesn't hurt either this draft or 8999, the confusion risk I mentioned earlier does not seem high after hearing others views. It might improve discoverability but I'm skeptical of the efficacy discovery via tags in practice; a link with no context seems like a pretty lame hint. I'd rather us have more detailed and expressive ways to communicate with implementers the \"why\" and broader context about things that they should consider - for example, adding resources on quicwg.org and the interop runner that nudge people to \"Do the best thing\". An updates tag doesn't prevent that though, so all good.\r\n\r\nFinally, adding an updates tag here risks us having to ask the question every time. I'm encouraged by the discussion here that we can logically reason why something like Datagram extension doesn't `updates` while version negotiation does. \r\n\r\nIn summary, as an individual, I'm seeing what appears to be ambivalence to `updates` RFC 8999 but no objections",
          "createdAt": "2022-09-24T00:29:54Z",
          "updatedAt": "2022-09-24T00:29:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "QUIC WG chairs have [declared consensus](https://mailarchive.ietf.org/arch/msg/quic/sjOa4B1ALq0AfsXyAs9HGZvFepM/) to update 8999 but not 9000. I've written this up as PR #124.",
          "createdAt": "2022-09-26T19:57:51Z",
          "updatedAt": "2022-09-26T19:57:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Let's merge the PR and cut a new release for Zahed to progress",
          "createdAt": "2022-09-26T21:03:27Z",
          "updatedAt": "2022-09-26T21:03:27Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDODoD7vc5QaUXr",
      "title": "AD Review : some minor editorial comments",
      "url": "https://github.com/quicwg/version-negotiation/issues/116",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Instead of creating separate issues for each minor editorial comments I will put them all in this issue -\r\n\r\n1. I am not a fan of having normative language in the definitions. I feel those normative languages are out of context and hard to reason. It is the case for MSL definition. I would suggest that besides definition, we have some description where MSL is used and put the recommended value there.\r\n2. What is the difference between the initial version and original version ? if there is none why do we need to use two different call sign for the same thing?\r\n3. What is Tubes? we need to explain it. otherwise use other example.\r\n",
      "createdAt": "2022-08-24T08:37:17Z",
      "updatedAt": "2022-09-13T19:58:32Z",
      "closedAt": "2022-09-13T19:58:32Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 1. I am not a fan of having normative language in the definitions. I feel those normative languages are out of context and hard to reason. It is the case for MSL definition. I would suggest that besides definition, we have some description where MSL is used and put the recommended value there.\r\n\r\nI personally disagree. Mentioning the recommended value when defining the term makes it easier to understand and implement.\r\n\r\n> 2. What is the difference between the initial version and original version ? if there is none why do we need to use two different call sign for the same thing?\r\n\r\nAgreed, there was only one mention of \"initial version\" so I replaced that with original in #120\r\n\r\n> 3. What is Tubes? we need to explain it. otherwise use other example.\r\n\r\nIt's a hypothetical example. That doesn't make it unhelpful.\r\n",
          "createdAt": "2022-09-09T03:26:03Z",
          "updatedAt": "2022-09-09T03:26:03Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "> > 1. I am not a fan of having normative language in the definitions. I feel those normative languages are out of context and hard to reason. It is the case for MSL definition. I would suggest that besides definition, we have some description where MSL is used and put the recommended value there.\r\n> \r\n> I personally disagree. Mentioning the recommended value when defining the term makes it easier to understand and implement.\r\n> \r\nI think it is important to describe the reasoning behind the recommendation, specially when we are coining the term. This is now lacking the description and terminology section might not the best place to describe it. I don't have a super strong opinion here, but I think describing it better would help.\r\n> > 2. What is the difference between the initial version and original version ? if there is none why do we need to use two different call sign for the same thing?\r\n> \r\n> Agreed, there was only one mention of \"initial version\" so I replaced that with original in #120\r\n> \r\n> > 3. What is Tubes? we need to explain it. otherwise use other example.\r\n> \r\n> It's a hypothetical example. That doesn't make it unhelpful.\r\n\r\n:-) hmm, the example makes little sense if one does not understand the terms used in the example. If \"Tube\" is a hypothetical term here, then let's just mention that.\r\n\r\n",
          "createdAt": "2022-09-09T08:36:16Z",
          "updatedAt": "2022-09-09T08:36:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think it is important to describe the reasoning behind the recommendation, specially when we are coining the term. This is now lacking the description and terminology section might not the best place to describe it. I don't have a super strong opinion here, but I think describing it better would help.\r\n\r\nThere was no reasoning, this was pulled out of a hat just like the original MSL from RFC 793. Can you send us a PR describing the reasoning you'd like to see added?\r\n\r\n> :-) hmm, the example makes little sense if one does not understand the terms used in the example. If \"Tube\" is a hypothetical term here, then let's just mention that.\r\n\r\nFair enough, I've added the word \"hypothetical\" to PR #120",
          "createdAt": "2022-09-10T00:48:16Z",
          "updatedAt": "2022-09-10T00:48:16Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDODoD7vc5QaVrB",
      "title": "AD review: lack of normative language",
      "url": "https://github.com/quicwg/version-negotiation/issues/117",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/quicwg/version-negotiation/blob/e193e1264887ffab5919d529ea21c0023989c1ec/draft-ietf-quic-version-negotiation.md?plain=1#L153\r\n\r\nhere, it feel lacking normative language. The current text gives feel like there are other options the client can do and these are examples. if that is true what are those other options? if the client behave differently than described here as there is no normative language will that not cause interoperability issues?",
      "createdAt": "2022-08-24T08:41:43Z",
      "updatedAt": "2022-09-13T19:59:00Z",
      "closedAt": "2022-09-13T19:59:00Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The normative language already exists in [Section 6.2 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#section-6.2). That said, the QUIC-VN draft is written in terms of QUIC invariants so we should tweak this.",
          "createdAt": "2022-09-09T03:29:03Z",
          "updatedAt": "2022-09-09T03:29:03Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "we should or we should not? ",
          "createdAt": "2022-09-09T08:29:56Z",
          "updatedAt": "2022-09-09T08:29:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should",
          "createdAt": "2022-09-10T00:43:21Z",
          "updatedAt": "2022-09-10T00:43:21Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#121 takes care of this",
          "createdAt": "2022-09-10T00:56:00Z",
          "updatedAt": "2022-09-10T00:56:00Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDODoD7vc5QaW8T",
      "title": "AD review : unclear reference to \"first flight\"",
      "url": "https://github.com/quicwg/version-negotiation/issues/118",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/quicwg/version-negotiation/blob/e193e1264887ffab5919d529ea21c0023989c1ec/draft-ietf-quic-version-negotiation.md?plain=1#L249\r\n\r\nhere it is not clear to me if we are talking about first flight or converted first flight. I am assuming the negotiated version is in the converted first flight. May be we can be more clear here.",
      "createdAt": "2022-08-24T08:45:53Z",
      "updatedAt": "2022-09-14T21:57:00Z",
      "closedAt": "2022-09-14T21:56:59Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "In this particular case, it probably doesn't matter.  I don't know if it would be possible to convert a flight so that it had a different address tuple.  I guess maybe you could, so I would say that this applies to the converted flight.\r\n\r\nBTW, @zaheduzzaman, I really appreciate the quoting of text, but when you quote the text, you can select a range of lines, which might be useful here.  Click the first/last line, then hold shift and click the last/first line.",
          "createdAt": "2022-08-25T02:32:34Z",
          "updatedAt": "2022-08-25T02:32:34Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "Ok then probably best to clear about this int he spec.\r\n\r\nby the way, thanks for the tip @martinthomson ",
          "createdAt": "2022-08-26T09:57:13Z",
          "updatedAt": "2022-08-26T09:57:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sorry, what is unclear here?",
          "createdAt": "2022-09-09T03:45:06Z",
          "updatedAt": "2022-09-09T03:45:06Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi the inclusion of \"including the first flight\" in the last sentence is confusing. it says -\r\n\r\n\"For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake, including the first flight.\"\r\n\r\nActually now I think the whole thing is very hard to parse. what does it mean? So, the negotiated version comes second and how does the first flight comply with that? should it not be the case that if the first flight requires the 5-tuple to be stable the negotiated version must comply with that?\r\n\r\nor does it mean when the client receives the negotiated version it should not change the 5-tuple? I think this is what we want but that is not clear from the example text or entire paragraph.\r\n\r\nas MT, mentioned it might be possible to convert the flight to different address tuple. If we don't want that then we need to change this text - \" The entire handshake (including the converted first flight) needs to conform to the rules of the negotiated version\" to include normative MUST.",
          "createdAt": "2022-09-09T08:29:02Z",
          "updatedAt": "2022-09-09T08:29:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @DavidSchinazi the inclusion of \"including the first flight\" in the last sentence is confusing. it says -\r\n> \r\n> \"For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake, including the first flight.\"\r\n> \r\n> Actually now I think the whole thing is very hard to parse. what does it mean? So, the negotiated version comes second and how does the first flight comply with that? should it not be the case that if the first flight requires the 5-tuple to be stable the negotiated version must comply with that?\r\n\r\nAll this says is \"any requirements from the negotiated version also apply to the first flight\". So if the negotiated version required the addresses to be stable, if it detects that they changed then it fails the handshake.\r\n\r\n> or does it mean when the client receives the negotiated version it should not change the 5-tuple? I think this is what we want but that is not clear from the example text or entire paragraph.\r\n\r\nThat's just a way of saying \"follow the spec of the versions in use\". I don't think that's needed.\r\n\r\n> as MT, mentioned it might be possible to convert the flight to different address tuple. If we don't want that then we need to change this text - \" The entire handshake (including the converted first flight) needs to conform to the rules of the negotiated version\" to include normative MUST.\r\n\r\nI'm fine with a future document defining conversion such that it changes the address tuple. There's no need to prevent that.\r\n\r\nPerhaps you could propose text that you find clearer?",
          "createdAt": "2022-09-09T17:28:10Z",
          "updatedAt": "2022-09-09T17:28:10Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "> > @DavidSchinazi the inclusion of \"including the first flight\" in the last sentence is confusing. it says -\r\n> > \"For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake, including the first flight.\"\r\n> > Actually now I think the whole thing is very hard to parse. what does it mean? So, the negotiated version comes second and how does the first flight comply with that? should it not be the case that if the first flight requires the 5-tuple to be stable the negotiated version must comply with that?\r\n> \r\n> All this says is \"any requirements from the negotiated version also apply to the first flight\". So if the negotiated version required the addresses to be stable, if it detects that they changed then it fails the handshake.\r\n> \r\n> > or does it mean when the client receives the negotiated version it should not change the 5-tuple? I think this is what we want but that is not clear from the example text or entire paragraph.\r\n> \r\n> That's just a way of saying \"follow the spec of the versions in use\". I don't think that's needed.\r\n> \r\n> > as MT, mentioned it might be possible to convert the flight to different address tuple. If we don't want that then we need to change this text - \" The entire handshake (including the converted first flight) needs to conform to the rules of the negotiated version\" to include normative MUST.\r\n> \r\n> I'm fine with a future document defining conversion such that it changes the address tuple. There's no need to prevent that.\r\n> \r\n> Perhaps you could propose text that you find clearer?\r\n\r\nI would simple suggest to make it clear in this document and rewrite - \r\n\r\n> The entire handshake (including the converted first flight) **MUST** to conform to the rules of the negotiated version.\r\n\r\nAlso I would suggest to change the example to reflect what you said here -\r\n\r\n> \"For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake, otherwise if fails the handshake.\"\r\n\r\n    \r\n\r\n",
          "createdAt": "2022-09-14T08:37:47Z",
          "updatedAt": "2022-09-14T08:37:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I would simple suggest to make it clear in this document and rewrite -\r\n> \r\n> > The entire handshake (including the converted first flight) **MUST** to conform to the rules of the negotiated version.\r\n\r\nThis is unclear, who does this normative requirement apply to?\r\n\r\n> Also I would suggest to change the example to reflect what you said here -\r\n> \r\n> > \"For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake, otherwise if fails the handshake.\"\r\n\r\nWho is \"it\" in \"it fails the handshake\"?\r\n\r\nAt this point, it's sounding like this issue is editorial about how best to phrase one paragraph. I propose we don't block IESG review on this editorial work.",
          "createdAt": "2022-09-14T19:18:38Z",
          "updatedAt": "2022-09-14T19:18:38Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "> > I would simple suggest to make it clear in this document and rewrite -\r\n> > > The entire handshake (including the converted first flight) **MUST** to conform to the rules of the negotiated version.\r\n> \r\n> This is unclear, who does this normative requirement apply to?\r\n\r\nThe draft says -\r\n\r\n>The entire handshake (including the converted first flight) needs to conform to the rules of the negotiated version.\r\n\r\nit seems like it is then unclear who does this \"needs\" apply to? Then we have problem.\r\n\r\n> \r\n> > Also I would suggest to change the example to reflect what you said here -\r\n> > > \"For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake, otherwise if fails the handshake.\"\r\n> \r\n> Who is \"it\" in \"it fails the handshake\"?\r\n\r\nthe \"it\" is I suppose same as in your previous reply :-)\r\n>  All this says is \"any requirements from the negotiated version also apply to the first flight\". So if the negotiated version required the addresses to be stable, if it detects that they changed then it fails the handshake.\r\n> \r\n> At this point, it's sounding like this issue is editorial about how best to phrase one paragraph. I propose we don't block IESG review on this editorial work.\r\n\r\nit is editorial yes, but I am assuming if what is written is not clear to me I think it won't clear to others as well. Hence, I think it is worth clarifying. And I don't think this will block any longer than the consensus call we have now on update tag if we work on to improve the text. \r\n\r\nMay be we should just say\r\n\r\n> For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then this applies to the entire handshake.\r\n\r\ndo we lose big if we drop the \"including the first flight\" part?\r\n\r\n",
          "createdAt": "2022-09-14T20:50:00Z",
          "updatedAt": "2022-09-14T20:50:00Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about this:\r\n\r\n> Note that, after the first flight is converted to the negotiated version, the handshake completes in the negotiated version. If the negotiated version has requirements that apply during the handshake, those requirements apply to the entire handshake, including the converted first flight. In particular, if the negotiated version mandates that endpoints perform validations on handshake packets, endpoints MUST also perform such validations on the converted first flight. For instance, if the negotiated version requires that the 5-tuple remain stable for the entire handshake (as QUIC version 1 does), then both endpoints need to validate the 5-tuple of all handshake packets, including the converted first flight.",
          "createdAt": "2022-09-14T21:03:50Z",
          "updatedAt": "2022-09-14T21:03:50Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "This is much better, specially clear about the converted first flight. Thanks",
          "createdAt": "2022-09-14T21:32:15Z",
          "updatedAt": "2022-09-14T21:32:15Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDODoD7vc5QaZDM",
      "title": "AD review : When does the negotiation end?",
      "url": "https://github.com/quicwg/version-negotiation/issues/119",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/quicwg/version-negotiation/blob/e193e1264887ffab5919d529ea21c0023989c1ec/draft-ietf-quic-version-negotiation.md?plain=1#L275\r\n\r\nin this example, it would be very stupid of the client to select version C and start another negotiation after the sever has indicated D is what it prefers. The server can again select D as preferred and there exits a potential loop. However, it is possible. What are the rule we have in the specification that stops this kind of loop?  ",
      "createdAt": "2022-08-24T08:52:45Z",
      "updatedAt": "2022-09-14T22:04:19Z",
      "closedAt": "2022-09-14T22:04:19Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure that I understand this question.  A client makes a choice about what version to attempt (and offer) when it creates a connection.  It might learn that its versions are incompatible with a server (with a Version Negotiation packet) and try again, but that retry would be a separate action.  But if the connection is successfully established, the negotiation is done.",
          "createdAt": "2022-08-25T02:28:39Z",
          "updatedAt": "2022-08-25T02:28:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is at most one round of incompatible VN followed by one connection that may or may not use compatible VN to switch versions again. There is no potential for a loop here. @zaheduzzaman can you clarify what you meant?",
          "createdAt": "2022-09-09T03:43:02Z",
          "updatedAt": "2022-09-09T03:43:02Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "The scenario i was thinking is a follows -\r\n\r\nChosen = A, Other Versions = (A, B) ----------------->\r\n<----------------- Chosen = D, Other Versions = (D, C)\r\n\r\nChosen = C, Other Versions = (C,D) ----------------->\r\n<----------------- Chosen = D, Other Versions = (D,C)\r\n\r\nChosen = C, Other Versions = (C,D) ----------------->\r\n<----------------- Chosen = D, Other Versions = (D,C)\r\n\r\n.....\r\n\r\nis this prohibited by this specification ? can you show me the description?\r\n\r\n\r\nalso, \r\n\r\nis the following interaction by the client and server possible? \r\n\r\nChosen = A, Other Versions = (A, B) ----------------->\r\n<----------------- Chosen = D, Other Versions = (D, C)\r\n\r\nChosen = E, Other Versions = (E,F) ----------------->\r\n<----------------- Chosen = G, Other Versions = (G,H)\r\n\r\n........\r\n\r\nthe draft only says the client's first flight contain This contains the list of versions that the client knows its first flight is compatible with (A,B). It does not force the client to list ALL the compatible versions, so it might not list all the compatible versions. I think, there is also no requirement on the server to list ALL the compatible versions.  Now server sends back another list of compatible versions (D,C).  This new list triggers the client to realise it knows about versions that are compatible (E,F), and sends it back to the client as it has not interest in D or C. That trigger the server to reply with new list of compatible version (G,H).. and this goes on. \r\n\r\nIt is also possible that client made a mistake  by not listing all the compatible version (well it does not have to) and as it is not interested in D or C, it wants to list (E,F) and keep in negotiating.\r\n\r\nI would like to understand the with current specification this kind of interaction is not possible and the negotiation should not  go on like that. ",
          "createdAt": "2022-09-09T08:13:22Z",
          "updatedAt": "2022-09-09T08:13:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The scenarios you describe aren't allowed: if the server performs compatible version negotiation it MUST select a ` Chosen Version` that was included in the client's `Other Versions`:\r\n\r\n> When the server can parse the client's first flight using the client's chosen version, it can extract the client's Version Information structure (see [Section 3](https://quicwg.org/version-negotiation/draft-ietf-quic-version-negotiation.html#vers-info)). This contains the list of versions that the client knows its first flight is compatible with.\r\n> In order to perform compatible version negotiation, the server MUST select one of these versions that (1) it supports and (2) it knows the client's chosen version to be compatible with. This selected version is now the negotiated version.",
          "createdAt": "2022-09-10T00:42:37Z",
          "updatedAt": "2022-09-10T00:42:37Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "> The scenarios you describe aren't allowed: if the server performs compatible version negotiation it MUST select a ` Chosen Version` that was included in the client's `Other Versions`:\r\n\r\nyes, but servers are allowed to do incompatible version negotiation. \r\n\r\nin my 1st scenario, the server initiates incompatible version negotiation, the server selects D instead of C as chosen by client. The expectation here is that D will be the final negotiated version, and the version negotiation will end. But is there anything stopping the client to try to enforce it's chosen one (C) again? shall we have some to avoid this case?\r\n\r\nin the 2nd scenario, it is not possible if A, B, C,D, E,F all are compatible. if the server starts incompatible version negotiation with (C,D) and client does not find any supported version, it aborts the connection. I just realized - **there is no normative text for aborting the connection attempt.**. As the server expresses all the versions it support in the supported versions list, the client knows there is not point on continuing with another attempt with (E,F). Unless I am mistaken there is nothing now prohibiting the client to do so. It can continue to do so.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-09-14T08:28:22Z",
          "updatedAt": "2022-09-14T08:28:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > The scenarios you describe aren't allowed: if the server performs compatible version negotiation it MUST select a ` Chosen Version` that was included in the client's `Other Versions`:\r\n> \r\n> yes, but servers are allowed to do incompatible version negotiation.\r\n> \r\n> in my 1st scenario, the server initiates incompatible version negotiation, the server selects D instead of C as chosen by client\r\n\r\nThat doesn't make sense. The server initiates incompatible version negotiation by sending a VN packet, there's no notion of chosen version in the VN packet.\r\n\r\n> in the 2nd scenario, it is not possible if A, B, C,D, E,F all are compatible. if the server starts incompatible version negotiation with (C,D) and client does not find any supported version, it aborts the connection. I just realized - **there is no normative text for aborting the connection attempt.**.\r\n\r\nThere's no need for normative text when there's nothing else a client can do, are you saying the client could do something wrong as opposed to aborting due to lack of versions?\r\n\r\n> As the server expresses all the versions it support in the supported versions list, the client knows there is not point on continuing with another attempt with (E,F). Unless I am mistaken there is nothing now prohibiting the client to do so. It can continue to do so.\r\n\r\nThe client will ignore any VN packet apart from the first one: `A client that makes a connection attempt based on information received from a Version Negotiation packet MUST ignore any Version Negotiation packets it receives in response to that connection attempt.`\r\n\r\n",
          "createdAt": "2022-09-14T19:13:24Z",
          "updatedAt": "2022-09-14T19:13:24Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "> > > The scenarios you describe aren't allowed: if the server performs compatible version negotiation it MUST select a ` Chosen Version` that was included in the client's `Other Versions`:\r\n> > \r\n> > \r\n> > yes, but servers are allowed to do incompatible version negotiation.\r\n> > in my 1st scenario, the server initiates incompatible version negotiation, the server selects D instead of C as chosen by client\r\n> \r\n> That doesn't make sense. The server initiates incompatible version negotiation by sending a VN packet, there's no notion of chosen version in the VN packet.\r\n\r\nright, my bad. I think I have drawn the picture wrong. Server send (D,C) and the client choses C but the server choses D. does this make sense?  and the main issue goes away? sniped from my previous comment.\r\n \r\n>The expectation here is that D will be the final negotiated version, and the version negotiation will end. But is there anything stopping the client to try to enforce it's chosen one (C) again? shall we have some to avoid this case?\r\n> \r\n> > in the 2nd scenario, it is not possible if A, B, C,D, E,F all are compatible. if the server starts incompatible version negotiation with (C,D) and client does not find any supported version, it aborts the connection. I just realized - **there is no normative text for aborting the connection attempt.**.\r\n> \r\n> There's no need for normative text when there's nothing else a client can do, are you saying the client could do something wrong as opposed to aborting due to lack of versions?\r\n\r\nyes . and should we try to prevent it? \r\n\r\n> \r\n> > As the server expresses all the versions it support in the supported versions list, the client knows there is not point on continuing with another attempt with (E,F). Unless I am mistaken there is nothing now prohibiting the client to do so. It can continue to do so.\r\n> \r\n> The client will ignore any VN packet apart from the first one: `A client that makes a connection attempt based on information received from a Version Negotiation packet MUST ignore any Version Negotiation packets it receives in response to that connection attempt.`\r\n\r\nOK, I see the client ignores, but what does happen then ? does it abort the connection attempt ?  Is it possible for the client to start another connection attempt with complete new original versions and a new set of other versions?\r\n",
          "createdAt": "2022-09-14T21:16:56Z",
          "updatedAt": "2022-09-14T21:16:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> right, my bad. I think I have drawn the picture wrong. Server send (D,C) and the client choses C but the server choses D. does this make sense? and the main issue goes away? sniped from my previous comment.\r\n\r\nZahed and I discussed this first scenario offline. In this scenario, the client indicated that it was happy with D by sending it in its Other Versions, so the client will be happy when D is negotiated even if it preferred C. If the client didn't like D, it could have removed D from Other Versions and then the connection would have negotiated C.\r\n\r\n> yes . and should we try to prevent it?\r\n\r\nFair enough, this can be fixed with a small tweak - see below.\r\n\r\n> OK, I see the client ignores, but what does happen then ? does it abort the connection attempt ? Is it possible for the client to start another connection attempt with complete new original versions and a new set of other versions?\r\n\r\nZahed and I discussed this second scenario offline as well. I wrote up #123 to make the incompatible VN text more normative and that addresses Zahed's concern here.\r\n\r\nNow we have normative text to guarantee a failure in that scenario. If the client wants to start a separate connection attempt later, it will restart the algorithm from the top. We explicitly decided as a WG to avoid telling the client to remember information from previous connection attempts because VN packets don't carry an expiration date so caching them is fraught.",
          "createdAt": "2022-09-14T22:04:11Z",
          "updatedAt": "2022-09-14T22:04:11Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "I_kwDODoD7vc5Svc0A",
      "title": "Update discipline: tell readers what you update",
      "url": "https://github.com/quicwg/version-negotiation/issues/125",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We have agreed to mark this document as updating RFC 8999. Fine, but this lacks a bit of discipline. We should have a statement inside the text (not just the abstract) explaining in which way RFC 8999 is updated.",
      "createdAt": "2022-09-27T18:13:03Z",
      "updatedAt": "2022-09-28T00:38:23Z",
      "closedAt": "2022-09-28T00:38:23Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can someone propose text here? Based on our discussion in #115, there is no agreement inside the IETF on what \"updates\" means so I'm not sure what text would be helpful for readers.",
          "createdAt": "2022-09-27T18:28:55Z",
          "updatedAt": "2022-09-27T18:28:55Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi see PR #126 ",
          "createdAt": "2022-09-27T19:21:23Z",
          "updatedAt": "2022-09-27T19:21:23Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDODoD7vc5TqNBS",
      "title": "Should fail the handshake when version_info.chosen_version doesn't match long_header.version",
      "url": "https://github.com/quicwg/version-negotiation/issues/129",
      "state": "CLOSED",
      "author": "anrossi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently at [section 3](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation#section-3) says future versions might allow the long header version to be different from the chosen version in the version_info transport parameter.  But there's nothing about what to do until such a version exists which changes the semantics of the chosen_version.\r\nThis is in the initial packet, before incompatible version negotiation, and before compatible version negotiation, has happened.\r\n\r\nWhich error should the handshake be closed with? [Section 4](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation#section-4) says that version info transport parameter parsing errors should use the transport parameter error.\r\n",
      "createdAt": "2022-10-10T18:40:42Z",
      "updatedAt": "2022-10-20T00:20:59Z",
      "closedAt": "2022-10-20T00:20:59Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this some more, I think draft-ietf-quic-version-negotiation doesn't need to say anything more, as those details are specific to the compatibility version document. So I opened https://github.com/quicwg/quic-v2/issues/76 to discuss this there.",
          "createdAt": "2022-10-11T21:00:31Z",
          "updatedAt": "2022-10-11T21:00:31Z"
        },
        {
          "author": "anrossi",
          "authorAssociation": "NONE",
          "body": "I'm a little confused because this document explains which errors should be used with QUIC v1 when closing the connection on failure to parse the transport parameter or invalid versions (i.e. 0). In the absence of another compatibility version document, shouldn't this document specify the error for QUIC v1?  Or are you saying this is not an error in QUIC v1, but could be an error in, e.g., QUIC v2?",
          "createdAt": "2022-10-11T22:36:55Z",
          "updatedAt": "2022-10-11T22:36:55Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This only causes an error when there are two versions involved - and therefore that scenario should be covered by the document that defines compatibility between those two versions. Or do you have a scenario in mind where one version is QUICv1 and the other is unknown?\r\n\r\nI'm noticing that RFC 9000 doesn't say what you're supposed to do if you receive a packet from another version - I think the assumption is that you silently drop it because you don't know how to parse it.",
          "createdAt": "2022-10-11T22:48:46Z",
          "updatedAt": "2022-10-11T22:48:46Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that I should specify the v1/v2 case. But perhaps the VN draft should handle the behavior when the long header has a known version (certainly v1) and the Chosen Version is unknown?\r\n\r\n(I imagine that allowing this allows us to have a backdoor for version upgrade if the version field ossifies)",
          "createdAt": "2022-10-12T01:26:10Z",
          "updatedAt": "2022-10-12T01:26:10Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would recommend that a server sends a VN packet in this case, and a client kills the connection -- there is no valid reason for the server to slip in a version the client didn't advertise.",
          "createdAt": "2022-10-12T01:27:50Z",
          "updatedAt": "2022-10-12T01:27:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rereading what @anrossi originally wrote along with @martinduke's comments, I think we can tighten up the validation requirements in this spec to prevent tampering. I've written it up as #131, please take a look.\r\n\r\n@martinduke I went with forcing a close instead of your suggestion, because this back door would weaken the protocol (allows tampering) without helping (if the long header ossifies we can use compatible VN as our backdoor).",
          "createdAt": "2022-10-12T21:38:02Z",
          "updatedAt": "2022-10-12T21:38:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure compatible VN is sufficient. If someone writes a firewall that says \"drop all Long Headers with version == 4\" I don't see that compatible negotiation solves the problem -- all the long headers have to say v1 and the actual negotiation happens using TPs.\r\n\r\nThough I haven't fully thought this through, and certainly not any backdoor implications.",
          "createdAt": "2022-10-12T21:47:15Z",
          "updatedAt": "2022-10-12T21:47:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that the requirement is only for the client's first flight. So you work around that firewall by defining v1-to-v4 compatibility as always setting Version=1 in long headers",
          "createdAt": "2022-10-12T21:55:33Z",
          "updatedAt": "2022-10-12T21:55:33Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think that works.",
          "createdAt": "2022-10-12T22:01:33Z",
          "updatedAt": "2022-10-12T22:01:33Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA4NTcxMzIx",
      "title": "Fixed nit",
      "url": "https://github.com/quicwg/version-negotiation/pull/7",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-24T14:05:13Z",
      "updatedAt": "2020-04-24T17:32:36Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "096b2acc536f40cc4a76f894562cd264a8aa853e",
      "headRepository": "martinduke/version-negotiation",
      "headRefName": "patch-1",
      "headRefOid": "9d95ffbdf2e254056bf70b04be67e03e40dd1e71",
      "closedAt": "2020-04-24T17:32:35Z",
      "mergedAt": "2020-04-24T17:32:35Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e0b5dedc1eebe2c9ff78600ec8334f94f87d4a8b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5NzM1OTkx",
      "title": "fix link to editors copy",
      "url": "https://github.com/quicwg/version-negotiation/pull/10",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #9",
      "createdAt": "2020-12-14T19:06:27Z",
      "updatedAt": "2020-12-14T20:05:02Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "63b19e2ac9562ea7a9de2686b4a79b4227f23bc7",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "editors-copy-link",
      "headRefOid": "abc8deb1d5ecab19b885686bc401ae770ab35eff",
      "closedAt": "2020-12-14T20:05:01Z",
      "mergedAt": "2020-12-14T20:05:00Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "3584aa497c0c839bae1c5256cf25de01a674e038"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODUwMTkz",
          "commit": {
            "abbreviatedOid": "abc8deb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for the PR!",
          "createdAt": "2020-12-14T20:04:54Z",
          "updatedAt": "2020-12-14T20:04:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU0NTgyODM2",
      "title": "Major rewrite of draft-ietf-quic-version-negotiation",
      "url": "https://github.com/quicwg/version-negotiation/pull/11",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rewrites most of the draft to make it more aligned\r\nwith the fact that it's now a stand-alone document that\r\nis not directly tied to QUICv1.\r\n\r\nFixes #1.\r\nFixes #2.\r\nFixes #3.\r\nFixes #4.\r\nFixes #5.\r\nFixes #6.\r\nFixes #8.\r\nFixes #13.\r\nFixes #14.",
      "createdAt": "2021-01-14T01:23:23Z",
      "updatedAt": "2021-02-05T00:29:13Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "cb8c2ae62d0de370a60e0c75874f734d1bb67cdb",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "major_rewrite_20210113",
      "headRefOid": "716c57573cdec0d62cae667b325a696b7659059e",
      "closedAt": "2021-02-05T00:28:59Z",
      "mergedAt": "2021-02-05T00:28:59Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "3dc47acb8d087878a06d738f7e3fe103894c312f"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks defining compatible is currently left to future documents. For example QUICv2 could define its compatibility with QUICv1, or it could decide to skip that and rely on a future document.\r\n\r\nWe could theoretically use draft29 vs QUICv1 as an experiment, but I know we wouldn't implement it because that one is really tricky due to the transport parameter codepoint.",
          "createdAt": "2021-01-14T19:59:55Z",
          "updatedAt": "2021-01-14T19:59:55Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> defining compatible is currently left to future documents\r\n\r\nDo we explicitly state this? Should we (can we?) require future documents/versions to respect this process? Even if they're incompatible with other versions, should they reference and require usage of this extension? Would it even still be an extension or directly included?\r\n\r\n> could theoretically use draft29 vs QUICv1 as an experiment\r\n\r\nI do think it would be a good test case. It might be practically be useful as well, as v1 and -29 start being supported in parallel in the coming months. Perhaps a separate issue should be opened to track this though.",
          "createdAt": "2021-01-14T20:16:39Z",
          "updatedAt": "2021-01-14T20:16:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > defining compatible is currently left to future documents\r\n> \r\n> Do we explicitly state this?\r\n\r\nWe explicitly say that versions are incompatible unless a future document says otherwise.\r\n\r\n> Should we (can we?) require future documents/versions to respect this process? Even if they're incompatible with other versions, should they reference and require usage of this extension? Would it even still be an extension or directly included?\r\n\r\nWe shouldn't require anything. This is just an extension, and we may replace it with a different extension some day.\r\n\r\n> > could theoretically use draft29 vs QUICv1 as an experiment\r\n> \r\n> I do think it would be a good test case. It might be practically be useful as well, as v1 and -29 start being supported in parallel in the coming months. Perhaps a separate issue should be opened to track this though.\r\n\r\nA separate issue sounds best, could you file it please?\r\n\r\n",
          "createdAt": "2021-01-14T20:27:37Z",
          "updatedAt": "2021-01-14T20:27:37Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. Sounds good. #12 opened.",
          "createdAt": "2021-01-14T20:30:33Z",
          "updatedAt": "2021-01-14T20:30:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Mon, Feb 1, 2021 at 4:50 PM David Schinazi <notifications@github.com>\nwrote:\n\n> *@DavidSchinazi* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-quic-version-negotiation.md\n> <https://github.com/quicwg/version-negotiation/pull/11#discussion_r568246064>\n> :\n>\n> > +the negotiated version. The handshake of the negotiated version will exchange\n> +handshake version information (see {{hs-vers-info}}) required to ensure that VN\n> +was genuine, i.e. that no attacker injected packets in order to influence the\n> +VN process, see {{downgrade}}.\n> +\n> +\n> +## Compatible Version Negotiation {#compat-vn}\n> +\n> +When the server can parse the client's first flight using the original version,\n> +it can extract the client's handshake version information (see\n> +{{hs-vers-info}}). This contains the list of versions that the client thinks\n> +its original version is compatible with.\n> +\n> +If the server supports one of the client's compatible versions, and the server\n> +also believes that the original version is compatible with this version, then\n> +the server attempts to convert the client's first flight to that version. If\n>\n> What does valid mean? In my understanding of the word, an initial from\n> version A will never be valid in version B because version B requires the\n> version on the long header to be B.\n>\n\nNot necessarily. We could say that for version B, the long header could\nhave either A or B. This basically requires reinterpreting\nLongHeader.Version as \"format\" or \"minimum version to interpret\" or\nsomething, but it's not inherently a problem.\n",
          "createdAt": "2021-02-02T00:53:35Z",
          "updatedAt": "2021-02-02T00:53:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged based on offline conversation with @ekr ",
          "createdAt": "2021-02-05T00:29:13Z",
          "updatedAt": "2021-02-05T00:29:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3ODAyOTI3",
          "commit": {
            "abbreviatedOid": "d9be874"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Generally, looks to be a good rewrite. Thanks!\r\n\r\nBeyond the one small nit, I have a question about what document has the responsibility to describe/define what versions are compatible and how. This document by definition is an extension to the QUIC spec. The same may continue to be true for QUIC v2, right? If neither spec directly acknowledge this document, it seems they wouldn't specify how compatibility may work. If so, is it the responsibility of this extension to be updated with all known compatibility rules?\r\n\r\nAdditionally, would/could we use -29 and v1 as test candidates for this process? Should we define the compatibility rules in this doc?",
          "createdAt": "2021-01-14T02:12:59Z",
          "updatedAt": "2021-01-14T02:17:37Z",
          "comments": [
            {
              "originalPosition": 466,
              "body": "```suggestion\r\npreclude compatibility. Additionally, frames in QUIC version 1 do not use a\r\n```",
              "createdAt": "2021-01-14T02:13:00Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5OTI4NTYy",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-01-31T19:59:35Z",
          "updatedAt": "2021-01-31T20:25:53Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Is this true for incompatible and compatible VN?",
              "createdAt": "2021-01-31T19:59:35Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 90,
              "body": "Trying to define this as a property of *versions* seems problematic. I think we would be better off with a much simpler model, focuses on flights. A version A first flight is compatible with B if it would be acceptable to a conforming B implementation (this is the situation in TLS, for instance). \r\n\r\nConsider the case where we start with version X.\r\nWe now define version Y which has the same initial flight as X except that it requires transport parameter A and requires an initial version of X or Y.\r\n\r\nThus, a version X Initial could consist of:\r\n{version = X, compatible_versions = [X], transport_parameters = [...]}\r\n\r\nA compatible version Y would consist of:\r\n\r\nAt some point in the future, when version X is deprecated, you could send:\r\n{version = Y, compatible_versions = [X, Y], transport_parameters = [...., A]}\r\n\r\nThis doesn't preclude defining concurrent versions, in that one could could define a version Z which is like X but needs transport parameter B, so it has an X compatible first flight\r\n{version = X, compatible_versions = [X, Z], transport_parameters = [...., B]}\r\n\r\nIt also has an X, Y, Z compatible first flight:\r\n{version = X, compatible_versions = [X, Y, Z], transport_parameters = [...., A, B]}\r\n\r\nThis obviously works more cleanly if versions are essentially linear, but works OK if each version is required to accept an Initial which has the external version matching some previous version as well.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2021-01-31T20:14:33Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 170,
              "body": "This SHOULD seems like a problem. If this is the same connection, then this should be a MUST. If not, then DCID should change.",
              "createdAt": "2021-01-31T20:17:02Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 188,
              "body": "As above, I think this whole \"convert\" thing is problematic. We should confine ourselves to Initials which are valid for both versions.",
              "createdAt": "2021-01-31T20:17:39Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 204,
              "body": "Can you elaborate on how this would happen?",
              "createdAt": "2021-01-31T20:20:16Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 211,
              "body": "How is this opaque?",
              "createdAt": "2021-01-31T20:20:33Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 381,
              "body": "could? Perhaps would?",
              "createdAt": "2021-01-31T20:22:07Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 415,
              "body": "I don't think this is that helpful and would remove it, but this PR doesn't change that, so we can deal with it separately.",
              "createdAt": "2021-01-31T20:23:02Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            },
            {
              "originalPosition": 469,
              "body": "This is an interesting point that we didn't really consider in detail with TLS 1.3. However, I think it's off base for the same reason as above. We should just require them to be valid.",
              "createdAt": "2021-01-31T20:25:01Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk1MjA4",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:45:57Z",
          "updatedAt": "2021-02-02T00:45:58Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "We can have it either way. I wrote it as \"yes\" but we could change that. What do you think?",
              "createdAt": "2021-02-02T00:45:58Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk3MDU4",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:49:26Z",
          "updatedAt": "2021-02-02T00:49:26Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Do you have thoughts on what you prefer? I dislike MUST because it can cause issues if version A allows CID lengths of [0-8] and version B only allows [9-20]. (I know this probably won't happen, but I don't want to paint us into that corner)",
              "createdAt": "2021-02-02T00:49:26Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk3NTUx",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:50:43Z",
          "updatedAt": "2021-02-02T00:50:43Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "What does valid mean? In my understanding of the word, an initial from version A will never be valid in version B because version B requires the version on the long header to be B.",
              "createdAt": "2021-02-02T00:50:43Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk3ODcx",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:51:29Z",
          "updatedAt": "2021-02-02T00:51:29Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "In QUICv1, the server can select its own CID during the handshake by replying with a source CID that is different from the client's destination CID",
              "createdAt": "2021-02-02T00:51:29Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk4MDcw",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:51:55Z",
          "updatedAt": "2021-02-02T00:51:56Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "In that versions themselves don't need to worry about what's inside?",
              "createdAt": "2021-02-02T00:51:55Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk4NTY1",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:53:05Z",
          "updatedAt": "2021-02-02T00:53:05Z",
          "comments": [
            {
              "originalPosition": 381,
              "body": "Not really, \"would\" implies that the server doesn't use randomness when generating VN packets - and we do that for GREASE",
              "createdAt": "2021-02-02T00:53:05Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwODk4Njc5",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T00:53:25Z",
          "updatedAt": "2021-02-02T00:53:25Z",
          "comments": [
            {
              "originalPosition": 415,
              "body": "Yeah, please file a separate issue",
              "createdAt": "2021-02-02T00:53:25Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTM0MTYy",
          "commit": {
            "abbreviatedOid": "3fd08d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T02:25:02Z",
          "updatedAt": "2021-02-02T02:25:03Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "@ekr said:\r\n> Not necessarily. We could say that for version B, the long header could have either A or B. This basically requires reinterpreting LongHeader.Version as \"format\" or \"minimum version to interpret\" or something, but it's not inherently a problem.\r\n\r\nI think we should decouple documents from compatibility. It should be possible to have versions A and B not know about each other, and then someone writes the compatibility doc between them later.\r\n\r\nBut there are other reasons for things to not be valid: take `h3-32` and `h3-33` for example - they use a different TLS extension codepoints (0xffa5 vs 57) for transport parameters. That makes a first flight from one invalid in the other. However, it's possible to convert from one to the other. That's why I think of conversion instead of validity.",
              "createdAt": "2021-02-02T02:25:02Z",
              "updatedAt": "2021-02-05T00:26:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY5OTc5MzEw",
      "title": "Reword language about connections",
      "url": "https://github.com/quicwg/version-negotiation/pull/16",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "No real complaint with what existed before, but I thought that this\r\nmight be clearer.",
      "createdAt": "2021-02-09T03:14:23Z",
      "updatedAt": "2021-05-25T01:38:21Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "3dc47acb8d087878a06d738f7e3fe103894c312f",
      "headRepository": "martinthomson/version-negotiation",
      "headRefName": "how-many-connections",
      "headRefOid": "3d03cbd786c7cdfd4147cff7d88d1643d892d2fb",
      "closedAt": "2021-05-25T01:38:21Z",
      "mergedAt": "2021-05-25T01:38:21Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "cfbf40c2e6e1346e2bf4700e81fcb93a6e6960de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3MjU1ODA0",
          "commit": {
            "abbreviatedOid": "e3a9aff"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-10T04:55:53Z",
          "updatedAt": "2021-02-10T04:55:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg4MjE0MTg5",
          "commit": {
            "abbreviatedOid": "e3a9aff"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Approved with one nit",
          "createdAt": "2021-02-11T02:31:53Z",
          "updatedAt": "2021-02-11T02:32:05Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nIn comparison, the incompatible version negotiation mechanism, which leverages QUIC\r\n```",
              "createdAt": "2021-02-11T02:31:53Z",
              "updatedAt": "2021-02-11T02:53:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcxNTQzODQ3",
      "title": "Do not special-case receipt of grease versions",
      "url": "https://github.com/quicwg/version-negotiation/pull/31",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #22 ",
      "createdAt": "2021-02-11T03:28:38Z",
      "updatedAt": "2021-03-05T00:42:18Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "3dc47acb8d087878a06d738f7e3fe103894c312f",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "recv_grease",
      "headRefOid": "312dc39576ace53abafda7cc6cb5a19b78e82cce",
      "closedAt": "2021-03-05T00:42:17Z",
      "mergedAt": "2021-03-05T00:42:17Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "1b1eb8188eb6a31e3c168136c135ff372623e9ba"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE1NzM0ODU4",
      "title": "Replace bijective with symmetric",
      "url": "https://github.com/quicwg/version-negotiation/pull/33",
      "state": "MERGED",
      "author": "wbl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-15T05:38:43Z",
      "updatedAt": "2021-05-25T01:37:44Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "4b6fae34c6d4806b73f17aec75d0fc710aad4e12",
      "headRepository": "wbl/version-negotiation",
      "headRefName": "watson/terminology",
      "headRefOid": "eb5837ab88892c5c94b8a85cff79420c377bfa46",
      "closedAt": "2021-05-25T01:37:44Z",
      "mergedAt": "2021-05-25T01:37:44Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "dec568991fc865506ca6405214fd3a00794cf59d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2Mjg1OTU2",
          "commit": {
            "abbreviatedOid": "eb5837a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-15T05:39:30Z",
          "updatedAt": "2021-04-15T05:39:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMyMTY1Njc3",
      "title": "Incorporate MT's design",
      "url": "https://github.com/quicwg/version-negotiation/pull/42",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR simplifies the document's design. The new simplified design was by @martinthomson . It removes the indication of server versions that everyone seemed to think was useless, but apart from that has very similar properties to the previous design. One important difference is that it is now the client's responsibility to detect VN-packet-based downgrade attacks instead of the server's.\r\n\r\n[An HTML version of what the draft would look like with this PR merged is available here](https://quicwg.org/version-negotiation/simplify/draft-ietf-quic-version-negotiation.html).",
      "createdAt": "2021-05-07T02:01:35Z",
      "updatedAt": "2021-05-25T01:37:21Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "4b6fae34c6d4806b73f17aec75d0fc710aad4e12",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "simplify",
      "headRefOid": "1068db981fabb29b92e55f2200ae9f297e554ee8",
      "closedAt": "2021-05-25T01:37:21Z",
      "mergedAt": "2021-05-25T01:37:21Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "6f495f435261974d336809c3821eb9708abde721"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MDIzNjE3",
          "commit": {
            "abbreviatedOid": "5f0bf65"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Much easier than I had expected, which is good.\r\n\r\nThere's more work to do here, and I have only reviewed the diff, but this is good.",
          "createdAt": "2021-05-07T02:04:08Z",
          "updatedAt": "2021-05-07T02:39:52Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n: This is the set of versions supported by a given individual server instance.\r\n```",
              "createdAt": "2021-05-07T02:04:08Z",
              "updatedAt": "2021-05-07T02:39:52Z"
            },
            {
              "originalPosition": 42,
              "body": "I think that this might be better named \"Chosen Version\".  It's not necessarily the first choice, but the choice that is made after seeing what the other side supports (the client chooses by guessing if it doesn't get VN, and chooses from VN if it does; the server chooses from compatible versions).",
              "createdAt": "2021-05-07T02:05:52Z",
              "updatedAt": "2021-05-07T02:39:52Z"
            },
            {
              "originalPosition": 61,
              "body": "I'm not sure that this is the definition we want.  I *think* that you are right that this matches the version in the long header, but that is an accident of the design.  The key is that this is the version that the endpoint chose.\r\n\r\nIt might be possible with retransmissions of Initial packets to include this information even after the server - and server - has switched to a compatible version.  While it might be obvious that the server got the info, the retransmission machinery on the client might not have received an ACK and so it could send this again.",
              "createdAt": "2021-05-07T02:10:37Z",
              "updatedAt": "2021-05-07T02:39:52Z"
            },
            {
              "originalPosition": 80,
              "body": "I'm still not on board with preference ordering.  But let's track that separately.",
              "createdAt": "2021-05-07T02:30:31Z",
              "updatedAt": "2021-05-07T02:39:53Z"
            },
            {
              "originalPosition": 96,
              "body": "You might need to expand on this, as it is a key concept.  \r\n\r\nThis might be worth an entire section that says something like:\r\n\r\nThe client might receive a Version Negotiation packet from a server instance that doesn't support some Partially-Supported Versions; if it does so, those Partially-Supported Versions won't be listed in the Version Negotiation packet.  As part of validating the server's Other Versions, the client verifies that it would not have chosen any of the versions the server listed.  If the client supports any Partially-Supported Version and would prefer that version, it will detect a downgrade attack.  To avoid this, the server does not advertise any version that is Partially-Supported.\r\n\r\n(And then we need text about how to turn on new versions properly.  (1) Deploy code and accept connections; (2) turn on VN for that version; (3) turn on Other Versions for that version and enjoy downgrade protection.)",
              "createdAt": "2021-05-07T02:36:37Z",
              "updatedAt": "2021-05-07T02:39:53Z"
            },
            {
              "originalPosition": 144,
              "body": "These aren't ignored, it's just that they are never selected.",
              "createdAt": "2021-05-07T02:37:02Z",
              "updatedAt": "2021-05-07T02:39:53Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nclient's original version. If this validation fails, the client MUST close the\r\n```",
              "createdAt": "2021-05-07T02:37:30Z",
              "updatedAt": "2021-05-07T02:39:53Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\na transport error of type `VERSION_NEGOTIATION_ERROR`. This prevents \r\nan attacker from being able to use forged Version Negotiation packets to\r\nforce a version downgrade.\r\n```",
              "createdAt": "2021-05-07T02:38:27Z",
              "updatedAt": "2021-05-07T02:39:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NzAzMzc4",
          "commit": {
            "abbreviatedOid": "5f0bf65"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for the review!",
          "createdAt": "2021-05-07T17:20:22Z",
          "updatedAt": "2021-05-07T17:48:00Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Agreed, done.",
              "createdAt": "2021-05-07T17:20:22Z",
              "updatedAt": "2021-05-07T17:48:00Z"
            },
            {
              "originalPosition": 80,
              "body": "I filed #43 to track this.",
              "createdAt": "2021-05-07T17:23:19Z",
              "updatedAt": "2021-05-07T17:48:00Z"
            },
            {
              "originalPosition": 96,
              "body": "Agreed, fleshed out the \"Server Deployments of QUIC\" section",
              "createdAt": "2021-05-07T17:43:15Z",
              "updatedAt": "2021-05-07T17:48:00Z"
            },
            {
              "originalPosition": 144,
              "body": "Fixed",
              "createdAt": "2021-05-07T17:43:23Z",
              "updatedAt": "2021-05-07T17:48:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NzIzNjkw",
          "commit": {
            "abbreviatedOid": "7cb7f79"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T17:48:23Z",
          "updatedAt": "2021-05-07T17:48:23Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Agreed, I tweaked the text.",
              "createdAt": "2021-05-07T17:48:23Z",
              "updatedAt": "2021-05-07T17:48:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1MTg2NTc4",
          "commit": {
            "abbreviatedOid": "7cb7f79"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I realize now that the 2-step upgrade might need to be 3-step.  See below for more.",
          "createdAt": "2021-05-10T02:23:40Z",
          "updatedAt": "2021-05-10T02:39:02Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think that you can just say that an instantaneous upgrade is impossible.  A server deployment that includes multiple server instances cannot upgrade all instances instantaneously.  Even if that were possible, there could still be outdated Version Negotiation packets in flight that might result in negotiation failure if downgrade protection were engaged atomically.\r\n\r\nThis also applies to a single instance deployment.  Though you might avoid the problem by ensuring that your upgrade involves enough downtime to avoid the in-flight VN problem, you might as well just apply the same logic as a multi-server deployment.\r\n\r\nBased on that I would remove the \"single server instance\" paragraph and replace it with a description of the in-flight VN problem.",
              "createdAt": "2021-05-10T02:23:40Z",
              "updatedAt": "2021-05-10T02:39:02Z"
            },
            {
              "originalPosition": 70,
              "body": "Based on the above, I would remove the condition here: just describe how a new version is deployed.",
              "createdAt": "2021-05-10T02:26:47Z",
              "updatedAt": "2021-05-10T02:39:02Z"
            },
            {
              "originalPosition": 103,
              "body": "As I said before, I think that you can - at best - say that the field is generally equal to the Version field in the packet that carries the data.  You can't use \"MUST\".",
              "createdAt": "2021-05-10T02:28:24Z",
              "updatedAt": "2021-05-10T02:39:02Z"
            },
            {
              "originalPosition": 109,
              "body": "I just noticed this editorial convention: I think that you should avoid using backticks for field names.  The QUIC spec doesn't use them.  (One nasty consequence of using them is that you get scare quotes in the text rendering.)",
              "createdAt": "2021-05-10T02:29:13Z",
              "updatedAt": "2021-05-10T02:39:02Z"
            },
            {
              "originalPosition": 75,
              "body": "This needs to be three steps:\r\n\r\n1. Add code for version X\r\n2. Advertise version X in Version Negotiation\r\n3. Add version X to Other Versions\r\n\r\nThe reason I say this is the in-flight VN.  Let's say that you support version X and you just add it both VN and OV.  What about clients that 2ms ago got a VN without X in it?\r\n\r\nThe transition between step 2 and 3 can be short.  You can run that on a fairly short timer for a single server deployment, but you need to ensure that all VNs are out of the system before you move to step 3 or connections will fail.\r\n\r\nThe logic here is:\r\n\r\n* don't update the advisory signals (VN) until the code is in place\r\n* don't update the downgrade protection (OV) until all the advisory signals are in place\r\n\r\nRollback is similar: first remove downgrade protection, then remove advisory signals, then remove actual support.\r\n\r\nOne thing I like about this design is that we because we don't rely on VN being correct, the design can be made robust against VN being wrong for a short period.\r\n\r\nSee also https://quicwg.org/ops-drafts/draft-ietf-quic-applicability.html#name-enabling-new-versions",
              "createdAt": "2021-05-10T02:33:58Z",
              "updatedAt": "2021-05-10T02:39:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MDcxNjI4",
          "commit": {
            "abbreviatedOid": "7cb7f79"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T18:28:31Z",
          "updatedAt": "2021-05-11T18:28:32Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I'll address this in a separate PR, filed #44.",
              "createdAt": "2021-05-11T18:28:31Z",
              "updatedAt": "2021-05-11T18:28:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MTA5MTc0",
          "commit": {
            "abbreviatedOid": "7cb7f79"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Nice catch on in-flight VN, thanks!",
          "createdAt": "2021-05-11T19:13:25Z",
          "updatedAt": "2021-05-11T19:58:58Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "You'd be amazed at what time precision you can get using GPS clocks :)\r\n\r\nBut I've reworked this section to incorporate the in-flight VN problem.",
              "createdAt": "2021-05-11T19:13:25Z",
              "updatedAt": "2021-05-11T19:58:58Z"
            },
            {
              "originalPosition": 70,
              "body": "I've reworked the text slightly differently.",
              "createdAt": "2021-05-11T19:13:52Z",
              "updatedAt": "2021-05-11T19:58:58Z"
            },
            {
              "originalPosition": 75,
              "body": "I think we can get away with 2 steps if you have a delay between the two. What makes it work is using Fully Deployed Versions as what you send for VN. Let me know what you think.",
              "createdAt": "2021-05-11T19:28:59Z",
              "updatedAt": "2021-05-11T19:58:58Z"
            },
            {
              "originalPosition": 103,
              "body": "Do you have a proposal for what text we should write for validation then?",
              "createdAt": "2021-05-11T19:58:46Z",
              "updatedAt": "2021-05-11T19:58:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3NDIwMTU3",
          "commit": {
            "abbreviatedOid": "d47ad78"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-12T02:53:50Z",
          "updatedAt": "2021-05-12T02:53:50Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "So the server doesn't need to validate what the client provides (it is picking from the list, and **use** >> **validation**).\r\n\r\nThe client verifies that (a) the version it sent prior to receiving a Version Negotiation packet is not listed, and (b) it would not have selected a different version if it knew what versions the server truly supports.  Note here that the client's choice is based on what the server signals in other versions, the chosen version (if we drop ordering, as we should).\r\n\r\nI realize now that the server can't drop compatible versions from this list.  There's a long and complicated argument for why that doesn't work if you are interested, but I need to eat a well-overdue lunch and it might be better over a video link because it's tricky.",
              "createdAt": "2021-05-12T02:53:50Z",
              "updatedAt": "2021-05-12T02:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTAzNDAx",
          "commit": {
            "abbreviatedOid": "29bbd2e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T01:08:01Z",
          "updatedAt": "2021-05-13T01:08:01Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "> So the server doesn't need to validate what the client provides (it is picking from the list, and **use** >> **validation**).\r\n\r\nI've tweaked the text to clarify that this is the version used, not the one from long headers. That allowed me to drop this validation.\r\n\r\n> The client verifies that (a) the version it sent prior to receiving a Version Negotiation packet is not listed, and (b) it would not have selected a different version if it knew what versions the server truly supports.\r\n\r\nOh good catch I was missing (b).\r\n\r\n> Note here that the client's choice is based on what the server signals in other versions, the chosen version (if we drop ordering, as we should).\r\n\r\nNote that in the current proposal we have ordering of the client's versions but not of the server's versions.\r\n\r\n> I realize now that the server can't drop compatible versions from this list. There's a long and complicated argument for why that doesn't work if you are interested, but I need to eat a well-overdue lunch and it might be better over a video link because it's tricky.\r\n\r\nIn the current proposal endpoints can disagree on which versions are compatible so we need them in the list in case the client doesn't think they are compatible.",
              "createdAt": "2021-05-13T01:08:01Z",
              "updatedAt": "2021-05-13T01:08:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTI0NDAz",
          "commit": {
            "abbreviatedOid": "29bbd2e"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T01:57:25Z",
          "updatedAt": "2021-05-13T01:57:25Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "That is not the reason I had, but as the server generates its list after the client, it would know what the client thinks is compatible when generating its list.",
              "createdAt": "2021-05-13T01:57:25Z",
              "updatedAt": "2021-05-13T01:57:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTQ0MDM0",
          "commit": {
            "abbreviatedOid": "29bbd2e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T02:58:45Z",
          "updatedAt": "2021-05-13T02:58:46Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Oh that's a good point. I'd love to hear the full story over VC one of these days then, but no rush.\r\n\r\nBut overall, do you think this PR is ready to be merged? (If you do I'll email the list to get WG input)",
              "createdAt": "2021-05-13T02:58:45Z",
              "updatedAt": "2021-05-13T02:58:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTY3OTg5",
          "commit": {
            "abbreviatedOid": "29bbd2e"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think that your upgrade process is busted, but that can be fixed later if you want to open a separate issue.",
          "createdAt": "2021-05-13T04:21:08Z",
          "updatedAt": "2021-05-13T04:26:15Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Do you add the code AND start sending VN with the new version at the same time?  Because sending VN in that state will result in connection failures.  As I said, this probably needs a three step dance.",
              "createdAt": "2021-05-13T04:21:08Z",
              "updatedAt": "2021-05-13T04:26:15Z"
            },
            {
              "originalPosition": 99,
              "body": "You can use `{{Section 15 of QUIC}}` if you like, or even `{{Section 15 (Versions) of QUIC}}`.  Both work (if you have a recent kramdown version).",
              "createdAt": "2021-05-13T04:22:47Z",
              "updatedAt": "2021-05-13T04:26:15Z"
            },
            {
              "originalPosition": 109,
              "body": "How about just \"Version Information\"?",
              "createdAt": "2021-05-13T04:23:38Z",
              "updatedAt": "2021-05-13T04:26:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MzA2MjI0",
          "commit": {
            "abbreviatedOid": "29bbd2e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T21:11:18Z",
          "updatedAt": "2021-05-13T21:32:58Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "No, the key property here is that VN packets carry the Fully-Deployed Versions, so that happens after the 1min wait. Or am I missing something?",
              "createdAt": "2021-05-13T21:11:18Z",
              "updatedAt": "2021-05-13T21:32:58Z"
            },
            {
              "originalPosition": 99,
              "body": "`{{Section 1.3 of QUIC}}` works but `{{Section 1.3 (Notational Conventions) of QUIC}}` doesn't. I'd rather have the section title when the other document isn't yet published because it could get renumbered.\r\n\r\nFWIW it's failing with `Error: IDREF attribute target references an unknown ID \"Section_1.3__Notational_Conventions__of_QUIC\", at None` and I'm at https://github.com/martinthomson/i-d-template/commit/4639e5ce1002e49ee93a4bb3d9acd7644b3a83de.",
              "createdAt": "2021-05-13T21:24:28Z",
              "updatedAt": "2021-05-13T21:32:59Z"
            },
            {
              "originalPosition": 109,
              "body": "I like that, done.",
              "createdAt": "2021-05-13T21:30:54Z",
              "updatedAt": "2021-05-13T21:32:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MzIxMzA5",
          "commit": {
            "abbreviatedOid": "2150253"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T21:34:47Z",
          "updatedAt": "2021-05-13T21:34:48Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Oh I'm realizing you said a recent kramdown, not a recent i-d-template. I'll look into updating that.",
              "createdAt": "2021-05-13T21:34:48Z",
              "updatedAt": "2021-05-13T21:34:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MzMzMDg3",
          "commit": {
            "abbreviatedOid": "2150253"
          },
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T21:54:02Z",
          "updatedAt": "2021-05-13T21:55:58Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "nit: \"Supported Versions\" is plural, but \"is\" is singular. You might consider using \"are\" instead of \"is\" or alternatively dodging by using \"Supported Versions set\" (which is singular).",
              "createdAt": "2021-05-13T21:54:02Z",
              "updatedAt": "2021-05-13T21:55:58Z"
            },
            {
              "originalPosition": 28,
              "body": "nit: \"fields\" or \"sets\"",
              "createdAt": "2021-05-13T21:54:22Z",
              "updatedAt": "2021-05-13T21:55:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MzU2Mjgw",
          "commit": {
            "abbreviatedOid": "2150253"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T22:42:23Z",
          "updatedAt": "2021-05-13T22:42:23Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "So the problem is that if you change VN and Other Versions at the same time. You will have a mismatch between VN and Other Versions in both directions.  Some clients will see VN without the new version and OV with.  Other clients will see VN with the new version and OV without.\r\n\r\nIt's that former of those two that creates a problem; if the client sees VN without version X and then sees version X in OV, then it will fail the connection.",
              "createdAt": "2021-05-13T22:42:23Z",
              "updatedAt": "2021-05-13T22:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5Mzg1Mzgw",
          "commit": {
            "abbreviatedOid": "48ca26d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T23:59:13Z",
          "updatedAt": "2021-05-13T23:59:13Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "/facepalm. Yup, you're right. Three steps it is.",
              "createdAt": "2021-05-13T23:59:13Z",
              "updatedAt": "2021-05-13T23:59:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5NDcwNzMy",
          "commit": {
            "abbreviatedOid": "48ca26d"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Almost there, but I think we need clarity on the clients verification-and-drop requirements.",
          "createdAt": "2021-05-14T03:01:28Z",
          "updatedAt": "2021-05-14T03:04:36Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "There is a tradeoff here between \"punish the attacker\" and \"punish the client\". Suppose that when all is said and done, the server proposes version X. Suppose also that version X is equally or better preferred by the client over the original version Y and the version Z proposed after version negotiation. For all practical matter, the attack has been thwarted, and the negotiation landed in a good place. Do you really want the client to discard the connection? Isn't that providing VN packets with the power of DOS? ",
              "createdAt": "2021-05-14T03:01:28Z",
              "updatedAt": "2021-05-14T03:04:36Z"
            },
            {
              "originalPosition": 314,
              "body": "On the other hand, I do like putting the onus of verification on the client. That's a significant improvement over the previous draft version.",
              "createdAt": "2021-05-14T03:02:43Z",
              "updatedAt": "2021-05-14T03:04:36Z"
            },
            {
              "originalPosition": 322,
              "body": "Yes! That does make the code simpler.",
              "createdAt": "2021-05-14T03:03:28Z",
              "updatedAt": "2021-05-14T03:04:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5NjYxODc2",
          "commit": {
            "abbreviatedOid": "48ca26d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-14T09:10:31Z",
          "updatedAt": "2021-05-14T09:10:31Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "I would be ok with saying that the client rejects the connection according to its policy. If it is content, then that is fine. Though I would strongly encourage a default posture of rejection. There are many other ways that an on path attack at this stage can be used to deny service, but leaving the protocol open to downgrade means that it is harder to defend. What if the perfectly acceptable version is broken, unbeknownst to the client?",
              "createdAt": "2021-05-14T09:10:31Z",
              "updatedAt": "2021-05-14T09:10:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5OTU3OTE2",
          "commit": {
            "abbreviatedOid": "48ca26d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-14T15:34:59Z",
          "updatedAt": "2021-05-14T15:37:30Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "Thanks :)",
              "createdAt": "2021-05-14T15:34:59Z",
              "updatedAt": "2021-05-14T15:37:30Z"
            },
            {
              "originalPosition": 314,
              "body": "I agree with MT here, VN can already cause DoS (just send an empty VN packet) so I'd rather be more conservative unless we have a specific scenario we want to enable.",
              "createdAt": "2021-05-14T15:37:23Z",
              "updatedAt": "2021-05-14T15:37:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMTI5NzA3",
          "commit": {
            "abbreviatedOid": "48ca26d"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-14T19:10:29Z",
          "updatedAt": "2021-05-14T19:40:00Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nupdates to happen a few server instances at a time. Because\r\n```\r\nRemoves a split infinitive and language that feels excessively informal (\"exact same time\").",
              "createdAt": "2021-05-14T19:10:30Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nsupport for a version.\r\n\r\nWhen adding support for a new version:\r\n\r\n- The first step is to progressively add\r\n  support for the new version to all server instances. This step updates the\r\n  Accepted Versions but not the Negotiated Versions nor the Fully-Deployed\r\n  Versions. Once all server instances have been updated, operators wait for at\r\n  least one minute to allow any in-flight Version Negotiation packets to\r\n  arrive. \r\n- Next, progressively add the new version to\r\n  Negotiated Versions on all server instances. Once complete, operators wait\r\n  for at least another minute.\r\n- Finally, progressively add\r\n  the new version to Fully-Deployed Versions on all server instances.\r\n```\r\nModulo rewrapping, I think moving the bullets down a level is clearer.",
              "createdAt": "2021-05-14T19:16:52Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\nWhen removing support for a version:\r\n\r\n- The first step is to progressively\r\n  remove the version from Fully-Deployed Versions on all server instances. Once\r\n  it has been removed on all server instances, operators wait for at least one\r\n  minute to allow any in-flight Version Negotiation packets to arrive.\r\n - Next, progressively remove the version from Negotiated\r\n  Versions on all server instances. Once complete, operators wait for at least\r\n  another minute.\r\n- Finally, progressively remove support for\r\n  the version from all server instances. That step updates the Supported\r\n  Versions.\r\n```\r\n...and the same down here.",
              "createdAt": "2021-05-14T19:17:17Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 95,
              "body": "Nit:  Supported Version doesn't contain a list -- it contains a single version and repeats as many times as necessary to convey the list.\r\n\r\n```suggestion\r\nNegotiation packet. This packet SHALL include each entry from the server's\r\nset of Negotiated Versions (see {{server-fleet}}) in a Supported Version\r\nfield. The\r\n```",
              "createdAt": "2021-05-14T19:20:54Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 108,
              "body": "Capitalizing this suggests it's referring to the structure, but it's the information within that's relevant.\r\n```suggestion\r\ninformation (see {{vers-info}}) used to ensure that VN was genuine,\r\n```",
              "createdAt": "2021-05-14T19:29:06Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 119,
              "body": "```suggestion\r\nit can extract the client's Version Information structure (see {{vers-info}}). This\r\n```",
              "createdAt": "2021-05-14T19:29:32Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\ncontents of Version Information are shown below (using the notation from\r\n{{Section 1.3 of QUIC}}):\r\n```",
              "createdAt": "2021-05-14T19:31:54Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            },
            {
              "originalPosition": 246,
              "body": "```suggestion\r\nexercise version negotiation (see {{Section 15 of QUIC}}), and will\r\n```",
              "createdAt": "2021-05-14T19:34:31Z",
              "updatedAt": "2021-05-14T19:40:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMTU5MDM1",
          "commit": {
            "abbreviatedOid": "48ca26d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-14T19:55:19Z",
          "updatedAt": "2021-05-14T20:06:30Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "I prefer to use section names for unpublished documents. We can change that once RFC 9000 ships.",
              "createdAt": "2021-05-14T19:55:19Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 142,
              "body": "I prefer to use section names for unpublished documents. We can change that once RFC 9000 ships.",
              "createdAt": "2021-05-14T19:55:34Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 31,
              "body": "Fixed",
              "createdAt": "2021-05-14T19:57:40Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 53,
              "body": "Fixed",
              "createdAt": "2021-05-14T20:00:34Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 63,
              "body": "Fixed",
              "createdAt": "2021-05-14T20:00:41Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 95,
              "body": "Fixed.",
              "createdAt": "2021-05-14T20:01:01Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 108,
              "body": "Fixed",
              "createdAt": "2021-05-14T20:03:24Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            },
            {
              "originalPosition": 119,
              "body": "Fixed",
              "createdAt": "2021-05-14T20:03:50Z",
              "updatedAt": "2021-05-14T20:06:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTUyMjcz",
          "commit": {
            "abbreviatedOid": "6a0901f"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T22:25:07Z",
          "updatedAt": "2021-05-20T22:36:47Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Nit: I would call this \"acceptable\"",
              "createdAt": "2021-05-20T22:25:07Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            },
            {
              "originalPosition": 16,
              "body": "And I would call this \"offered versions\"",
              "createdAt": "2021-05-20T22:25:27Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            },
            {
              "originalPosition": 55,
              "body": "This should be phrased in terms of MSL.",
              "createdAt": "2021-05-20T22:26:43Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            },
            {
              "originalPosition": 65,
              "body": "What does this mean operationally. Fully-Deployed is defined as being across all the servers.",
              "createdAt": "2021-05-20T22:28:14Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            },
            {
              "originalPosition": 312,
              "body": "Doesn't this mean you can't do incompatible VN when you offer VN=1? ",
              "createdAt": "2021-05-20T22:31:40Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            },
            {
              "originalPosition": 319,
              "body": "```suggestion\r\nchecks fail, the client MUST close the connection. If the connection was\r\n```",
              "createdAt": "2021-05-20T22:32:31Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            },
            {
              "originalPosition": 322,
              "body": "Why?",
              "createdAt": "2021-05-20T22:33:53Z",
              "updatedAt": "2021-05-20T22:36:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTY5NTEx",
          "commit": {
            "abbreviatedOid": "66cf75c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T23:01:34Z",
          "updatedAt": "2021-05-20T23:02:35Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "The moment you remove it from the list it means that server no longer sends it in the TP.",
              "createdAt": "2021-05-20T23:01:34Z",
              "updatedAt": "2021-05-20T23:02:35Z"
            },
            {
              "originalPosition": 312,
              "body": "Clarified this by using a semi-colon.",
              "createdAt": "2021-05-20T23:02:13Z",
              "updatedAt": "2021-05-20T23:02:35Z"
            },
            {
              "originalPosition": 322,
              "body": "Is it unclear? Can you suggest text?",
              "createdAt": "2021-05-20T23:02:28Z",
              "updatedAt": "2021-05-20T23:02:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTcwNjMz",
          "commit": {
            "abbreviatedOid": "66cf75c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T23:04:07Z",
          "updatedAt": "2021-05-20T23:04:07Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "How is that different from removal from Negotiated versions",
              "createdAt": "2021-05-20T23:04:07Z",
              "updatedAt": "2021-05-20T23:04:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTcxNTc3",
          "commit": {
            "abbreviatedOid": "66cf75c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T23:06:39Z",
          "updatedAt": "2021-05-20T23:06:40Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "```suggestion\r\nthe endpoint MUST close the connection with a version-specific error; if the connection was using QUIC\r\nversion 1, that error MUST be `TRANSPORT_PARAMETER_ERROR`.\r\n```",
              "createdAt": "2021-05-20T23:06:39Z",
              "updatedAt": "2021-05-20T23:06:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTcxODQz",
          "commit": {
            "abbreviatedOid": "66cf75c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T23:07:22Z",
          "updatedAt": "2021-05-20T23:07:22Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Negotiated Versions is sent in VN packets, these are sent in the TP. They're different.",
              "createdAt": "2021-05-20T23:07:22Z",
              "updatedAt": "2021-05-20T23:07:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTcyMTAw",
          "commit": {
            "abbreviatedOid": "66cf75c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T23:08:00Z",
          "updatedAt": "2021-05-20T23:08:00Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "This too is about the binding of \"This\". In this case, it's closing the connection that prevents the VN packets forcing a downgrade. I think the text I proposed above would work.",
              "createdAt": "2021-05-20T23:08:00Z",
              "updatedAt": "2021-05-20T23:08:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU0NDA1ODU5",
      "title": "Allow interop with non-supporting endpoints",
      "url": "https://github.com/quicwg/version-negotiation/pull/46",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #40.",
      "createdAt": "2021-05-27T01:53:52Z",
      "updatedAt": "2021-05-27T01:54:33Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "master",
      "baseRefOid": "cfbf40c2e6e1346e2bf4700e81fcb93a6e6960de",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "no_support",
      "headRefOid": "b21da006c19bd44ec90d050d03b4d0ffa579c9bc",
      "closedAt": "2021-05-27T01:54:33Z",
      "mergedAt": "2021-05-27T01:54:32Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "503221347efae08fac0b78e0b8aad69829bdde0e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkxMjI0NjY2",
      "title": "Remove redundant attribute",
      "url": "https://github.com/quicwg/version-negotiation/pull/48",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "kramdown supports both, but having both just causes warnings",
      "createdAt": "2021-07-16T06:13:20Z",
      "updatedAt": "2021-07-16T16:44:37Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "503221347efae08fac0b78e0b8aad69829bdde0e",
      "headRepository": "martinthomson/version-negotiation",
      "headRefName": "remove-redundant-wg",
      "headRefOid": "b464907aafc83003485f952a73e17c087f6569fd",
      "closedAt": "2021-07-16T16:44:37Z",
      "mergedAt": "2021-07-16T16:44:37Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "be2061f55c1ef8c6cb88c4e1b601786a71a61f1f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA4NTc1Njc2",
          "commit": {
            "abbreviatedOid": "b464907"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-16T16:44:29Z",
          "updatedAt": "2021-07-16T16:44:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkxMjMzODM0",
      "title": "Client validation",
      "url": "https://github.com/quicwg/version-negotiation/pull/49",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "\r\n\r\nIn light of discussion in slack, the problem here is that the validation\r\nis based on the *negotiated* version.  Validation needs to be based on\r\nthe client's *selected* version.\r\n\r\nI've also moved text about validating lack of support for the original\r\nversion to the incompatible VN section, alongside a reminder to validate\r\nconnection IDs.  Security does depend on this, but the client ignores\r\nthese bad VN packets.  That provides more effective defense against\r\nattack than what was here originally.",
      "createdAt": "2021-07-16T06:34:20Z",
      "updatedAt": "2021-07-26T00:06:33Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "503221347efae08fac0b78e0b8aad69829bdde0e",
      "headRepository": "martinthomson/version-negotiation",
      "headRefName": "client-validation",
      "headRefOid": "64e22632cb8a18d46cb03cf4a8318a1be322adee",
      "closedAt": "2021-07-26T00:06:33Z",
      "mergedAt": "2021-07-26T00:06:33Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "f369534c4c7e8d3082e77480663b7c79964850d2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA4NTc2NjM2",
          "commit": {
            "abbreviatedOid": "78ddb8a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for writing this up!\r\n\r\nAlso, can you please add Anthony Rossi to the Acknowledgements since he pointed out this issue?",
          "createdAt": "2021-07-16T16:45:46Z",
          "updatedAt": "2021-07-16T16:50:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Out of curiosity, does a syntax like `{{Section 6 of !RFC8999}}` not work?",
              "createdAt": "2021-07-16T16:45:46Z",
              "updatedAt": "2021-07-16T16:50:48Z"
            },
            {
              "originalPosition": 19,
              "body": "I'm not a huge fan of repeating normative statements from a normative reference. How about something non-normative that's backed up by the reference:\r\n```suggestion\r\nClients will ignore a Version Negotiation packet if it contains the original\r\n```",
              "createdAt": "2021-07-16T16:47:46Z",
              "updatedAt": "2021-07-16T16:50:48Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nreceived a Version Negotiation packet that listed the versions in the server's\r\n```",
              "createdAt": "2021-07-16T16:48:16Z",
              "updatedAt": "2021-07-16T16:50:48Z"
            },
            {
              "originalPosition": 39,
              "body": "This requirement only applies to clients that have reacted to a VN packet right? What validation MUST a client do if this connection didn't involve a VN packet? (in other words, why drop the \"If a client has reacted to a Version Negotiation packet,\" part?)",
              "createdAt": "2021-07-16T16:49:57Z",
              "updatedAt": "2021-07-16T16:50:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA4OTg1MTc5",
          "commit": {
            "abbreviatedOid": "78ddb8a"
          },
          "author": "anrossi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-18T03:38:04Z",
          "updatedAt": "2021-07-18T03:38:04Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Why shouldn't the client do the same validation during compatible version negotiation?",
              "createdAt": "2021-07-18T03:38:04Z",
              "updatedAt": "2021-07-18T03:38:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5MDY3Nzk3",
          "commit": {
            "abbreviatedOid": "78ddb8a"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-18T22:39:52Z",
          "updatedAt": "2021-07-18T22:39:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "It didn't when I last touched that code.",
              "createdAt": "2021-07-18T22:39:52Z",
              "updatedAt": "2021-07-18T22:39:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5MDY4MjE3",
          "commit": {
            "abbreviatedOid": "78ddb8a"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-18T22:46:01Z",
          "updatedAt": "2021-07-18T22:46:02Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "There are ways in which the two are different, so I think David is right here.\r\n\r\nLet's say that there are two groups of versions, the versions in each group compatible with each other, but incompatible with the versions in the other group.  The client prefers a version in the first group, but the client also knows that the versions in the first group are not widely implemented.  As the client doesn't like the added latency of version negotiation, it chooses the second group, which contains a version that is totally OK.  However, if it gets a Version Negotiation packet as a result, it will happily switch to the first group.\r\n\r\nSo yeah, let's go with the \"if VN\" condition.",
              "createdAt": "2021-07-18T22:46:02Z",
              "updatedAt": "2021-07-18T22:46:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTM1NTA2",
          "commit": {
            "abbreviatedOid": "870887c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks! Approved modulo two nits",
          "createdAt": "2021-07-19T20:09:52Z",
          "updatedAt": "2021-07-19T20:12:01Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nIf the client received and acted on a Version Negotiation packet, the client MUST\r\n```",
              "createdAt": "2021-07-19T20:09:52Z",
              "updatedAt": "2021-07-19T20:12:01Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nvalidate the server's `Other Versions` field.  The `Other Versions` field is\r\n```",
              "createdAt": "2021-07-19T20:10:17Z",
              "updatedAt": "2021-07-19T20:12:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjU4NTYw",
      "title": "Tweak the intro",
      "url": "https://github.com/quicwg/version-negotiation/pull/50",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The \"single round trip\" thing isn't really a guarantee given various\r\nfactors.  Setting this up as *additional* round trips is cleaner and\r\nmore accurate.  I adjusted the paragraph structure to match.\r\n\r\nCloses #29.",
      "createdAt": "2021-07-19T04:23:17Z",
      "updatedAt": "2021-07-26T00:07:08Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "be2061f55c1ef8c6cb88c4e1b601786a71a61f1f",
      "headRepository": "martinthomson/version-negotiation",
      "headRefName": "tweak-intro",
      "headRefOid": "676058a843848e34c179b3fb0986c35d2089a44c",
      "closedAt": "2021-07-26T00:07:08Z",
      "mergedAt": "2021-07-26T00:07:08Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "2b79bdcf7d03fef8baef67bfa7706e41b48c1318"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQyMzI5",
          "commit": {
            "abbreviatedOid": "676058a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, that is a lot clearer",
          "createdAt": "2021-07-19T20:18:36Z",
          "updatedAt": "2021-07-19T20:18:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjYwNDY0",
      "title": "Don't choose the oldest",
      "url": "https://github.com/quicwg/version-negotiation/pull/51",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Though it might be the oldest version that is compatible with the\r\nmost-preferred version, it isn't just \"oldest\".",
      "createdAt": "2021-07-19T04:28:53Z",
      "updatedAt": "2021-07-26T00:07:29Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "be2061f55c1ef8c6cb88c4e1b601786a71a61f1f",
      "headRepository": "martinthomson/version-negotiation",
      "headRefName": "not-oldest",
      "headRefOid": "5d02a897fcf3820df1ceba80825bb64cdfddbe23",
      "closedAt": "2021-07-26T00:07:29Z",
      "mergedAt": "2021-07-26T00:07:29Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "5f44d2d884902666895ce6a25d5f4414f048d017"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQyODAz",
          "commit": {
            "abbreviatedOid": "5d02a89"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:19:15Z",
          "updatedAt": "2021-07-19T20:19:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjYzMzAy",
      "title": "Edits to Retry text",
      "url": "https://github.com/quicwg/version-negotiation/pull/52",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Retry packets have a capital R\r\n* protocols aren't \"who\"\r\n* paragraphs are good\r\n* minor edits for brevity",
      "createdAt": "2021-07-19T04:38:18Z",
      "updatedAt": "2021-07-26T00:08:26Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "be2061f55c1ef8c6cb88c4e1b601786a71a61f1f",
      "headRepository": "martinthomson/version-negotiation",
      "headRefName": "no-protocol-anthopomorphism",
      "headRefOid": "62f06fa1f2dbfb6924524830046fbb1d3d8ec1a7",
      "closedAt": "2021-07-26T00:08:26Z",
      "mergedAt": "2021-07-26T00:08:26Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "089c0ce023d9f0d0c01c20bb2ddc8b6a00811b83"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQ0MjIz",
          "commit": {
            "abbreviatedOid": "62f06fa"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:21:03Z",
          "updatedAt": "2021-07-19T20:21:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDODoD7vc4tVjbf",
      "title": "Clarify that we will switch to permanent smaller codepoints",
      "url": "https://github.com/quicwg/version-negotiation/pull/54",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #53",
      "createdAt": "2021-10-18T15:56:38Z",
      "updatedAt": "2021-10-18T15:57:34Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "bbaf87b5cc3381a6c85e306b73a124f3e4c76b22",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "iana_note",
      "headRefOid": "cde8d1bc3bad8fef53df31db2ae12d1bacbc939a",
      "closedAt": "2021-10-18T15:57:29Z",
      "mergedAt": "2021-10-18T15:57:29Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "ed54263171b584f8305d93a1ed386623ffc3d3c8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDODoD7vc4uy5YA",
      "title": "Remove backticks",
      "url": "https://github.com/quicwg/version-negotiation/pull/56",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #44.",
      "createdAt": "2021-11-19T23:32:49Z",
      "updatedAt": "2021-11-19T23:33:31Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "380accda9b28e3836092b5846e93306c586a2d7d",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "no_backticks",
      "headRefOid": "cf64621fc50588b111de7c355af3e886218068cb",
      "closedAt": "2021-11-19T23:33:31Z",
      "mergedAt": "2021-11-19T23:33:30Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "2d04cf73b3b1d4677a6d33095f42aaf27a934001"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDODoD7vc4uy50c",
      "title": "No anthropomorphism",
      "url": "https://github.com/quicwg/version-negotiation/pull/57",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #45 ",
      "createdAt": "2021-11-19T23:39:19Z",
      "updatedAt": "2021-11-19T23:40:18Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "2d04cf73b3b1d4677a6d33095f42aaf27a934001",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "anthropomorphism",
      "headRefOid": "d0fa665bd950944b42a1888b135a1c4524519e4d",
      "closedAt": "2021-11-19T23:40:18Z",
      "mergedAt": "2021-11-19T23:40:18Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "22cfa4dc95ff6fd3cea52bfb86f87e28e13189d5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDODoD7vc4uy6Ff",
      "title": "Version Negotiation terminates a connection attempt",
      "url": "https://github.com/quicwg/version-negotiation/pull/58",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23",
      "createdAt": "2021-11-19T23:43:18Z",
      "updatedAt": "2021-11-19T23:44:18Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "22cfa4dc95ff6fd3cea52bfb86f87e28e13189d5",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "fix23",
      "headRefOid": "3bc31ecf3e1b2cd7632a44829d19ce5a9dec6d1d",
      "closedAt": "2021-11-19T23:44:17Z",
      "mergedAt": "2021-11-19T23:44:17Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "2e7ef1272befb6c888ee498e79ea8bd80f6c3676"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDODoD7vc4uy6gp",
      "title": "Error signaling is a requirement on all QUIC versions",
      "url": "https://github.com/quicwg/version-negotiation/pull/59",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #24.",
      "createdAt": "2021-11-19T23:49:32Z",
      "updatedAt": "2021-11-19T23:50:27Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "2e7ef1272befb6c888ee498e79ea8bd80f6c3676",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "all_versions_error",
      "headRefOid": "50e0c57f6e4857bd285823e36f604e129feb986d",
      "closedAt": "2021-11-19T23:50:26Z",
      "mergedAt": "2021-11-19T23:50:26Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e5ac4dcda7ecc37b332890af454d3440c2c33304"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDODoD7vc4uy7K6",
      "title": "Conversion cannot fail",
      "url": "https://github.com/quicwg/version-negotiation/pull/60",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #38.\r\nFixes #17.",
      "createdAt": "2021-11-19T23:59:53Z",
      "updatedAt": "2021-12-02T21:27:29Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "bad197d64e9ffc9ffb1526346811db874563dc0d",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "convert_fail",
      "headRefOid": "00237b279c13dff76384f3937504141fc7d25a26",
      "closedAt": "2021-12-02T21:27:28Z",
      "mergedAt": "2021-12-02T21:27:28Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c160cf3eb790a0295c2d95106b382f7facb2e1e2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDODoD7vc4uy_Eh",
      "title": "Clarify that clients only list useful compatible versions",
      "url": "https://github.com/quicwg/version-negotiation/pull/61",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #41.",
      "createdAt": "2021-11-20T01:06:45Z",
      "updatedAt": "2021-12-02T21:27:20Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "bad197d64e9ffc9ffb1526346811db874563dc0d",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "application_reqs",
      "headRefOid": "fa9bf9f98efd2b12a24a1118a382a94cad047154",
      "closedAt": "2021-12-02T21:27:20Z",
      "mergedAt": "2021-12-02T21:27:19Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "608ab29e81878d10741bf8de7779d86608ef88a3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDODoD7vc4uy_Q5",
      "title": "Remove outdated text about self-describing frames",
      "url": "https://github.com/quicwg/version-negotiation/pull/62",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #26 ",
      "createdAt": "2021-11-20T01:10:38Z",
      "updatedAt": "2021-11-20T01:11:44Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "bad197d64e9ffc9ffb1526346811db874563dc0d",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "self_describing",
      "headRefOid": "f9659bc96d651e9e7ebfe237b15d9a0525f84f4e",
      "closedAt": "2021-11-20T01:11:43Z",
      "mergedAt": "2021-11-20T01:11:43Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "7682293ca488882049c88fb65e2c61c7d5c6e885"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDODoD7vc4uy_sk",
      "title": "Clarify that Version Information is invariant but its encoding is not",
      "url": "https://github.com/quicwg/version-negotiation/pull/63",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #27 ",
      "createdAt": "2021-11-20T01:20:01Z",
      "updatedAt": "2021-12-02T21:27:13Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "7682293ca488882049c88fb65e2c61c7d5c6e885",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "invariant",
      "headRefOid": "c02bbc48cd61487860d9639ce1c01f51aff3995b",
      "closedAt": "2021-12-02T21:27:12Z",
      "mergedAt": "2021-12-02T21:27:12Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b5efb95913f62f3157902f7be24d0e9b8c90fbf5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 64,
      "id": "PR_kwDODoD7vc4uy__0",
      "title": "Soften requirement on address stability",
      "url": "https://github.com/quicwg/version-negotiation/pull/64",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18 ",
      "createdAt": "2021-11-20T01:26:40Z",
      "updatedAt": "2021-12-02T21:26:50Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "7682293ca488882049c88fb65e2c61c7d5c6e885",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "stable_address",
      "headRefOid": "1734559907a1b6ae958c43c44f935eb9272dad76",
      "closedAt": "2021-12-02T21:26:49Z",
      "mergedAt": "2021-12-02T21:26:49Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "5ba222e5e4379a0332cd3d9729a5782cc0a6b4b9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 65,
      "id": "PR_kwDODoD7vc4u1AAT",
      "title": "adding example scenarios",
      "url": "https://github.com/quicwg/version-negotiation/pull/65",
      "state": "CLOSED",
      "author": "kazu-yamamoto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This should close #55.",
      "createdAt": "2021-11-22T04:52:08Z",
      "updatedAt": "2022-04-06T03:18:59Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "7682293ca488882049c88fb65e2c61c7d5c6e885",
      "headRepository": "kazu-yamamoto/version-negotiation",
      "headRefName": "scenario-appendix",
      "headRefOid": "d40cab237caced4f9ad1bca10d2109a00ab93938",
      "closedAt": "2022-04-06T03:18:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing now that we've resolved #55 differently",
          "createdAt": "2022-04-06T03:18:58Z",
          "updatedAt": "2022-04-06T03:18:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc4wdTG-",
          "commit": {
            "abbreviatedOid": "d40cab2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-22T20:26:45Z",
          "updatedAt": "2021-11-22T20:27:29Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This example uses a greasing version, and we never specified how those are used. Should we remove that example? What purpose does this example serve?",
              "createdAt": "2021-11-22T20:26:45Z",
              "updatedAt": "2021-11-22T20:27:29Z"
            },
            {
              "originalPosition": 6,
              "body": "QUIC version 2 doesn't exist yet. Should we use a fake version for these examples?",
              "createdAt": "2021-11-22T20:27:14Z",
              "updatedAt": "2021-11-22T20:27:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDODoD7vc4u73Tc",
      "title": "Special case QUIC version 1",
      "url": "https://github.com/quicwg/version-negotiation/pull/66",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #55 ",
      "createdAt": "2021-11-24T00:04:47Z",
      "updatedAt": "2022-03-22T00:01:13Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "9eab9ebdc001742ac9d424a3fdc3c52254ca40a6",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "v1_is_special",
      "headRefOid": "421dac53c4979778651a85bf9c3fa38d7a6a4497",
      "closedAt": "2022-03-22T00:01:13Z",
      "mergedAt": "2022-03-22T00:01:12Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "93250196b571c811d9b98f22d74eb29c9dc59b6f"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that this is the right angle. Instead, I would suggest that we simply say that VN can't be used to negotiate pre-v1 versions of QUIC, which seems to achieve the same objective.\r\n",
          "createdAt": "2021-11-24T00:06:38Z",
          "updatedAt": "2021-11-24T00:06:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "It's true that you could avoid using any sort of version negotiation signaling to select a version that doesn't support this extension (with the exception of version 1).  That still leaves a client that supports a new version and version 1 without protection when it has to validate the response from a server that only supports version 1.  This change addresses the problem by saying that if you don't support this mechanism properly, then you must only support version 1.\r\n\r\nWe could *also* say that Version Negotiation packets cannot be used to select draft versions of QUIC, but I don't think that makes any real difference.\r\n\r\n",
          "createdAt": "2021-11-24T00:16:40Z",
          "updatedAt": "2021-11-24T00:16:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's true that you could avoid using any sort of version negotiation signaling to select a version that doesn't support this extension (with the exception of version 1). That still leaves a client that supports a new version and version 1 without protection when it has to validate the response from a server that only supports version 1. This change addresses the problem by saying that if you don't support this mechanism properly, then you must only support version 1.\r\n\r\nI don't think I'm following you here. If the client supports version N > 1 and 1 and the server only supports 1, then what are you trying to protect against? You can only negotiate 1.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-11-24T00:19:53Z",
          "updatedAt": "2021-11-24T00:20:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "If the client supports this specification, it is required to fail to connect in that case because the transport parameter is absent.  That's what this change is addressing.",
          "createdAt": "2021-11-24T00:21:40Z",
          "updatedAt": "2021-11-24T00:21:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, well that's a matter of interop, not protection. So, I agree some special casing is needed, but I don't think this is necessarily it. I would just say that if the parameter is not present, then you can still negotiate v1, rather than trying to pretend it sent a parameter it didn't.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-11-24T00:25:16Z",
          "updatedAt": "2021-11-24T00:25:16Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Same net effect.  Sounds like that comes down to editorial preference.",
          "createdAt": "2021-11-24T00:26:27Z",
          "updatedAt": "2021-11-24T00:26:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "...oh, I just realized that this isn't completely true.  The formulation with `1, {1}` says something more: it says that you don't support any other version.  That might be important for those cases where you might have other incompatible versions available.",
          "createdAt": "2021-11-24T00:27:56Z",
          "updatedAt": "2021-11-24T00:27:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> ...oh, I just realized that this isn't completely true. The formulation with `1, {1}` says something more: it says that you don't support any other version. That might be important for those cases where you might have other incompatible versions available.\r\n\r\nYes, and I'm proposing we don't address that case, because future versions should use this mechanism and we just want to get rid of past versions.\r\n",
          "createdAt": "2021-11-24T00:29:37Z",
          "updatedAt": "2021-11-24T00:29:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "But would it be reasonable to require that - if you implement a new version - you implement this extension for version 1?",
          "createdAt": "2021-11-24T00:30:58Z",
          "updatedAt": "2021-11-24T00:30:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think we should require that.",
          "createdAt": "2021-11-24T00:32:38Z",
          "updatedAt": "2021-11-24T00:32:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This change is consistent with that decision: if a server implements an incompatible version X, then it will be required to send `1, {1, X}`, which will allow the client to confirm that it would not have chosen X over 1.  That provides the client with protection against a downgrade to version 1 from X.  If you merely allow the client to negotiate version X, then that client gets no downgrade protection in that case.",
          "createdAt": "2021-11-24T00:38:16Z",
          "updatedAt": "2021-11-24T00:38:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As above, I propose to merely forbid negotiating any older version at all\nvia this mechanism.\n\n\nOn Tue, Nov 23, 2021 at 4:38 PM Martin Thomson ***@***.***>\nwrote:\n\n> This change is consistent with that decision: if a server implements an\n> incompatible version X, then it will be required to send 1, {1, X}, which\n> will allow the client to confirm that it would not have chosen X over 1.\n> That provides the client with protection against a downgrade to version 1\n> from X. If you merely allow the client to negotiate version X, then that\n> client gets no downgrade protection in that case.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/version-negotiation/pull/66#issuecomment-977319753>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIJXX7XASOSU4ZG7QU3UNQXYFANCNFSM5IUX3W5Q>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-11-24T16:00:12Z",
          "updatedAt": "2021-11-24T16:00:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr to clarify your position: in the scenario where\r\n- the client supports version 1, version 2, and this extension\r\n- the client supports only version 1 and not this extension\r\n- the client starts with v2\r\n- server replies with a VN packet that only contains v1\r\n- client restarts with v1 but doesn't get version_information from the server\r\n\r\nAre you suggesting that in this scenario the client should fail the handshake?",
          "createdAt": "2021-11-24T19:48:21Z",
          "updatedAt": "2021-11-24T19:48:21Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Wed, Nov 24, 2021 at 11:48 AM David Schinazi ***@***.***>\nwrote:\n\n> @ekr <https://github.com/ekr> to clarify your position: in the scenario\n> where\n>\n>    - the client supports version 1, version 2, and this extension\n>    - the client supports only version 1 and not this extension\n>\n> I assume this sentence should say \"server\"?\n\n\n>    - the client starts with v2\n>    - server replies with a VN packet that only contains v1\n>    - client restarts with v1 but doesn't get version_information from the\n>    server\n>\n> Are you suggesting that in this scenario the client should fail the\n> handshake?\n>\n\nNo. I believe this should succeed. What I believe should fail is that the\nclient supports V2, V1, and some old (preV1) draft version, and server only\nsupports that draft version and they use this extension to negotiate that.\n",
          "createdAt": "2021-11-24T20:50:09Z",
          "updatedAt": "2021-11-24T20:50:09Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "This PR is trying to fix #55 which is not the same issue which @ekr pointed out.\r\n\r\nTo fix @ekr's issue, we need another rule: this version negotiation mechanism must not be used for pre-v1 draft versions.",
          "createdAt": "2021-11-24T22:16:45Z",
          "updatedAt": "2021-11-24T22:16:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What I believe should fail is that the client supports V2, V1, and some old (preV1) draft version, and server only supports that draft version and they use this extension to negotiate that.\r\n\r\n@ekr in this scenario did the server send the version_information transport parameter?",
          "createdAt": "2021-11-29T01:47:06Z",
          "updatedAt": "2021-11-29T01:47:06Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Doesn't matter. I think we should actively forbid negotiation of pre-V1 versions, regardless of whether they implement this mechanism or not.",
          "createdAt": "2021-11-29T01:48:35Z",
          "updatedAt": "2021-11-29T01:48:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's outside the purview of this draft. Google's going to keep using Google QUIC and h3-29 until our aggregated data shows it's safe to remove support for those versions - we're not going to treat those versions different from QUICv1 until then.",
          "createdAt": "2021-11-29T01:59:47Z",
          "updatedAt": "2021-11-29T01:59:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not even remotely outside of the purview of this draft. For example, RFC 8996 forbids negotiating TLS 1.0. \r\n\r\nAs for what Google chooses to do or not to do, as is often said, there are no protocol police. But that doesn't really have that much to do with whether the IETF should endorse removing these versions.\r\n\r\nRegardless, I don't really see what the issue is here: presumably the problem is old *clients*, who will not be implementing this draft in any case, so you can simply accept them as a server, but not do VN for them.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-11-29T02:06:05Z",
          "updatedAt": "2021-11-29T02:06:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm failing to understand how your proposal is an alternative to this PR. Consider the scenario I mentioned in https://github.com/quicwg/version-negotiation/pull/66#issuecomment-978173869 - in the current version of the draft, that scenario fails whereas with this PR that scenario succeeds. Since that scenario only involves QUICv1 and QUICv2, how are pre-QUICv1 versions relevant?",
          "createdAt": "2021-11-29T02:11:16Z",
          "updatedAt": "2021-11-29T02:11:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll write something up in more detail.",
          "createdAt": "2021-11-29T02:31:39Z",
          "updatedAt": "2021-11-29T02:31:39Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "@ekr Gentle ping.",
          "createdAt": "2021-12-03T01:45:26Z",
          "updatedAt": "2021-12-03T01:45:26Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "I have implemented this PR feature in my client and confirmed that the backward compatibility is maintained.",
          "createdAt": "2021-12-08T23:44:10Z",
          "updatedAt": "2021-12-08T23:44:10Z"
        },
        {
          "author": "kazu-yamamoto",
          "authorAssociation": "NONE",
          "body": "@ekr Would you write up?",
          "createdAt": "2022-01-17T02:31:57Z",
          "updatedAt": "2022-01-17T02:31:57Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see why this is a special case for QUICv1. It should apply to all single-version servers.\r\n\r\nI thought our position was that any multiple-version endpoint needs to support the VN draft. If a server was e.g. v2 only for some silly reason, it could omit the TP with no risk of downgrade. The client should interpret lack of the TP as a single-version server, whether it's v1 or not.\r\n\r\nThe alternative is to make the TP mandatory for all non-v1 servers. I could edit the v2 draft accordingly if that's the consensus.",
          "createdAt": "2022-03-07T18:10:27Z",
          "updatedAt": "2022-03-07T18:10:27Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"it could omit the TP with no risk of downgrade\" is not correct. You can have an attack where the client thinks it's speaking one version and the server is thinking it's speaking another version because an attacker is rewriting packets as they flow by. This can't happen with v1 vs v2 because we changed the TLS HKDF labels but it's a risk in general. Keeping the Chosen Version in the transport parameters avoids this attack and simplifies security analysis",
          "createdAt": "2022-03-07T19:19:06Z",
          "updatedAt": "2022-03-07T19:19:06Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"it could omit the TP with no risk of downgrade\" is not correct. You can have an attack where the client thinks it's speaking one version and the server is thinking it's speaking another version because an attacker is rewriting packets as they flow by. This can't happen with v1 vs v2 because we changed the TLS HKDF labels but it's a risk in general. Keeping the Chosen Version in the transport parameters avoids this attack and simplifies security analysis\r\n\r\nDoesn't that collapse once the Version field is properly authenticated?\r\n\r\nAnd anyway 9001 says we SHOULD roll new labels for each version, FWIW",
          "createdAt": "2022-03-07T19:22:11Z",
          "updatedAt": "2022-03-07T19:22:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Doesn't that collapse once the Version field is properly authenticated?\r\n\r\nThe Version field is not authenticated if it's not in the TLS transcript.\r\n\r\n> And anyway 9001 says we SHOULD roll new labels for each version, FWIW\r\n\r\nThat doesn't apply to non-TLS versions\r\n\r\n",
          "createdAt": "2022-03-07T19:54:19Z",
          "updatedAt": "2022-03-07T19:54:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc42nUad",
          "commit": {
            "abbreviatedOid": "0f1748c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-21T19:46:55Z",
          "updatedAt": "2022-03-21T19:46:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ncontaining exactly one version set to 0x00000001. This allows version\r\nnegotiation to work with servers that only support QUIC version 1, while\r\npreventing downgrade attacks against servers that support QUIC version 1 and\r\nearlier versions.\r\n```\r\n```suggestion\r\ncontaining exactly one version set to 0x00000001. This allows version\r\nnegotiation to work with servers that only support QUIC version 1. Note\r\nthat implementations which wish to use VN to negotiate versions other\r\nthan QUIC version 1 will need to implement this draft.\r\n```\r\n\r\nI believe this is more correct.\r\n\r\nMy preferred text would actually be phrased differently, which is to say:\r\n\"from the server's transport parameters, then the client SHALL omit\r\nthe checks specified in Section XXX\". I believe this has the same impact\r\nbut is less prescriptive about the details. However, @martinthomson's comments\r\nconvinced me that this is just a matter of spelling.",
              "createdAt": "2022-03-21T19:46:55Z",
              "updatedAt": "2022-03-21T19:46:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc42nUab",
          "commit": {
            "abbreviatedOid": "0f1748c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-21T19:46:55Z",
          "updatedAt": "2022-03-21T19:46:58Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ncontaining exactly one version set to 0x00000001. This allows version\r\nnegotiation to work with servers that only support QUIC version 1, while\r\npreventing downgrade attacks against servers that support QUIC version 1 and\r\nearlier versions.\r\n```\r\n```suggestion\r\ncontaining exactly one version set to 0x00000001. This allows version\r\nnegotiation to work with servers that only support QUIC version 1. Note\r\nthat implementations which wish to use VN to negotiate versions other\r\nthan QUIC version 1 will need to implement this draft.\r\n```\r\n\r\nI believe this is more correct.\r\n\r\nMy preferred text would actually be phrased differently, which is to say:\r\n\"from the server's transport parameters, then the client SHALL omit\r\nthe checks specified in Section XXX\". I believe this has the same impact\r\nbut is less prescriptive about the details. However, @martinthomson's comments\r\nconvinced me that this is just a matter of spelling.",
              "createdAt": "2022-03-21T19:46:55Z",
              "updatedAt": "2022-03-21T19:46:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc42oHXx",
          "commit": {
            "abbreviatedOid": "0f1748c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-21T23:47:41Z",
          "updatedAt": "2022-03-21T23:47:41Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thanks. Committed that suggestion for now, happy to tweak editorial details later",
              "createdAt": "2022-03-21T23:47:41Z",
              "updatedAt": "2022-03-21T23:47:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDODoD7vc4vOMUJ",
      "title": "Clarify other versions empty",
      "url": "https://github.com/quicwg/version-negotiation/pull/71",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #69",
      "createdAt": "2021-12-01T02:35:28Z",
      "updatedAt": "2021-12-02T21:26:16Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "7682293ca488882049c88fb65e2c61c7d5c6e885",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "may_be_empty",
      "headRefOid": "310a9e5ab229f074daada6367aa98f04d773fca9",
      "closedAt": "2021-12-02T21:26:15Z",
      "mergedAt": "2021-12-02T21:26:15Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b6bdcee9db29a9a94ee6787895309556c681d375"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 75,
      "id": "PR_kwDODoD7vc4vVTOR",
      "title": "Clarify that VN validation fails if server other versions are empty",
      "url": "https://github.com/quicwg/version-negotiation/pull/75",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #73.",
      "createdAt": "2021-12-02T22:15:18Z",
      "updatedAt": "2022-03-05T00:50:38Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "c160cf3eb790a0295c2d95106b382f7facb2e1e2",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "clarify_empty_server_other_validation",
      "headRefOid": "fac23376fb9f6ecd7192cfebf3c32506ea51e1c8",
      "closedAt": "2022-03-05T00:50:38Z",
      "mergedAt": "2022-03-05T00:50:38Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "074b51ca456b8dadc5bf4f37956f830cd5e6cef0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 82,
      "id": "PR_kwDODoD7vc4z93WZ",
      "title": "Clarify minimum levels of compliance",
      "url": "https://github.com/quicwg/version-negotiation/pull/82",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #80 ",
      "createdAt": "2022-03-04T17:13:52Z",
      "updatedAt": "2022-03-07T19:57:20Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "c160cf3eb790a0295c2d95106b382f7facb2e1e2",
      "headRepository": "martinduke/version-negotiation",
      "headRefName": "min-support",
      "headRefOid": "c28178bb4903b7a21ca99d91b69d8930d87cfd30",
      "closedAt": "2022-03-07T19:57:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm not 100% sure what you wanted in some cases, but I addressed all your comments.",
          "createdAt": "2022-03-04T21:33:48Z",
          "updatedAt": "2022-03-04T21:33:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing  -- authors preferred #83 to this one",
          "createdAt": "2022-03-07T19:57:19Z",
          "updatedAt": "2022-03-07T19:57:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc41rcrs",
          "commit": {
            "abbreviatedOid": "fbb2958"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-04T18:42:12Z",
          "updatedAt": "2022-03-04T18:47:20Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "nit: add reference to that section",
              "createdAt": "2022-03-04T18:42:13Z",
              "updatedAt": "2022-03-04T18:47:20Z"
            },
            {
              "originalPosition": 22,
              "body": "similarly, add reference",
              "createdAt": "2022-03-04T18:42:38Z",
              "updatedAt": "2022-03-04T18:47:20Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\ncompatible version in the transport parameter.\r\n```",
              "createdAt": "2022-03-04T18:43:57Z",
              "updatedAt": "2022-03-04T18:47:20Z"
            },
            {
              "originalPosition": 15,
              "body": "I feel like this just repeats the requirements from the downgrade section. Do we need it?",
              "createdAt": "2022-03-04T18:44:47Z",
              "updatedAt": "2022-03-04T18:47:20Z"
            },
            {
              "originalPosition": 34,
              "body": "nit: use bullets",
              "createdAt": "2022-03-04T18:45:16Z",
              "updatedAt": "2022-03-04T18:47:20Z"
            },
            {
              "originalPosition": 6,
              "body": "I think we should expand on this to explain why it might be desirable to only partially support this spec",
              "createdAt": "2022-03-04T18:47:12Z",
              "updatedAt": "2022-03-04T18:47:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41sBFl",
          "commit": {
            "abbreviatedOid": "fbb2958"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-04T21:20:43Z",
          "updatedAt": "2022-03-04T21:20:44Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Struggled with the commutative property here, thanks.",
              "createdAt": "2022-03-04T21:20:44Z",
              "updatedAt": "2022-03-04T21:20:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41vvAq",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't quite understand the point of this section, but generally, I think most of the normative language should not be here.",
          "createdAt": "2022-03-07T13:45:03Z",
          "updatedAt": "2022-03-07T13:46:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm not sure I understand this text.\r\n\r\nIf you're talking about retransmission, srvers generally won't retransmit at this phase because of amplification limits, so clients need to retransmit INITIAL generally. If you're talking about the server deliberately suppressing transmission in response to repeated INITIALs, that seems like a bad idea because then you need to keep state. \r\n\r\nIs this a suggestion or a description of existing behavior?",
              "createdAt": "2022-03-07T13:45:03Z",
              "updatedAt": "2022-03-07T13:46:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41vwWw",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T13:49:35Z",
          "updatedAt": "2022-03-07T13:50:00Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I would rewrite this almost entirely non-normatively by describing what is technically possible.\r\n\r\nE.g.,\r\n\r\nIt is possible to implement only VN or compatible version negotiation. Servers which implement only compatible version negotiation will not be able to interoperate with clients which send compatible Initial values. Servers which implement only VN will not be able to select between multiple acceptable versions [I think this is true.]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2022-03-07T13:49:35Z",
              "updatedAt": "2022-03-07T13:50:00Z"
            },
            {
              "originalPosition": 32,
              "body": "Isn't this stuff required elsewhere.",
              "createdAt": "2022-03-07T13:49:53Z",
              "updatedAt": "2022-03-07T13:50:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41wNe5",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:14:04Z",
          "updatedAt": "2022-03-07T15:14:05Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "It's a summary of Sec 6.1 of RFC9000. The usual case would be an INITIAL with 0RTT packets -- if the server can recognize the packet type, it can limit the number of packets to 1 statelessly.  But one can certainly imagine some sort of global state saying \"I am under DoS attack, stop sending VN\". \r\n\r\nThe important thing this paragraph is saying is reminding the reader that other RFCs say that you might get a VN packet, but you might not. I'm happy to get a suggested rewording.",
              "createdAt": "2022-03-07T15:14:05Z",
              "updatedAt": "2022-03-07T15:14:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41wQmH",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:22:58Z",
          "updatedAt": "2022-03-07T15:22:58Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "OK",
              "createdAt": "2022-03-07T15:22:58Z",
              "updatedAt": "2022-03-07T15:22:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41wSnM",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:28:42Z",
          "updatedAt": "2022-03-07T15:28:42Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "If so, I can't find it, but if one reads and fully understands the doc it's an unavoidable conclusion.I thought it would be useful to make it explicit",
              "createdAt": "2022-03-07T15:28:42Z",
              "updatedAt": "2022-03-07T15:28:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41wTio",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:31:16Z",
          "updatedAt": "2022-03-07T15:31:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Well, the server is free to not respond to *any* message it wants. What's unique about VN.",
              "createdAt": "2022-03-07T15:31:17Z",
              "updatedAt": "2022-03-07T15:31:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41wT2v",
          "commit": {
            "abbreviatedOid": "c28178b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:32:11Z",
          "updatedAt": "2022-03-07T15:32:11Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "OK, I guess for now it can go here, but I think generally it should go elsewhere.\r\n",
              "createdAt": "2022-03-07T15:32:11Z",
              "updatedAt": "2022-03-07T15:32:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDODoD7vc40DPdD",
      "title": "min support, but much much shorter",
      "url": "https://github.com/quicwg/version-negotiation/pull/83",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #80 \r\n\r\nAfter pushback from @ekr, I think this covers the main point with a whole lot less text.",
      "createdAt": "2022-03-07T15:44:02Z",
      "updatedAt": "2022-03-07T19:55:02Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "074b51ca456b8dadc5bf4f37956f830cd5e6cef0",
      "headRepository": "martinduke/version-negotiation",
      "headRefName": "smaller-min-support",
      "headRefOid": "2156c8e8b08612c2872a8b9b2745bef521f7ec04",
      "closedAt": "2022-03-07T19:55:02Z",
      "mergedAt": "2022-03-07T19:55:02Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "747aca0c8aa59a76ccdfdfaadecf064d7e81c66c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc41wYgA",
          "commit": {
            "abbreviatedOid": "6379bc7"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-03-07T15:45:18Z",
          "updatedAt": "2022-03-07T15:45:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc41xX3m",
          "commit": {
            "abbreviatedOid": "6379bc7"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T19:10:12Z",
          "updatedAt": "2022-03-07T19:10:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Omitting the transport parameter removes the version from the TLS transcript which weakens security. I would instead:\r\n```suggestion\r\nonly including the Chosen Version in the Other Versions field of the Version\r\nInformation Transport Parameter.\r\n```",
              "createdAt": "2022-03-07T19:10:12Z",
              "updatedAt": "2022-03-07T19:10:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41xjT2",
          "commit": {
            "abbreviatedOid": "2156c8e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T19:54:56Z",
          "updatedAt": "2022-03-07T19:54:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "PR_kwDODoD7vc40D3qy",
      "title": "Consider 0RTT in definition of compatible.",
      "url": "https://github.com/quicwg/version-negotiation/pull/84",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #77\r\n\r\nThis is @DavidSchinazi 's proposed text to fix this issue.",
      "createdAt": "2022-03-07T18:30:00Z",
      "updatedAt": "2022-03-07T19:07:36Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "074b51ca456b8dadc5bf4f37956f830cd5e6cef0",
      "headRepository": "martinduke/version-negotiation",
      "headRefName": "compatible-def",
      "headRefOid": "c5ab54182e88b853ba3151a9cb7be29e1a845e3f",
      "closedAt": "2022-03-07T18:33:53Z",
      "mergedAt": "2022-03-07T18:33:52Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "06c464a6fefb341de2af14fc163e4cb27bcc7cee"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM. I am going to merge this on the basis of it being David's text and my approval.",
          "createdAt": "2022-03-07T18:32:52Z",
          "updatedAt": "2022-03-07T18:32:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2022-03-07T19:07:36Z",
          "updatedAt": "2022-03-07T19:07:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 85,
      "id": "PR_kwDODoD7vc40EfiT",
      "title": "clarify handling of multiple ALPNs",
      "url": "https://github.com/quicwg/version-negotiation/pull/85",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #81\r\n\r\nMix recommendations of @MikeBishop and @DavidSchinazi ",
      "createdAt": "2022-03-07T21:52:54Z",
      "updatedAt": "2022-03-07T22:06:05Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "747aca0c8aa59a76ccdfdfaadecf064d7e81c66c",
      "headRepository": "martinduke/version-negotiation",
      "headRefName": "single-alpn",
      "headRefOid": "cd8274e51b6ac1be93f9f4bc12e6e6aa9665732a",
      "closedAt": "2022-03-07T22:06:05Z",
      "mergedAt": "2022-03-07T22:06:04Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "fafe7bdbc94957e65f04b323906f9e232c6374fb"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2022-03-07T21:59:23Z",
          "updatedAt": "2022-03-07T21:59:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc41yCOo",
          "commit": {
            "abbreviatedOid": "cd8274e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T22:05:59Z",
          "updatedAt": "2022-03-07T22:05:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDODoD7vc40Emzw",
      "title": "handle TP with version = 0",
      "url": "https://github.com/quicwg/version-negotiation/pull/86",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #76.",
      "createdAt": "2022-03-07T22:31:39Z",
      "updatedAt": "2022-03-07T23:14:50Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "57b0b1eeaaf54ed3b1c7814db1699d1546f4de7f",
      "headRepository": "martinduke/version-negotiation",
      "headRefName": "version-zero",
      "headRefOid": "ca1f28ade02a13f2742c46900d6bda8ff1e8d498",
      "closedAt": "2022-03-07T23:14:50Z",
      "mergedAt": "2022-03-07T23:14:50Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c7e1c384c047530fb1a6968cf97833b5d428ad0a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc41yPLm",
          "commit": {
            "abbreviatedOid": "8283766"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T23:04:44Z",
          "updatedAt": "2022-03-07T23:04:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't like this difference between client and server. How about instead you add this to paragraph below that starts with `Both endpoints MUST parse...`:\r\n\r\n`If an endpoint receives a Chosen Version equal to zero, or any Other Version equal to zero, it MUST treat it as a parsing failure.`",
              "createdAt": "2022-03-07T23:04:44Z",
              "updatedAt": "2022-03-07T23:05:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc41yQ3U",
          "commit": {
            "abbreviatedOid": "ca1f28a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T23:14:46Z",
          "updatedAt": "2022-03-07T23:14:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDODoD7vc40EqOE",
      "title": "Clarify negotiated version",
      "url": "https://github.com/quicwg/version-negotiation/pull/87",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #67 \r\nFixes #72 \r\nFixes #79 ",
      "createdAt": "2022-03-07T22:48:42Z",
      "updatedAt": "2022-03-07T23:08:51Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "57b0b1eeaaf54ed3b1c7814db1699d1546f4de7f",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "clarify_negotiated_version",
      "headRefOid": "b2e5ebefd313b45ae2575f6cf17e8344b8a36ae5",
      "closedAt": "2022-03-07T23:08:05Z",
      "mergedAt": "2022-03-07T23:08:04Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "84f9a97b86be75682bb43aadff90a783a1cd9e7a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc41yNVs",
          "commit": {
            "abbreviatedOid": "b2e5ebe"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-03-07T22:54:24Z",
          "updatedAt": "2022-03-07T22:54:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDODoD7vc40Ewpj",
      "title": "Tweak QUICv1 compatibility requirements",
      "url": "https://github.com/quicwg/version-negotiation/pull/88",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #25 \r\nFixes #68 \r\nFixes #78 ",
      "createdAt": "2022-03-07T23:27:43Z",
      "updatedAt": "2022-03-07T23:28:34Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "c7e1c384c047530fb1a6968cf97833b5d428ad0a",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "refactor_quicv1",
      "headRefOid": "1bb184e905573dbab397f3c54f7c88594085aa40",
      "closedAt": "2022-03-07T23:28:33Z",
      "mergedAt": "2022-03-07T23:28:33Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "12e976eea9a5d539df5e333c0462c7efca6d0dfe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "PR_kwDODoD7vc40EyCa",
      "title": "Reorder sections",
      "url": "https://github.com/quicwg/version-negotiation/pull/89",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #47 ",
      "createdAt": "2022-03-07T23:37:23Z",
      "updatedAt": "2022-03-07T23:38:11Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "12e976eea9a5d539df5e333c0462c7efca6d0dfe",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "reorder_sections",
      "headRefOid": "639231ca42f969e855c26ada25f76a84253b4d01",
      "closedAt": "2022-03-07T23:38:10Z",
      "mergedAt": "2022-03-07T23:38:10Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c09f9980b3cbf844a31e1595b5e3c647109a60eb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 99,
      "id": "PR_kwDODoD7vc41rMEq",
      "title": "Editorial PR for MT issue 98",
      "url": "https://github.com/quicwg/version-negotiation/pull/99",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #98 ",
      "createdAt": "2022-04-05T17:11:49Z",
      "updatedAt": "2022-04-05T17:12:16Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "4796ddb72321d4192e347b149c1563671f1163b0",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "editorial98",
      "headRefOid": "fd3e3c4af1b5a875647aa87588f6af42b2e5f234",
      "closedAt": "2022-04-05T17:12:15Z",
      "mergedAt": "2022-04-05T17:12:15Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c4fc6210bffd7b1387e867bc1ee241d2adbf8e09"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDODoD7vc41rThh",
      "title": "Add ALPN Considerations",
      "url": "https://github.com/quicwg/version-negotiation/pull/100",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #92 ",
      "createdAt": "2022-04-05T17:43:36Z",
      "updatedAt": "2022-04-05T17:58:26Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "c4fc6210bffd7b1387e867bc1ee241d2adbf8e09",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "alpn92",
      "headRefOid": "0609a7f92d60b25fcbe459229b862213851cf640",
      "closedAt": "2022-04-05T17:58:25Z",
      "mergedAt": "2022-04-05T17:58:25Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "1a323533d1f8d1cb79f044891ec8b6a9cafd7276"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc43kbXq",
          "commit": {
            "abbreviatedOid": "850273b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-05T17:52:18Z",
          "updatedAt": "2022-04-05T17:52:18Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```\r\nNote: it is possible for clients to send some ALPNs which may not be compatible with some of their\r\noffered versions. It is the server's responsibility to only select ALPN/version combinations which\r\nmeet the above criteria.\r\n```",
              "createdAt": "2022-04-05T17:52:18Z",
              "updatedAt": "2022-04-05T17:52:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc43kbe9",
          "commit": {
            "abbreviatedOid": "9b4ad7b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2022-04-05T17:52:44Z",
          "updatedAt": "2022-04-05T17:52:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDODoD7vc41rXb2",
      "title": "Clarify directionality",
      "url": "https://github.com/quicwg/version-negotiation/pull/101",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #93 ",
      "createdAt": "2022-04-05T18:03:58Z",
      "updatedAt": "2022-04-05T18:19:59Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "1a323533d1f8d1cb79f044891ec8b6a9cafd7276",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "compatible_editorial",
      "headRefOid": "895722e7b8524680f0ce1f8f7b1c46aff57a3369",
      "closedAt": "2022-04-05T18:19:59Z",
      "mergedAt": "2022-04-05T18:19:58Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "b4a75f32541ec4c98727f5597b1e9630eed2a91a"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM.\r\n",
          "createdAt": "2022-04-05T18:19:54Z",
          "updatedAt": "2022-04-05T18:19:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 102,
      "id": "PR_kwDODoD7vc41rX6S",
      "title": "Implementaion leeway for 2 connections",
      "url": "https://github.com/quicwg/version-negotiation/pull/102",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #95.",
      "createdAt": "2022-04-05T18:06:29Z",
      "updatedAt": "2022-04-05T18:36:41Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "1a323533d1f8d1cb79f044891ec8b6a9cafd7276",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "2connections",
      "headRefOid": "ec3059d2f9f0a9572e8c61d6ce38f33c52fc6e98",
      "closedAt": "2022-04-05T18:36:40Z",
      "mergedAt": "2022-04-05T18:36:39Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e4e0bc8ae539729f385897a76d9a03b5bd44ea1a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc43kjlK",
          "commit": {
            "abbreviatedOid": "fe38859"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-05T18:22:31Z",
          "updatedAt": "2022-04-05T18:35:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nto internally use two distinct connection objects.\r\n```",
              "createdAt": "2022-04-05T18:22:31Z",
              "updatedAt": "2022-04-05T18:35:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 103,
      "id": "PR_kwDODoD7vc41rY11",
      "title": "Clarify client choice",
      "url": "https://github.com/quicwg/version-negotiation/pull/103",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #96 ",
      "createdAt": "2022-04-05T18:11:11Z",
      "updatedAt": "2022-04-05T18:34:54Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "1a323533d1f8d1cb79f044891ec8b6a9cafd7276",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "client_choice",
      "headRefOid": "bbb2a4813987ffeca6be84db955a4e672f7f96f4",
      "closedAt": "2022-04-05T18:34:54Z",
      "mergedAt": "2022-04-05T18:34:53Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "36254b3cd206c3d0ec7eae49158338543b25f405"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc43kjCT",
          "commit": {
            "abbreviatedOid": "f1bd84b"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM with the following edits.",
          "createdAt": "2022-04-05T18:20:27Z",
          "updatedAt": "2022-04-05T18:20:58Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\noriginal version to maximize the combined probability that both:\r\n```",
              "createdAt": "2022-04-05T18:20:28Z",
              "updatedAt": "2022-04-05T18:20:58Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n* The original version is compatible with the client's preferred version.\r\n```",
              "createdAt": "2022-04-05T18:20:43Z",
              "updatedAt": "2022-04-05T18:20:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDODoD7vc41raKK",
      "title": "Clarify compatible",
      "url": "https://github.com/quicwg/version-negotiation/pull/104",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #90 \r\nFixes #94 ",
      "createdAt": "2022-04-05T18:17:26Z",
      "updatedAt": "2022-04-06T14:18:55Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "1a323533d1f8d1cb79f044891ec8b6a9cafd7276",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "clarify_compatible",
      "headRefOid": "cd066ed7550c39ddbd43067064b69372d5339a30",
      "closedAt": "2022-04-05T18:39:34Z",
      "mergedAt": "2022-04-05T18:39:34Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "017c1bea378b52629bfc92deb874f81ad04ac172"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc43kkkq",
          "commit": {
            "abbreviatedOid": "5944145"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good",
          "createdAt": "2022-04-05T18:25:16Z",
          "updatedAt": "2022-04-05T18:33:42Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "supported by ... ?",
              "createdAt": "2022-04-05T18:25:16Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\ngiven QUIC connection as the \"client's chosen version\".\r\n```",
              "createdAt": "2022-04-05T18:25:47Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nclient to initiate a new connection with a different version.\r\n```",
              "createdAt": "2022-04-05T18:26:27Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 66,
              "body": "can we say A and B instead of 1 and 2?",
              "createdAt": "2022-04-05T18:26:42Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nIn order to perform compatible version negotiation, the server MUST select\r\n```",
              "createdAt": "2022-04-05T18:27:31Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 116,
              "body": "this is backwards. the client's chosen version needs to be compatible with the selected version not the other way around",
              "createdAt": "2022-04-05T18:29:29Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nthe identity transform. If the first flight is correctly formatted,\r\n```",
              "createdAt": "2022-04-05T18:29:56Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            },
            {
              "originalPosition": 127,
              "body": "That's QUICv1-specific. Let's just say abort the handshake",
              "createdAt": "2022-04-05T18:30:50Z",
              "updatedAt": "2022-04-05T18:33:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc43koVs",
          "commit": {
            "abbreviatedOid": "cd066ed"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-05T18:39:29Z",
          "updatedAt": "2022-04-05T18:39:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc43l0zc",
          "commit": {
            "abbreviatedOid": "cd066ed"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-06T00:29:04Z",
          "updatedAt": "2022-04-06T00:29:14Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Want to show Other Versions here too?\r\n\r\nFun fact: that list could include B and E.",
              "createdAt": "2022-04-06T00:29:04Z",
              "updatedAt": "2022-04-06T00:29:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc43l1HU",
          "commit": {
            "abbreviatedOid": "cd066ed"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-06T00:32:11Z",
          "updatedAt": "2022-04-06T00:32:11Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I feel like adding this could add more confusion than it'd help remove?",
              "createdAt": "2022-04-06T00:32:11Z",
              "updatedAt": "2022-04-06T00:32:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc43mh8P",
          "commit": {
            "abbreviatedOid": "cd066ed"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-06T05:39:34Z",
          "updatedAt": "2022-04-06T05:39:34Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Oh yes, for certain, but you might at least show that there are other versions here, so maybe \"Other Versions = (...)\".",
              "createdAt": "2022-04-06T05:39:34Z",
              "updatedAt": "2022-04-06T05:39:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc43pUPD",
          "commit": {
            "abbreviatedOid": "cd066ed"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-06T14:18:54Z",
          "updatedAt": "2022-04-06T14:18:55Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Good point, wrote up PR #105",
              "createdAt": "2022-04-06T14:18:54Z",
              "updatedAt": "2022-04-06T14:18:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDODoD7vc41vOPb",
      "title": "Tweak diagram",
      "url": "https://github.com/quicwg/version-negotiation/pull/105",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on @martinthomson 's https://github.com/quicwg/version-negotiation/pull/104#discussion_r843483908",
      "createdAt": "2022-04-06T14:18:33Z",
      "updatedAt": "2022-04-06T15:33:27Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "3328a59dd32723057a695fa3c9210318c2f987dd",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "diagram_tweak",
      "headRefOid": "376bb31e53b8ca074997ca698af1cc5c55f82f07",
      "closedAt": "2022-04-06T15:33:26Z",
      "mergedAt": "2022-04-06T15:33:26Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "f5bedc95bd3877ad13923fc4396fc220c8c8a858"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "PR_kwDODoD7vc42n2Zt",
      "title": "Editorial clarification on advertising newer versions",
      "url": "https://github.com/quicwg/version-negotiation/pull/106",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-22T12:50:49Z",
      "updatedAt": "2022-04-22T13:43:10Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "f5bedc95bd3877ad13923fc4396fc220c8c8a858",
      "headRepository": "mirjak/version-negotiation",
      "headRefName": "patch-1",
      "headRefOid": "a8fbe87df3bc470d242c69d130de0466deaa30e3",
      "closedAt": "2022-04-22T13:43:10Z",
      "mergedAt": "2022-04-22T13:43:10Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "750450bb68bd7bb0190006e98312cec61bf34f0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc44oW9Z",
          "commit": {
            "abbreviatedOid": "840bdeb"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T13:42:05Z",
          "updatedAt": "2022-04-22T13:42:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nthat the client supports, while advertising newer compatible versions in the\r\n```",
              "createdAt": "2022-04-22T13:42:06Z",
              "updatedAt": "2022-04-22T13:42:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDODoD7vc42ocdR",
      "title": "Refactor to create Definitions section",
      "url": "https://github.com/quicwg/version-negotiation/pull/107",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-22T15:27:18Z",
      "updatedAt": "2022-06-03T19:59:27Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "750450bb68bd7bb0190006e98312cec61bf34f0e",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "definitions",
      "headRefOid": "6e783249de6edc7b4b0c9d58aed2ee1872211a2a",
      "closedAt": "2022-06-03T19:59:26Z",
      "mergedAt": "2022-06-03T19:59:26Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "ef87221f331f98f30aef0a653718dbc4f5ce6ab3"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2022-06-03T19:59:22Z",
          "updatedAt": "2022-06-03T19:59:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc44o-ag",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T15:34:14Z",
          "updatedAt": "2022-04-22T15:34:15Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> spans multiple connections\r\n\r\nAre you referring to the different initial flights between incompatible version negotiation? Do we really consider that multiple connections? I don't think it's ever been referred it this way before.\r\n\r\nI think I understand what each of these terms mean, or at least what you're trying to define them as, but how they are worded here actually confuses me more.",
              "createdAt": "2022-04-22T15:34:14Z",
              "updatedAt": "2022-04-22T15:34:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc44pS_B",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T16:51:19Z",
          "updatedAt": "2022-04-22T16:51:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> Are you referring to the different initial flights between incompatible version negotiation? Do we really consider that multiple connections? I don't think it's ever been referred it this way before.\r\n\r\nYes, as described in the \"Connections and Version Negotiation\" section.\r\n\r\n> I think I understand what each of these terms mean, or at least what you're trying to define them as, but how they are worded here actually confuses me more.\r\n\r\nCan you help explain what you find confusing? It's not very actionable for us editors otherwise.",
              "createdAt": "2022-04-22T16:51:19Z",
              "updatedAt": "2022-04-22T16:51:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc44pXId",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T17:08:56Z",
          "updatedAt": "2022-04-22T17:08:56Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "AFAIU, there are not multiple connections involved here. The client is making one connection, that is going through the version negotiation process. I don't consider incompatible negotiation a new connection. When you say first flight, I believe you mean the very first flight, and then also when the client responds for an incompatible negotiation; but you that doesn't align with my understanding of this text: \"before it has heard back from the server\". If you're doing incompatible negotiation, that's after you've heard from the server.",
              "createdAt": "2022-04-22T17:08:56Z",
              "updatedAt": "2022-04-22T17:08:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc44qDs5",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T20:28:19Z",
          "updatedAt": "2022-04-22T20:28:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> AFAIU, there are not multiple connections involved here. The client is making one connection, that is going through the version negotiation process. I don't consider incompatible negotiation a new connection.\r\n\r\nIf you have thoughts on the \"Connections and Version Negotiation\" section, please take them to an issue instead of a comment thread on an editorial PR.\r\n\r\n> When you say first flight, I believe you mean the very first flight, and then also when the client responds for an incompatible negotiation; but you that doesn't align with my understanding of this text: \"before it has heard back from the server\". If you're doing incompatible negotiation, that's after you've heard from the server.\r\n\r\nI think that is covered by \"In the context of a given QUIC connection\". Am I missing something?",
              "createdAt": "2022-04-22T20:28:19Z",
              "updatedAt": "2022-04-22T20:28:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc44rihT",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-23T06:38:42Z",
          "updatedAt": "2022-04-23T06:38:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc44yEBe",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-26T02:10:19Z",
          "updatedAt": "2022-04-26T02:11:10Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "This is a little weird in that \"segment\" is a TCP concept.  You might need to acknowledge the origin of the term in order to explain that.",
              "createdAt": "2022-04-26T02:10:19Z",
              "updatedAt": "2022-04-26T02:11:10Z"
            },
            {
              "originalPosition": 25,
              "body": "A forward reference to the bit about connections and incompatible negotiation might help address some of this confusion.",
              "createdAt": "2022-04-26T02:11:06Z",
              "updatedAt": "2022-04-26T02:11:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc4415NT",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-26T16:00:29Z",
          "updatedAt": "2022-04-26T16:00:29Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Good point, added",
              "createdAt": "2022-04-26T16:00:29Z",
              "updatedAt": "2022-04-26T16:00:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc4415RC",
          "commit": {
            "abbreviatedOid": "30de387"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-26T16:00:39Z",
          "updatedAt": "2022-04-26T16:00:39Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Added a reference to 793",
              "createdAt": "2022-04-26T16:00:39Z",
              "updatedAt": "2022-04-26T16:00:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc448NSn",
          "commit": {
            "abbreviatedOid": "50994c1"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-04-27T17:40:10Z",
          "updatedAt": "2022-04-27T17:40:20Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "This should still say \"initial\" because incompatible VN is two different connections.",
              "createdAt": "2022-04-27T17:40:10Z",
              "updatedAt": "2022-04-27T17:40:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449BO-",
          "commit": {
            "abbreviatedOid": "50994c1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T20:47:13Z",
          "updatedAt": "2022-04-27T20:47:13Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "But this sentence only refers to the first connection. Maybe we need a better name that refers to the set of related connections.",
              "createdAt": "2022-04-27T20:47:13Z",
              "updatedAt": "2022-04-27T20:47:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449CnX",
          "commit": {
            "abbreviatedOid": "50994c1"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T20:53:11Z",
          "updatedAt": "2022-04-27T20:53:11Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I don't get that out of this text. \r\n\r\nThe client initiates a QUIC connection. It gets a VN. It then initiates a new QUIC connection.",
              "createdAt": "2022-04-27T20:53:11Z",
              "updatedAt": "2022-04-27T20:53:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449FI0",
          "commit": {
            "abbreviatedOid": "50994c1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:04:02Z",
          "updatedAt": "2022-04-27T21:04:02Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's only true of the first connection, see Section 4:\r\n> A client that makes a connection attempt based on information received from a Version Negotiation packet MUST ignore any Version Negotiation packets it receives in response to that connection attempt.",
              "createdAt": "2022-04-27T21:04:02Z",
              "updatedAt": "2022-04-27T21:04:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449JWg",
          "commit": {
            "abbreviatedOid": "50994c1"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:21:37Z",
          "updatedAt": "2022-04-27T21:21:38Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That statement is true, but irrelevant to this sentence.",
              "createdAt": "2022-04-27T21:21:37Z",
              "updatedAt": "2022-04-27T21:21:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449MmJ",
          "commit": {
            "abbreviatedOid": "50994c1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:37:13Z",
          "updatedAt": "2022-04-27T21:37:14Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Sure, I don't feel too strongly\r\n```suggestion\r\nThe client initiates a QUIC connection by choosing an initial version and\r\n```",
              "createdAt": "2022-04-27T21:37:13Z",
              "updatedAt": "2022-04-27T21:37:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 108,
      "id": "PR_kwDODoD7vc42odGq",
      "title": "Clarify when long header version can mismatch",
      "url": "https://github.com/quicwg/version-negotiation/pull/108",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-22T15:30:19Z",
      "updatedAt": "2022-06-03T22:14:09Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "750450bb68bd7bb0190006e98312cec61bf34f0e",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "most_cases",
      "headRefOid": "44aaf3a5238c0fa04d736b05e4192e8e919d6d39",
      "closedAt": "2022-06-03T22:14:08Z",
      "mergedAt": "2022-06-03T22:14:08Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "cddbe2f568d6066b4b09bd0a4ead332e35ea7671"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc44o-iP",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-22T15:34:39Z",
          "updatedAt": "2022-04-22T15:34:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc44riiJ",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-23T06:39:32Z",
          "updatedAt": "2022-04-23T06:39:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc448M8s",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-04-27T17:39:05Z",
          "updatedAt": "2022-04-27T17:39:10Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think this needs some work, because long header Version field *indicates* the version.\r\n\r\nPerhaps rewrite the whole thing.\r\n\r\n\"The version that the sender has chosen to use for this connection as indicated by the value of the Version field in the long header that carries this data. In most cases, these values will be the same, but future versions of QUIC might opt to mask or otherwise change the version field that appears on the wire.\"\r\n",
              "createdAt": "2022-04-27T17:39:05Z",
              "updatedAt": "2022-06-03T22:11:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449A2R",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T20:45:29Z",
          "updatedAt": "2022-04-27T20:45:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That feels more confusing to me. The value of the Version field is what's sent on the wire.",
              "createdAt": "2022-04-27T20:45:29Z",
              "updatedAt": "2022-04-27T20:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449CXe",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T20:52:03Z",
          "updatedAt": "2022-04-27T20:52:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Well, then how can it be different from what's in this field?",
              "createdAt": "2022-04-27T20:52:03Z",
              "updatedAt": "2022-04-27T20:52:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449Eug",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:02:15Z",
          "updatedAt": "2022-04-27T21:02:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Here's an example of a way we could have designed the v1-to-v2 compatible upgrade:\r\n* client sends INITIAL as `long_header_version=v1` with `chosen_version=v1, other_versions=(v1,v2)`\r\n* server sends INITIAL and HANDSHAKE as `long_header_version=v1` with `chosen_version=v2`\r\n* clients sends HANDSHAKE as `long_header_version=v1`\r\n* then all 1-RTT packets use v2\r\n\r\nThat's not how v2 looks today, but that was a possible design. In that scenario, the long_header_version doesn't match the chosen_version",
              "createdAt": "2022-04-27T21:02:15Z",
              "updatedAt": "2022-04-27T21:02:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449JLU",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:20:45Z",
          "updatedAt": "2022-04-27T21:20:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think this document should specify that that that's not how this works.",
              "createdAt": "2022-04-27T21:20:45Z",
              "updatedAt": "2022-04-27T21:20:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449JxU",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:23:38Z",
          "updatedAt": "2022-04-27T21:23:38Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Indeed, we effectively do:\r\n> Clients can determine the server's negotiated version by examining\r\nthe QUIC long header Version field. It is possible for the server to\r\ninitially send packets with the client's chosen version before switching to the\r\nnegotiated version (for example, this can happen when the client's Version\r\nInformation structured spans multiple packets; in that case the server might\r\nacknowledge the first packet in the client's chosen version and later switch to a\r\ndifferent negotiated version).\r\n",
              "createdAt": "2022-04-27T21:23:38Z",
              "updatedAt": "2022-04-27T21:23:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc449M1i",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-27T21:38:30Z",
          "updatedAt": "2022-04-27T21:38:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That text doesn't preclude sending the server's transport parameters before switching to the negotiated version",
              "createdAt": "2022-04-27T21:38:30Z",
              "updatedAt": "2022-04-27T21:38:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc47V6lA",
          "commit": {
            "abbreviatedOid": "44aaf3a"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-03T22:14:04Z",
          "updatedAt": "2022-06-03T22:14:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 109,
      "id": "PR_kwDODoD7vc45GLCz",
      "title": "Leave how to determine versions up to versions",
      "url": "https://github.com/quicwg/version-negotiation/pull/109",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-03T22:17:15Z",
      "updatedAt": "2022-06-08T14:29:00Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "cddbe2f568d6066b4b09bd0a4ead332e35ea7671",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "how_to_determine_version",
      "headRefOid": "be5fda0f55698298a95f84a84f73d124103d8a15",
      "closedAt": "2022-06-08T14:29:00Z",
      "mergedAt": "2022-06-08T14:28:59Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "110d27de9da3da0315486863e12c6039bef5a57d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc47V8I4",
          "commit": {
            "abbreviatedOid": "3683a73"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T22:28:19Z",
          "updatedAt": "2022-06-03T22:28:19Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Here's a proposal on a slightly different way to frame this:\r\n\r\n```\r\nIf a document specifies that a QUIC version is compatible with another,\r\nthat document MUST specify the mechanism by which endpoints are\r\nmade aware of the negotiated version. An example of such a mechanism\r\nis to have the client determine the server's negotiated version by\r\nexamining the QUIC long header Version field. Note that, in this example\r\nmechanism, it is possible for the server to initially send packets\r\nwith the client's chosen version before switching to the negotiated version\r\n(this can happen when the client's Version Information structure spans\r\nmultiple packets; in that case the server might acknowledge the first packet in\r\nthe client's chosen version and later switch to a different negotiated version).\r\nAny set of mutually compatible versions SHOULD use the same mechanism.\r\n```",
              "createdAt": "2022-06-03T22:28:19Z",
              "updatedAt": "2022-06-03T22:28:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc47V8UL",
          "commit": {
            "abbreviatedOid": "3683a73"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T22:29:53Z",
          "updatedAt": "2022-06-03T22:29:54Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I can live with this modulo \"by which endpoints\" -> \"by which clients\".",
              "createdAt": "2022-06-03T22:29:54Z",
              "updatedAt": "2022-06-03T22:29:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc47V8t5",
          "commit": {
            "abbreviatedOid": "3683a73"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T22:34:10Z",
          "updatedAt": "2022-06-03T22:34:10Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I pushed that change to this branch",
              "createdAt": "2022-06-03T22:34:10Z",
              "updatedAt": "2022-06-03T22:34:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDODoD7vc46lTHi",
      "title": "VN/v2 shepherd writeup",
      "url": "https://github.com/quicwg/version-negotiation/pull/110",
      "state": "MERGED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-29T17:07:48Z",
      "updatedAt": "2022-07-11T16:10:37Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "110d27de9da3da0315486863e12c6039bef5a57d",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "mjoras-patch-1",
      "headRefOid": "6bafd60087a0637ecf6883b8b22993baf46a2f4b",
      "closedAt": "2022-07-11T16:10:36Z",
      "mergedAt": "2022-07-11T16:10:36Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "0dadde4cc25e8607a3af79f20781d9b839501c92"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc49Bp3_",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good modulo two comments",
          "createdAt": "2022-06-29T18:52:18Z",
          "updatedAt": "2022-06-29T18:55:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Maybe also mention \"needed\" and \"correctly designed\"?",
              "createdAt": "2022-06-29T18:52:18Z",
              "updatedAt": "2022-06-29T18:55:03Z"
            },
            {
              "originalPosition": 75,
              "body": "The question also asks Why?",
              "createdAt": "2022-06-29T18:52:37Z",
              "updatedAt": "2022-06-29T18:55:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49BvWi",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:10:09Z",
          "updatedAt": "2022-06-29T19:10:09Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "The appropriate answer is \"Because\". (Snarky, because the question is a bit dumb)",
              "createdAt": "2022-06-29T19:10:09Z",
              "updatedAt": "2022-06-29T19:10:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49BxCy",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:16:16Z",
          "updatedAt": "2022-06-29T19:16:16Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I don't disagree with the question being dumb, but if you don't answer it here it might lead to a DISCUSS so an overzealous AD can get it answered",
              "createdAt": "2022-06-29T19:16:16Z",
              "updatedAt": "2022-06-29T19:16:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49Bzdu",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:25:43Z",
          "updatedAt": "2022-06-29T19:25:44Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Note that this writeup is based on the WIP shepherd doc PR that addresses some of the community feedback levied towards the latest writeup QA template. The usefulness of this question is an unresolved thread as far as I'm concerned - see https://github.com/ietf-tools/datatracker/pull/4042#discussion_r888515151",
              "createdAt": "2022-06-29T19:25:44Z",
              "updatedAt": "2022-06-29T19:25:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49B01Y",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:31:03Z",
          "updatedAt": "2022-06-29T19:31:03Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Fair, but saying \"Because the WG reached consensus on this being the long-term VN mechanism for QUIC\" doesn't hurt and might save the editors some time later :)",
              "createdAt": "2022-06-29T19:31:03Z",
              "updatedAt": "2022-06-29T19:31:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49B2f7",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:37:41Z",
          "updatedAt": "2022-06-29T19:37:42Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "sure, we aren't working to any word limit, it still boils down to \"because the WG declared consensus to do so\". And if that's ok, we can just make it a stock answer, which seems to defeat the purpose of the question as its currently posed.",
              "createdAt": "2022-06-29T19:37:42Z",
              "updatedAt": "2022-06-29T19:37:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49B4Jf",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:44:09Z",
          "updatedAt": "2022-06-29T19:44:10Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "To be clear I'm fully in agreement with working to improve the template, and would like to see that question removed. I'm just asking for us to not be guinea pigs with this document, I don't want to have discussions about the merit of the template question during this draft's IESG review",
              "createdAt": "2022-06-29T19:44:09Z",
              "updatedAt": "2022-06-29T19:44:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49B7S-",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:53:06Z",
          "updatedAt": "2022-06-29T19:53:06Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "That's a fair concern that I take on board. We don't want to make our editors lives hard for the sake of it, nor tie up the progress of this document. \r\n\r\nBut I'd honestly be surprised if someone objected to the statement \"because we have WG consensus it is\" while being happy with \"because we have WG consensus that the draft $foo explains how to do $foo is appropriate\"\r\n",
              "createdAt": "2022-06-29T19:53:06Z",
              "updatedAt": "2022-06-29T19:53:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49B-Ch",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T19:55:14Z",
          "updatedAt": "2022-06-29T19:55:14Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Oh the only difference is that it sounds slightly less snarky :-)",
              "createdAt": "2022-06-29T19:55:14Z",
              "updatedAt": "2022-06-29T19:55:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49CHWI",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T20:20:53Z",
          "updatedAt": "2022-06-29T20:20:53Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "yeah agree here, the answer is an easy direct one - omission here sticks out",
              "createdAt": "2022-06-29T20:20:53Z",
              "updatedAt": "2022-06-29T20:20:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc49CJJF",
          "commit": {
            "abbreviatedOid": "50c2f96"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-29T20:27:31Z",
          "updatedAt": "2022-06-29T20:27:31Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "VN has IANA considerations too, so we should cover that, possibly noting that the intended codepoint is in the 0-63 range, which is Specification Required",
              "createdAt": "2022-06-29T20:27:31Z",
              "updatedAt": "2022-06-29T20:27:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDODoD7vc47NGqO",
      "title": "INV -> INVARIANTS",
      "url": "https://github.com/quicwg/version-negotiation/pull/112",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #111",
      "createdAt": "2022-07-11T16:06:05Z",
      "updatedAt": "2022-07-11T16:24:29Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "110d27de9da3da0315486863e12c6039bef5a57d",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "inv-",
      "headRefOid": "de8776fd80c08192f24db2b049f0b3f399ca4a45",
      "closedAt": "2022-07-11T16:24:28Z",
      "mergedAt": "2022-07-11T16:24:28Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "2c19cafdeb637482f0ec06cf22e55a17c321bdc9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc49qwW7",
          "commit": {
            "abbreviatedOid": "de8776f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-11T16:24:23Z",
          "updatedAt": "2022-07-11T16:24:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 113,
      "id": "PR_kwDODoD7vc47NHrQ",
      "title": "nits: spellcheck",
      "url": "https://github.com/quicwg/version-negotiation/pull/113",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-11T16:10:08Z",
      "updatedAt": "2022-07-11T16:26:45Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "2c19cafdeb637482f0ec06cf22e55a17c321bdc9",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "spellcheck",
      "headRefOid": "788df8960259397ea47803813b8a7625023362e5",
      "closedAt": "2022-07-11T16:26:44Z",
      "mergedAt": "2022-07-11T16:26:44Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e193e1264887ffab5919d529ea21c0023989c1ec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc49qwfF",
          "commit": {
            "abbreviatedOid": "8784a2c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-11T16:24:50Z",
          "updatedAt": "2022-07-11T16:24:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDODoD7vc4-peLU",
      "title": "fix original version",
      "url": "https://github.com/quicwg/version-negotiation/pull/120",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #116",
      "createdAt": "2022-09-09T03:25:05Z",
      "updatedAt": "2022-09-13T19:58:32Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "e193e1264887ffab5919d529ea21c0023989c1ec",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "editorial116",
      "headRefOid": "121224bb9321c3a21238ac1ae14a4adfee572d3a",
      "closedAt": "2022-09-13T19:58:31Z",
      "mergedAt": "2022-09-13T19:58:31Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "dafc6c76d89ca266a1f48f0f05c3fc87ef32a2c4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 121,
      "id": "PR_kwDODoD7vc4-tdp1",
      "title": "Add reference for normative text",
      "url": "https://github.com/quicwg/version-negotiation/pull/121",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #117",
      "createdAt": "2022-09-10T00:55:48Z",
      "updatedAt": "2022-09-13T19:59:00Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "e193e1264887ffab5919d529ea21c0023989c1ec",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "fix117",
      "headRefOid": "fc33f3abf15a7be19042c458ab56fb51186ec064",
      "closedAt": "2022-09-13T19:58:59Z",
      "mergedAt": "2022-09-13T19:58:59Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "4163ee8f996ba7b1cf398bff851bc228f9478f5e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 122,
      "id": "PR_kwDODoD7vc4--qQg",
      "title": "Clarify validations on converted first flight",
      "url": "https://github.com/quicwg/version-negotiation/pull/122",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #118 ",
      "createdAt": "2022-09-14T21:56:44Z",
      "updatedAt": "2022-09-14T22:06:57Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "4163ee8f996ba7b1cf398bff851bc228f9478f5e",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "fix118",
      "headRefOid": "c36622125c976e7ec4befea39d8eeaff84f4c7c8",
      "closedAt": "2022-09-14T21:56:59Z",
      "mergedAt": "2022-09-14T21:56:59Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "7dc19524754d18c081b17fe2baac703af6e17585"
      },
      "comments": [
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "thanks for the fix.",
          "createdAt": "2022-09-14T22:06:57Z",
          "updatedAt": "2022-09-14T22:06:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 123,
      "id": "PR_kwDODoD7vc4--qgX",
      "title": "Make incompatible VN more normative",
      "url": "https://github.com/quicwg/version-negotiation/pull/123",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #119 ",
      "createdAt": "2022-09-14T21:58:24Z",
      "updatedAt": "2022-09-14T22:06:12Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "7dc19524754d18c081b17fe2baac703af6e17585",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "fix119",
      "headRefOid": "dc268a0750da52d8a323d479e32901ec7b315fa3",
      "closedAt": "2022-09-14T22:04:18Z",
      "mergedAt": "2022-09-14T22:04:18Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "7d09d445bc12376908ae3ab665c51dbddc7ff986"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5CDtLk",
          "commit": {
            "abbreviatedOid": "dc268a0"
          },
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2022-09-14T22:06:12Z",
          "updatedAt": "2022-09-14T22:06:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDODoD7vc4_os4D",
      "title": "Updates RFC 8999",
      "url": "https://github.com/quicwg/version-negotiation/pull/124",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #115 ",
      "createdAt": "2022-09-26T19:54:38Z",
      "updatedAt": "2022-09-27T18:09:43Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "7d09d445bc12376908ae3ab665c51dbddc7ff986",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "updates",
      "headRefOid": "5a59d8bb5b461e7f9245bdfa124a599214b2d05e",
      "closedAt": "2022-09-27T18:09:42Z",
      "mergedAt": "2022-09-27T18:09:42Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "434cc0b554e01705cd9127b6ec4221338230a9fe"
      },
      "comments": [
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "This PR just updates the tag. Which I think is not adequate. The abstract should clearly mention that it is updating 8999 and the respective sections should say what it is updating.",
          "createdAt": "2022-09-26T21:42:09Z",
          "updatedAt": "2022-09-26T21:42:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The whole document updates Section 6 of RFC 8999. I think it's sufficient to state that in a stand-alone sentence in the abstract and introduction.",
          "createdAt": "2022-09-26T22:09:36Z",
          "updatedAt": "2022-09-26T22:09:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As per the IETF tradition, I've modified the abstract to mention that this document updates RFC 8999. There is no requirement to update the introduction or the rest of the text.",
          "createdAt": "2022-09-26T23:06:41Z",
          "updatedAt": "2022-09-26T23:06:41Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "Please merge and update the datatracker version.",
          "createdAt": "2022-09-27T17:59:44Z",
          "updatedAt": "2022-09-27T17:59:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5Czltg",
          "commit": {
            "abbreviatedOid": "3e3f748"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-26T19:56:25Z",
          "updatedAt": "2022-09-26T19:56:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc5CztOI",
          "commit": {
            "abbreviatedOid": "3e3f748"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-26T20:20:09Z",
          "updatedAt": "2022-09-26T20:20:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc5C3V6F",
          "commit": {
            "abbreviatedOid": "5a59d8b"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-27T11:30:17Z",
          "updatedAt": "2022-09-27T11:30:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "PR_kwDODoD7vc4_uHGH",
      "title": "Specify how this document updates RFC 8999",
      "url": "https://github.com/quicwg/version-negotiation/pull/126",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a short text in the introduction section to define how this document updates RFC 8999.\r\n\r\nFixes #125 ",
      "createdAt": "2022-09-27T19:20:03Z",
      "updatedAt": "2022-09-28T00:38:22Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "0395eddf33863ad0b72bffc7c127157a906ca7d3",
      "headRepository": "huitema/version-negotiation",
      "headRefName": "main",
      "headRefOid": "6ba127192baf5d38426773fcfe6e4ae6f5fda5f0",
      "closedAt": "2022-09-28T00:38:22Z",
      "mergedAt": "2022-09-28T00:38:22Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "111f8aacb789eefcaa914f0badb150bf3d27abce"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for taking the time, Christian! I appreciate it.",
          "createdAt": "2022-09-28T00:38:17Z",
          "updatedAt": "2022-09-28T00:38:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5C6TnO",
          "commit": {
            "abbreviatedOid": "7b65340"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-27T19:39:56Z",
          "updatedAt": "2022-09-27T19:39:56Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "No need to redefine the references:\r\n\r\n```suggestion\r\nThis document updates {{QUIC-INVARIANTS}} by defining an alternative version\r\nnegotiation mechanism, while keeping the option to use the mechanism defined in\r\n{{QUIC-INVARIANTS}} for negotiating versions incompatible with the initially\r\nproposed value.\r\n```",
              "createdAt": "2022-09-27T19:39:56Z",
              "updatedAt": "2022-09-27T19:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5C6T6K",
          "commit": {
            "abbreviatedOid": "2403605"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-27T19:41:03Z",
          "updatedAt": "2022-09-27T19:41:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This text contradicts the start of the paragraph, QUIC-INVARIANTS does not define a version negotiation *mechanism*, it only defines a version negotiation *packet*.",
              "createdAt": "2022-09-27T19:41:03Z",
              "updatedAt": "2022-09-27T19:41:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5C6x3k",
          "commit": {
            "abbreviatedOid": "47a05e1"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-27T21:13:56Z",
          "updatedAt": "2022-09-27T21:13:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Simpler text, less likely to contradict other sentences. @DavidSchinazi, what do you think?",
              "createdAt": "2022-09-27T21:13:56Z",
              "updatedAt": "2022-09-27T21:13:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5C647V",
          "commit": {
            "abbreviatedOid": "47a05e1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-27T21:43:39Z",
          "updatedAt": "2022-09-27T21:43:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "How about this?\r\n```suggestion\r\nnegotiation mechanisms that leverage the Version Negotiation packet.\r\n```",
              "createdAt": "2022-09-27T21:43:39Z",
              "updatedAt": "2022-09-27T21:43:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5C7Vc_",
          "commit": {
            "abbreviatedOid": "47a05e1"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-28T00:04:09Z",
          "updatedAt": "2022-09-28T00:04:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That works, I merged your commit in the PR.",
              "createdAt": "2022-09-28T00:04:09Z",
              "updatedAt": "2022-09-28T00:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5C7aC6",
          "commit": {
            "abbreviatedOid": "6ba1271"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T00:37:32Z",
          "updatedAt": "2022-09-28T00:37:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDODoD7vc4_-Qo3",
      "title": "Explain what a downgrade is",
      "url": "https://github.com/quicwg/version-negotiation/pull/127",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was raised during the [OPSDIR review](https://mailarchive.ietf.org/arch/msg/quic/lIqqvtp1n40gqp21BuRT3XStbbE/)",
      "createdAt": "2022-09-30T22:24:28Z",
      "updatedAt": "2022-10-11T22:25:21Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "111f8aacb789eefcaa914f0badb150bf3d27abce",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "downgrade",
      "headRefOid": "f8232a9e736c99a91ff4d00f12a6fd7a8633313d",
      "closedAt": "2022-10-11T22:25:20Z",
      "mergedAt": "2022-10-11T22:25:20Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "d672e11c2db44ef4e6b42d7ea2a4f616baa676f7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5DNMpV",
          "commit": {
            "abbreviatedOid": "0f2752b"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-01T14:18:34Z",
          "updatedAt": "2022-10-01T14:18:49Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ndocument prevents this attack.\r\n```",
              "createdAt": "2022-10-01T14:18:34Z",
              "updatedAt": "2022-10-01T14:18:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5D11q8",
          "commit": {
            "abbreviatedOid": "d1ff463"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "With my comment.",
          "createdAt": "2022-10-11T21:39:53Z",
          "updatedAt": "2022-10-11T21:40:00Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ndocument is designed to prevent downgrade attacks.\r\n```",
              "createdAt": "2022-10-11T21:39:53Z",
              "updatedAt": "2022-10-11T21:40:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDODoD7vc4_-Q9J",
      "title": "Only clients can start incompatible VN",
      "url": "https://github.com/quicwg/version-negotiation/pull/128",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was raised during the [OPSDIR review](https://mailarchive.ietf.org/arch/msg/quic/lIqqvtp1n40gqp21BuRT3XStbbE/)",
      "createdAt": "2022-09-30T22:27:08Z",
      "updatedAt": "2022-10-11T22:29:33Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "111f8aacb789eefcaa914f0badb150bf3d27abce",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "no_client_incompat",
      "headRefOid": "d0449233db979e088b2902fd8728d983a3e65714",
      "closedAt": "2022-10-11T22:29:32Z",
      "mergedAt": "2022-10-11T22:29:32Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "eb9af6bfba520a6cf7dd822bcb895b85dd3607b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5D11ih",
          "commit": {
            "abbreviatedOid": "d044923"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-11T21:39:14Z",
          "updatedAt": "2022-10-11T21:39:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDODoD7vc5AmtB3",
      "title": "Attempt to clarify the examples",
      "url": "https://github.com/quicwg/version-negotiation/pull/130",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-11T22:16:12Z",
      "updatedAt": "2022-10-11T22:27:39Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "b07f813b0f4bedf874d2b6f50175d6a5de183560",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "clarify_examples",
      "headRefOid": "8652d817c0ac4d75f5aafd78a79a2742fcd87a25",
      "closedAt": "2022-10-11T22:27:38Z",
      "mergedAt": "2022-10-11T22:27:38Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "a46a8c975f8b6350305db5b3d0ce0f646a257fad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5D19N6",
          "commit": {
            "abbreviatedOid": "8652d81"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-11T22:18:18Z",
          "updatedAt": "2022-10-11T22:18:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "PR_kwDODoD7vc5Ar4b7",
      "title": "Mandate validation of Version Information",
      "url": "https://github.com/quicwg/version-negotiation/pull/131",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #129 ",
      "createdAt": "2022-10-12T21:34:49Z",
      "updatedAt": "2022-10-20T00:20:59Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "de26cb3b1cf91f97419e934b6c4bbb988c834766",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "enforce",
      "headRefOid": "b1d0d27f8c2defe46553dec4d36cf310ad205f39",
      "closedAt": "2022-10-20T00:20:58Z",
      "mergedAt": "2022-10-20T00:20:58Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b4e4cb853e1188a46469ce8deb7f00d99acefa42"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr confirmed offline that he can live with this PR as-is, so I'm merging it",
          "createdAt": "2022-10-20T00:20:52Z",
          "updatedAt": "2022-10-20T00:20:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5ECsgG",
          "commit": {
            "abbreviatedOid": "692c330"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-10-13T21:53:59Z",
          "updatedAt": "2022-10-13T21:53:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc5ECs_b",
          "commit": {
            "abbreviatedOid": "692c330"
          },
          "author": "anrossi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-13T21:56:31Z",
          "updatedAt": "2022-10-13T21:56:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7vc5EDb0f",
          "commit": {
            "abbreviatedOid": "692c330"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "See the long comment for why I think that this is not a good change (though there are definitely good bits).",
          "createdAt": "2022-10-14T03:04:45Z",
          "updatedAt": "2022-10-14T03:13:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "What is a parsing failure?  TRANSPORT_PARAMETER_ERROR or something else?",
              "createdAt": "2022-10-14T03:04:46Z",
              "updatedAt": "2022-10-14T03:13:22Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\na version negotiation error. For example, if a server receives the client's\r\n```",
              "createdAt": "2022-10-14T03:05:24Z",
              "updatedAt": "2022-10-14T03:13:22Z"
            },
            {
              "originalPosition": 20,
              "body": "Not sure if this is going to be correct in all cases.\r\n\r\nThe client might switch to using Version 2 if the server decides to upgrade.  Retransmissions of the ClientHello containing the Version Information might then be sent in Initial packets with a version == 2.\r\n\r\nNow, obviously, the server can't upgrade until it has read the Version Information, but there is a possibility that a client could retransmit stuff that the server already has.  This might be due to the Version Information being in a packet that the server received, processed, and acknowledged.  But the ACK might get lost and so the client might still end up sending another copy.\r\n\r\nAlso, I don't believe that this sort of validation is easy to implement.  The principle we apply here is that validation is mandated only where there is fairly uniform agreement that it is trivial to implement.  This is not.  It requires accessing information that is very hard to access in our stack.  In our stack, processing of Version Information occurs in a callback that is invoked by the TLS library.  For various reasons (mostly relating to how callbacks from C work with Rust and Rust's ownership rules), that processing cannot access a lot of connection-level state.  It certainly can't access details of the packet that was received, even if that would make sense.  After all, the data that the cryptographic handshake processes could come from multiple packets, some of which might have been received and long-since discarded.",
              "createdAt": "2022-10-14T03:12:30Z",
              "updatedAt": "2022-10-14T03:13:22Z"
            },
            {
              "originalPosition": 29,
              "body": "We didn't say this already?  Wow.  This is definitely needed.",
              "createdAt": "2022-10-14T03:12:54Z",
              "updatedAt": "2022-10-14T03:13:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5EHNUy",
          "commit": {
            "abbreviatedOid": "3458ae5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T17:07:49Z",
          "updatedAt": "2022-10-14T17:14:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's described earlier in this paragraph",
              "createdAt": "2022-10-14T17:07:49Z",
              "updatedAt": "2022-10-14T17:14:24Z"
            },
            {
              "originalPosition": 29,
              "body": "Agreed, this was assumed by all of us but not actually written down.",
              "createdAt": "2022-10-14T17:08:18Z",
              "updatedAt": "2022-10-14T17:14:24Z"
            },
            {
              "originalPosition": 20,
              "body": "The text above along discusses the client's first flight. The retransmission scenario would not be part of the first flight, by definition. The validation is trivial to implement because you have access to the version of the connection - we're not asking to keep track of the version of the packet carrying the CRYPTO frame, only the version of the first packet received. Your stack already has access to this during TP parsing because the TP parsing is version-dependent.",
              "createdAt": "2022-10-14T17:14:15Z",
              "updatedAt": "2022-10-14T17:14:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5Ecmq9",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T22:32:53Z",
          "updatedAt": "2022-10-19T22:35:14Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "What's the purpose of this requirement? Is it just a correctness check?",
              "createdAt": "2022-10-19T22:32:53Z",
              "updatedAt": "2022-10-19T22:35:14Z"
            },
            {
              "originalPosition": 18,
              "body": "I'm concerned about this \"for example\". Suppose we defined a QUIC v3 which used the same version field. In S 2.2. we said this was version specific and it has to be for any *pair* of versions.",
              "createdAt": "2022-10-19T22:34:27Z",
              "updatedAt": "2022-10-19T22:35:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5EcqvA",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T22:59:29Z",
          "updatedAt": "2022-10-19T22:59:29Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Yes, it makes sure that the server validates that the client follows the MUST.",
              "createdAt": "2022-10-19T22:59:29Z",
              "updatedAt": "2022-10-19T22:59:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5EcsZw",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:11:22Z",
          "updatedAt": "2022-10-19T23:11:22Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The QUIC version field contains the QUIC version, so I'm not sure I follow how QUIC version 3 would use the version field of 1.",
              "createdAt": "2022-10-19T23:11:22Z",
              "updatedAt": "2022-10-19T23:11:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5Ecspi",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:13:12Z",
          "updatedAt": "2022-10-19T23:13:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'm sorry, I don't follow this at all.",
              "createdAt": "2022-10-19T23:13:12Z",
              "updatedAt": "2022-10-19T23:13:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5Ecs6i",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:14:57Z",
          "updatedAt": "2022-10-19T23:14:57Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "NM. I misread this as the client determining the server version. I agree this text is fine.",
              "createdAt": "2022-10-19T23:14:57Z",
              "updatedAt": "2022-10-19T23:14:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5Ecs7Z",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:15:02Z",
          "updatedAt": "2022-10-19T23:15:03Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "In `Client-Sent Available Versions` we have `Note that the version in the Chosen Version field MUST be included in this list`. The text we're commenting on here asks the server to validate that the client followed that MUST",
              "createdAt": "2022-10-19T23:15:03Z",
              "updatedAt": "2022-10-19T23:15:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5EcsuB",
          "commit": {
            "abbreviatedOid": "4434a9c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:13:40Z",
          "updatedAt": "2022-10-19T23:16:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "No, it is not.  You really need to use the words \"parsing failure\" in the definition if you mean to invoke it with this text.",
              "createdAt": "2022-10-19T23:13:40Z",
              "updatedAt": "2022-10-19T23:16:27Z"
            },
            {
              "originalPosition": 18,
              "body": "I think that @ekr is implicitly referring to the potential for the version field to become ossified where we are forced to identify v3 in some other way.",
              "createdAt": "2022-10-19T23:15:39Z",
              "updatedAt": "2022-10-19T23:16:27Z"
            },
            {
              "originalPosition": 19,
              "body": "Still opposed to this MUST, for aforementioned reasons.",
              "createdAt": "2022-10-19T23:16:05Z",
              "updatedAt": "2022-10-19T23:16:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5EctOZ",
          "commit": {
            "abbreviatedOid": "692c330"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:17:11Z",
          "updatedAt": "2022-10-19T23:17:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "But there is no guarantee that the version information is in that first packet, so this is not that easy to implement.",
              "createdAt": "2022-10-19T23:17:11Z",
              "updatedAt": "2022-10-19T23:17:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5Ecubh",
          "commit": {
            "abbreviatedOid": "0a3335b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T23:25:18Z",
          "updatedAt": "2022-10-19T23:25:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sure. Fixed by explicitly using the words \"parsing failure\" above.",
              "createdAt": "2022-10-19T23:25:18Z",
              "updatedAt": "2022-10-19T23:25:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5EcxE-",
          "commit": {
            "abbreviatedOid": "0a3335b"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Sorry about the confusion.  Language choice lead me astray.  I already implemented this specific check.  I've suggested some wording that might avoid such confusion in future.  Maybe.",
          "createdAt": "2022-10-19T23:46:25Z",
          "updatedAt": "2022-10-19T23:48:25Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think that the problem I'm seeing here is rooted in the word \"parses\" and how it connects to the \"in use\" bit.  I think that you might want to use \"processes\" in the first instance.  For the second, use the version of the Initial packet that was used to open the connection rather than a potentially over-broad \"in use\".\r\n\r\nMaybe instead:\r\n\r\n> If the server processes Version Information from the client and the Chosen Version differs from the version of the packet that initiated the connection attempt, it MUST close the connection with a version negotiation error.\r\n\r\nHowever, this implies something about Retry packets, so I get why you went with \"in use\" to avoid that.  Maybe instead:\r\n\r\n\r\n> If the server processes Version Information from the client and the Chosen Version differs from the version from the version of packets the server has received for this connection attempt, it MUST close the connection with a version negotiation error.\r\n\r\nThat is, rely on an expectation that the client uses a single, consistent version for its connection attempt.",
              "createdAt": "2022-10-19T23:46:25Z",
              "updatedAt": "2022-10-19T23:48:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5Ec08T",
          "commit": {
            "abbreviatedOid": "b1d0d27"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "WFM.  David pointed out that this already defines \"in use\" and the change to \"processes\" is good.",
          "createdAt": "2022-10-20T00:18:59Z",
          "updatedAt": "2022-10-20T00:18:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDODoD7vc5FrNqm",
      "title": "Final IANA values",
      "url": "https://github.com/quicwg/version-negotiation/pull/132",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See [the registry](https://www.iana.org/assignments/quic/quic.xhtml)",
      "createdAt": "2022-12-16T21:00:05Z",
      "updatedAt": "2022-12-19T20:27:37Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "85d2a7658bca23083f1225d604a1454c803184a0",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "iana_final",
      "headRefOid": "7916a4dd30588c7f4c2b39c490b44f135d496253",
      "closedAt": "2022-12-19T20:27:37Z",
      "mergedAt": "2022-12-19T20:27:37Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "710b89b1194afce80f05eee5859a6d34133150e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5I1-KL",
          "commit": {
            "abbreviatedOid": "7916a4d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This matches the registry.  17!",
          "createdAt": "2022-12-18T23:10:56Z",
          "updatedAt": "2022-12-18T23:10:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDODoD7vc5K-v_E",
      "title": "AUTH48 changes",
      "url": "https://github.com/quicwg/version-negotiation/pull/133",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes from AUTH48 process.\r\n\r\n[Rendered view of this PR](https://quicwg.github.io/version-negotiation/auth48/draft-ietf-quic-version-negotiation.html)\r\n[Diff with main](https://author-tools.ietf.org/iddiff?url1=https://quicwg.github.io/version-negotiation/draft-ietf-quic-version-negotiation.txt&url2=https://quicwg.github.io/version-negotiation/auth48/draft-ietf-quic-version-negotiation.txt)\r\n[Diff with the RFC Editor's copy](https://author-tools.ietf.org/iddiff?url1=https://quicwg.github.io/version-negotiation/auth48/draft-ietf-quic-version-negotiation.txt&url2=https://www.rfc-editor.org/authors/rfc9368.txt)",
      "createdAt": "2023-03-01T00:08:20Z",
      "updatedAt": "2023-05-17T20:48:14Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "main",
      "baseRefOid": "710b89b1194afce80f05eee5859a6d34133150e6",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "auth48",
      "headRefOid": "1e648dc137e40eb74c0d4f8fd0e1e9e759ccd79c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5Tn915",
          "commit": {
            "abbreviatedOid": "6bcdca6"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-04-26T23:43:59Z",
          "updatedAt": "2023-04-26T23:52:15Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "This is unnecessary. \r\n\r\nhttp://itre.cis.upenn.edu/~myl/languagelog/archives/001484.html\r\n```suggestion\r\nwhich leverages similarities between versions and can negotiate between\r\n```\r\n",
              "createdAt": "2023-04-26T23:43:59Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nand \"compatible\", that allows saving the round trip but only applies when the\r\n```",
              "createdAt": "2023-04-26T23:44:35Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 127,
              "body": "```suggestion\r\nOnly servers can start incompatible version negotiation. Clients MUST NOT send\r\n```",
              "createdAt": "2023-04-26T23:46:18Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 137,
              "body": "```suggestion\r\nwith A. Note that the conversion of the first flight can be lossy; some data,\r\n```",
              "createdAt": "2023-04-26T23:47:15Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\nVersion compatibility is not symmetric. It is possible for version A to be\r\n```",
              "createdAt": "2023-04-26T23:47:43Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\n: The version that the sender has chosen to use for this connection. In most\r\n```",
              "createdAt": "2023-04-26T23:50:19Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 338,
              "body": "```suggestion\r\nThe contents of the Available Versions field depend on whether it is sent by\r\n```",
              "createdAt": "2023-04-26T23:50:35Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 496,
              "body": "```suggestion\r\nreach a different server instance which hasn't been updated yet.\r\n```",
              "createdAt": "2023-04-26T23:51:24Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            },
            {
              "originalPosition": 582,
              "body": "```suggestion\r\nQUIC version 1 defines multiple features whch are not documented in the QUIC\r\n```",
              "createdAt": "2023-04-26T23:51:56Z",
              "updatedAt": "2023-04-26T23:52:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDODoD7vc5PVsPl",
      "title": "Ekr editorial auth48",
      "url": "https://github.com/quicwg/version-negotiation/pull/134",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-27T22:42:52Z",
      "updatedAt": "2023-05-11T22:47:18Z",
      "baseRepository": "quicwg/version-negotiation",
      "baseRefName": "auth48",
      "baseRefOid": "6bcdca62888da1a0f250e3f7752bc3d3f390466b",
      "headRepository": "quicwg/version-negotiation",
      "headRefName": "ekr_editorial_auth48",
      "headRefOid": "b57b0d93b1d39005279f5d24048465136d50725e",
      "closedAt": "2023-05-11T22:47:17Z",
      "mergedAt": "2023-05-11T22:47:17Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "fd72bceb4f8a44c66154007e80ac2db4a3ecd6c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7vc5T0kDm",
          "commit": {
            "abbreviatedOid": "64c34e4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Overall this LGTM, some comments inline.",
          "createdAt": "2023-04-28T16:45:52Z",
          "updatedAt": "2023-04-28T21:18:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This intentionally used \"will\" to avoid repeating the normative statement from the downgrade section, I'd prefer to keep it that way.",
              "createdAt": "2023-04-28T16:45:52Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 17,
              "body": "Similarly, this was intentional to avoid repeating 8999",
              "createdAt": "2023-04-28T21:01:11Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 35,
              "body": "I'm not sure what \"examining packets outside of the handshake\" means. INITIAL packets are still part of the handshake in the generic sense.\r\n\r\nI suspect you meant something like \"examining data that is not covered by the handshake transcript\" but that's a mouthful and also quite specific to v1\r\n\r\nHow about just \"This may involve examining the long header Version field.\"?",
              "createdAt": "2023-04-28T21:07:22Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nIn the specific case of QUIC version 1, the server determines that version 1 is in use\r\n```",
              "createdAt": "2023-04-28T21:10:28Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nis set to 0x00000001. Subsequently, if the server receives the client's Version\r\n```",
              "createdAt": "2023-04-28T21:10:50Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 62,
              "body": "For this paragraph I personally find the previous phrasing easier to reason about, but I don't feel too strongly",
              "createdAt": "2023-04-28T21:12:58Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nVersion Negotiation packet and the server's Version Information was missing, the client\r\n```",
              "createdAt": "2023-04-28T21:13:46Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            },
            {
              "originalPosition": 67,
              "body": "Good catch!",
              "createdAt": "2023-04-28T21:17:20Z",
              "updatedAt": "2023-04-28T21:18:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5T10wk",
          "commit": {
            "abbreviatedOid": "64c34e4"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T21:22:34Z",
          "updatedAt": "2023-04-28T21:26:05Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Well, it might involve examining something else. E.g., the length of the packet.",
              "createdAt": "2023-04-28T21:22:34Z",
              "updatedAt": "2023-04-28T21:26:05Z"
            },
            {
              "originalPosition": 16,
              "body": "I'm not comfortable with a naked \"will\" like this. If you want to cite to the downgrade section, I'm fine with that.",
              "createdAt": "2023-04-28T21:23:28Z",
              "updatedAt": "2023-04-28T21:26:05Z"
            },
            {
              "originalPosition": 17,
              "body": "See above. My problem is that naked statements of how the client behaves need to be supported by something. If you want to put (as required by...) that would be fine.",
              "createdAt": "2023-04-28T21:24:01Z",
              "updatedAt": "2023-04-28T21:26:05Z"
            },
            {
              "originalPosition": 62,
              "body": "I found the ordering pretty confusing. Happy to look at yet another alternative if you want.",
              "createdAt": "2023-04-28T21:25:02Z",
              "updatedAt": "2023-04-28T21:26:05Z"
            },
            {
              "originalPosition": 56,
              "body": "Hmm.. This paragraph or not, it seems that *both* endpoints look at the long header, no?",
              "createdAt": "2023-04-28T21:25:43Z",
              "updatedAt": "2023-04-28T21:26:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5T13AK",
          "commit": {
            "abbreviatedOid": "eff954f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T21:35:56Z",
          "updatedAt": "2023-04-28T21:35:56Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Don't we cite that section in that sentence? Keeping `will` and replacing `(see {{downgrade}})` with `, as required by {{downgrade}}` SGTM though",
              "createdAt": "2023-04-28T21:35:56Z",
              "updatedAt": "2023-04-28T21:35:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5T13F5",
          "commit": {
            "abbreviatedOid": "3a10a64"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T21:36:29Z",
          "updatedAt": "2023-04-28T21:36:29Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Agreed. But I still don't understand what \"packets outside of the handshake\" means",
              "createdAt": "2023-04-28T21:36:29Z",
              "updatedAt": "2023-04-28T21:36:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5T13SO",
          "commit": {
            "abbreviatedOid": "64c34e4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T21:37:36Z",
          "updatedAt": "2023-04-28T21:37:37Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Well yeah, but the server is the one reading the client's Version",
              "createdAt": "2023-04-28T21:37:37Z",
              "updatedAt": "2023-04-28T21:37:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5T13t6",
          "commit": {
            "abbreviatedOid": "64c34e4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T21:40:15Z",
          "updatedAt": "2023-04-28T21:40:15Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "This ordering works for me, let's keep yours.",
              "createdAt": "2023-04-28T21:40:15Z",
              "updatedAt": "2023-04-28T21:40:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5U2Nb9",
          "commit": {
            "abbreviatedOid": "64c34e4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T21:55:30Z",
          "updatedAt": "2023-05-11T22:08:05Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nClients will ignore a Version Negotiation packet if it contains the Original\r\nVersion attempted by the client, as required by {{downgrade}}. The client also ignores a\r\nVersion Negotiation packet that contains incorrect connection ID fields, as required by\r\n{{Section 6 of QUIC-INVARIANTS}}.\r\n```",
              "createdAt": "2023-05-11T21:55:30Z",
              "updatedAt": "2023-05-11T22:08:05Z"
            },
            {
              "originalPosition": 72,
              "body": "GitHub is silly so I can't comment further down, but can you s/is made aware/can be made aware/ on line 479?\r\n\r\nSimilarly, s/will/MUST/ on line 657",
              "createdAt": "2023-05-11T22:02:17Z",
              "updatedAt": "2023-05-11T22:08:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5U2UYP",
          "commit": {
            "abbreviatedOid": "0c360c5"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T22:21:46Z",
          "updatedAt": "2023-05-11T22:21:47Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "PTAL",
              "createdAt": "2023-05-11T22:21:46Z",
              "updatedAt": "2023-05-11T22:21:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7vc5U2Wwi",
          "commit": {
            "abbreviatedOid": "8a5edd7"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo one last tweak",
          "createdAt": "2023-05-11T22:34:46Z",
          "updatedAt": "2023-05-11T22:37:07Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nproperly parse the first flight. This may involve examining data\r\nthat is not part of the handshake transcript, such as parts of the\r\n```",
              "createdAt": "2023-05-11T22:34:46Z",
              "updatedAt": "2023-05-11T22:37:08Z"
            }
          ]
        }
      ]
    }
  ]
}